#include "kalanjiyamwindow.h"
#include "treemodel_dnd.h"
#include "image_treemodel_dnd.h"
#include "image_treemodel_dnd.cc"
#include <cairomm/cairomm.h>
#include <iostream>  
#include <fstream>
#include <Python.h>

#include <sys/stat.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>

/*Directory Access*/
#include <sys/types.h> 
#include <sys/stat.h>
/*Directory Access*/

/*Directory deletion*/
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <ftw.h>
/*Directory deletion*/

#include <vector>
#include <string> //

/*RapidXml*/
#include <cstdlib>
#include "rapidxml.hpp"
#include <sstream>
#include <vector>
#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/replace.hpp>
using namespace std;
using namespace rapidxml;
/*RapidXml*/


#include <boost/progress.hpp>
/**/
#include <Magick++.h>
#include <boost/lexical_cast.hpp>
#include<boost/tokenizer.hpp>
using namespace boost;
using namespace std;
using namespace Magick;
/**/

/*Images load*/
#include <dirent.h>
#include<stdio.h>
#include<iostream>
#include <boost/algorithm/string.hpp>
/*Images load*/

/*Load External Applications*/
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
/*Load External Applications*/

#include <ctime>
time_t start1;


int text_status=0;
int wid=0;
int hei=0;
/*Thumbnail*/
//Glib::ustring str;
static int file_open_confirm_flag=0;
static int mcanvas_show_flag=0;
std::string global_name;
std::string final;
std::vector<std::string> thump_list;
Glib::ustring scene_number;
Glib::ustring full_scene_name;
Glib::ustring full_shot_name;
int total_rows;
int total_rows1;
int selection_value;
int selection_value1;
int selec;
int rows_altered;
int rows_altered1;
int k1;
int zxc=0;	
int scene_shot_check_flag=0;
int shot_flag=0;
int drop_flag=0;
int del_flag=0;
 Goocanvas::Bounds ram;
int my_scene_number=1;
/*Thumbnail*/
int add_scn_status=0;
int shot_parse_status=0;
/*Pdf*/
int ij=0;
const char * abc11; 
#include <cairomm/cairomm.h>
#include <iostream>
#include <cairo-pdf.h>
#include <pango/pangocairo.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <string>
#include <boost/lexical_cast.hpp>
/*Pdf*/

/*xml*/
std::vector<std::string>xml_scene_overall_tag; 
std::vector<std::string>::iterator xml_scene_overall_tag_it;

std::vector<std::string>xml_kalanjiyam_overall_tag; 
std::vector<std::string>::iterator xml_kalanjiyam_overall_tag_it;

Glib::ustring global_temp_scene_xml;
Glib::ustring polyline_tag;
Glib::ustring curve_tag;
/*xml*/

const char* open_global_fillcolor_hex=g_strdup_printf("#%02x%02x%02x",00000,00000,00000);
const char* open_global_strokecolor_hex=g_strdup_printf("#%02x%02x%02x",00000,00000,00000);

Gtk::Window* pDialog = 0;
Gtk::EventBox* event1 = 0;
Gtk::Window* pAboutDialog = 0;
Gtk::Button* pAboutOkay = 0;
Gtk::Window* pPreferenceDialog = 0;
Gtk::Window* pInfoDialog = 0;
Gtk::Button* pPreferenceOkay = 0;
Gtk::Window* pSceneShotMoveDialog = 0;
Gtk::Label* pInfoLabel = 0;
Gtk::Window* pConfirmDialog = 0;
Gtk::Label* pConfirmLabel = 0;
Gtk::Label* pSceneShotMoveInfoLabel = 0;

Gtk::DrawingArea* darea = 0;
Gtk::DrawingArea* darea2 = 0;
std::string brush_var;
Gtk::Button* pButton = 0;
GdkColor color;
Gtk::Statusbar *pSbar = 0;

/*layer*/
Gtk::Viewport* v_port = 0;
Gtk::Viewport* vt_port = 0;
Gtk::Viewport* v_port8 = 0;
Gtk::Viewport* pImagesTab = 0;
/*layer*/

Gtk::Toolbar *toolbar = 0;  //top toolbar
Gtk::Box* pViewport = 0;  //property bar
Gtk::HandleBox* toolswindow = 0; //left-side tools window
Gtk::CheckMenuItem *tToolpallete = 0;
Gtk::HandleBox* phan = 0;  //kalanjiyam info
Gtk::FontButton *pFontButton;

//Gtk::ToolButton* pfull = 0;
static int group_item_no=0; //Group
static int grouping_flag=0; //Group
static int full_screen_mode = 0;
static int show_thumbnail_mode = 0;
static int toolbar_mode = 1;
static int propertyBar_mode = 1;
static int toolPallete_mode = 1;
static int kalanjiyaInfo_mode = 1;
static int thumbnail_mode = 1;
static int grid_mode = 1;
static int global_move_status = 0;
//static int grid_child_num;
static int button_press_status = 1;
static int on_parse_value_status = 0;

static int child_num=0;
static int last_child_num;
static int move_var;
static int child_var;
static int polyline_cnt=0;
static int curve_cnt=0;
static int curve_rect_num;
static int dragging_var=0;
static double starting_x;
std::string group_var; 
static double xx1,yy1,xx2,yy2,xx3,yy3,xx4,yy4,xx5,yy5,xx6,yy6,xx7,yy7,xx8,yy8,ww1,hh1;
int for_grp_check = 0;
/*Group*/
static double grp_xx;
static double grp_yy;
static double grp_ww;
static double grp_hh;
std::vector<std::string> group_child_total_list;
std::vector<std::string> group_child_total_list_buffer;
std::vector<int> group_child_no;
std::vector<int> group_child_buffer_no;
std::vector<int> group_child_buffer1_no;
std::vector<int> grouped_child_no;
std::vector<int> eraser_grouped_child_no;
std::vector<int> group_child_region_no;
std::vector<double> group_xx;
std::vector<double> group_yy;
std::vector<double> group_end_xx;
std::vector<double> group_end_yy;
/*Group*/

static int global_group_status;
static int copy_status;
std::vector<std::string>copy_tag_vector;
std::vector<std::string>copy_group_temp_vector;
std::vector<int>copy_single_temp_vector;
std::vector<int>copy_single_index_temp_vector;

/*Undo-Redo*/
std::vector<std::string> undo_redo_tag_vector;
std::vector<int> undo_redo_child_number_vector;
std::vector<int> undo_redo_delete_status_vector;
std::vector<int> undo_redo_position_vector;
std::vector<std::string> undo_redo_buffer_for_group;
std::vector<std::string> undo_redo_buffer_for_ungroup;
static int standing_position;
static int undo_status=0;
static int undo_count=0;
static int action_status=0;
static int group_select=0;
static int copy_paste_status=0;
static int standing_position_value=0;
/*Undo-Redo*/

std::string curve_var;

Glib::RefPtr<Goocanvas::Item> root;
Glib::RefPtr<Goocanvas::Grid> grid ;
Glib::RefPtr<Gdk::Window> m_refDrawable;
Glib::RefPtr<Goocanvas::Rect> rect;

/*ToolBar*/
Gtk::ToolButton* tSave = 0;
Gtk::ToolButton* tImportImage = 0;
Gtk::ToggleToolButton* tShowThumbnail = 0;
/*ToolBar*/

/*File Menu*/
Gtk::ImageMenuItem *pNew = 0;
Gtk::ImageMenuItem *pOpen = 0;
Gtk::ImageMenuItem *pSave = 0;
Gtk::ImageMenuItem *pSaveAs = 0;
Gtk::ImageMenuItem *pExport = 0;
Gtk::ImageMenuItem *pProperties = 0;
Gtk::ImageMenuItem *pPpreview = 0;
Gtk::ImageMenuItem *pPpreviewFile1 = 0;
Gtk::ImageMenuItem *pPpreviewFile2 = 0;
Gtk::ImageMenuItem *pPpreviewFile3 = 0;
Gtk::ImageMenuItem *pPpreviewFile4 = 0;
Gtk::ImageMenuItem *pPpreviewFile5 = 0;
Gtk::ImageMenuItem *pPpreviewFile6 = 0;
Gtk::ImageMenuItem *pExportFile1 = 0;
Gtk::ImageMenuItem *pExportFile2 = 0;
Gtk::ImageMenuItem *pExportFile3 = 0;
Gtk::ImageMenuItem *pExportFile4 = 0;

Gtk::ImageMenuItem *pPrintAll = 0;
Gtk::ImageMenuItem *pPrintFile1 = 0;
Gtk::ImageMenuItem *pPrintFile2 = 0;
Gtk::ImageMenuItem *pPrintFile3 = 0;
Gtk::ImageMenuItem *pPrintFile4 = 0;
Gtk::ImageMenuItem *pPrintFile5 = 0;
Gtk::ImageMenuItem *pPrintFile6 = 0;
Gtk::ImageMenuItem *pExit = 0;
/*File menu*/ 

/*Edit menu*/
Gtk::ImageMenuItem *pCopy = 0;
Gtk::ImageMenuItem *pPaste = 0;
Gtk::ImageMenuItem *pUndo = 0;
Gtk::ImageMenuItem *pRedo = 0;
Gtk::ImageMenuItem *pMoveUp = 0;
Gtk::ImageMenuItem *pMoveDown = 0;
Gtk::ImageMenuItem *pMoveLeft = 0;
Gtk::ImageMenuItem *pMoveRight = 0;
Gtk::ImageMenuItem *pGroup = 0;
Gtk::ImageMenuItem *pUnGroup = 0;
Gtk::ImageMenuItem *pRaiseToFront = 0;
Gtk::ImageMenuItem *pRaiseToTop = 0;
Gtk::ImageMenuItem *pLowerToBack = 0;
Gtk::ImageMenuItem *pLowerToBottom = 0;
Gtk::ImageMenuItem *pClearSelected = 0;
Gtk::ImageMenuItem *pClearWindow = 0;
/*Edit menu*/

/*View menu*/
Gtk::CheckMenuItem *tToolbar = 0;
Gtk::CheckMenuItem *pPropertybar =- 0;
Gtk::CheckMenuItem *pToolpallete = 0;
Gtk::CheckMenuItem *tKalanjiyaminfo = 0;
Gtk::CheckMenuItem *tThumbnail = 0;
Gtk::CheckMenuItem *tGrid = 0;
Gtk::ImageMenuItem *pZoomIn = 0;
Gtk::ImageMenuItem *pZoomOut = 0;
Gtk::ImageMenuItem *pResetZoom = 0;
Gtk::ImageMenuItem *pFullScreen = 0;
/*View menu*/

/*Navigation menu*/
Gtk::ImageMenuItem *pFirstPanel = 0;
Gtk::ImageMenuItem *pPreviousPanel = 0;
Gtk::ImageMenuItem *pNextPanel = 0;
Gtk::ImageMenuItem *pLastPanel = 0;
/*Navigation menu*/

/*Kalanjiyam menu*/
Gtk::ImageMenuItem *pAddScene = 0;
Gtk::ImageMenuItem *pAddShot = 0;
Gtk::ImageMenuItem *pScShMove = 0;
Gtk::ImageMenuItem *pImportImage = 0;
Gtk::ImageMenuItem *pExportImage = 0;
Gtk::ImageMenuItem *pLoadExternalEditor = 0;
Gtk::ImageMenuItem *pShortcut = 0;
/*Kalanjiyam menu*/

/*About menu*/
Gtk::ImageMenuItem *pQuickStart = 0;
Gtk::ImageMenuItem *pOnTheWeb = 0;
Gtk::ImageMenuItem *pAbout = 0;
/*About menu*/

/*Toolbar*/
Glib::RefPtr<Gtk::Builder> refBuilder;
/*Toolbar*/

/*Text*/
Gtk::ToolButton* tTextTool = 0;
Gtk::ToolButton* tTextOkay = 0;
Gtk::ToolButton* tTextCancel = 0;
Gtk::TextView *pTextTool = 0;
/*Text*/

/* Kalanjiyam Info */
Gtk::Entry *pSceneNumber = 0;
Gtk::Entry *pShotNumber = 0;

Gtk::Entry *pProjectName = 0;
Gtk::Entry *pProjectClient = 0;
Gtk::Entry *pProjectCopy = 0;

Gtk::Entry *pSceneTitle = 0;
Gtk::TextView *pDialogue = 0;
Gtk::TextView *pActionNotes = 0;
Gtk::TextView *pAudioNotes = 0;
Glib::RefPtr<Gtk::TextBuffer> text_buffer;

Glib::ustring SceneNumber;
Glib::ustring ShotNumber;
Glib::ustring ShotType;
Glib::ustring TotalFrames;
Glib::ustring SceneTitle;
Glib::ustring Dialogue;
Glib::ustring ActionNotes;
Glib::ustring AudioNotes;
int scene_shot_comparision_status = 0;
/* Kalanjiyam Info*/

/*Propertybar*/
Gtk::Box *pBorderWidth = 0;
Gtk::Box *pEraserWidth = 0;
Gtk::Box *pFont = 0;
Gtk::Box *pStrokeColor = 0;
Gtk::Box *pFillColor = 0;
Gtk::Box *pBorderXradius = 0;
Gtk::Box *pBorderYradius = 0;
Gtk::Box *pShape = 0;
/*Propertybar*/

/*Notebook*/
Gtk::Notebook* pNotebook = 0;
/*Notebook*/

/*SpinButton*/
Gtk::SpinButton *pSpinBorderWidth = 0;
Gtk::SpinButton *pSpinEraserWidth = 0;
Gtk::SpinButton *pSpinBorderXRadius = 0;
Gtk::SpinButton *pSpinBorderYRadius = 0;

Gtk::SpinButton *pTotalFrames = 0;

Gtk::Adjustment *pAdjBorderWidth = 0;
Gtk::Adjustment *pAdjEraserWidth = 0;
Gtk::Adjustment *pAdjBorderXRadius = 0;
Gtk::Adjustment *pAdjBorderYRadius = 0;
static int border_width=1;
static int eraser_width=1;
static int border_x_radius=0;
static int border_y_radius=0;
const char* open_node_name = "";
const char* open_node_value = "";
const char* open_attr_name = "";
const char* open_attr_value = "";
/*SpinButton*/

/*Shapes*/
Gtk::Button* pShape1 = 0;
Gtk::Button* pShape1_1 = 0;
Gtk::Button* pShape1_2 = 0;
Gtk::Button* pShape1_3 = 0;
Gtk::Button* pShape1_4 = 0;
/*Shapes*/

/*Preference Combo box*/
Gtk::Box *pPreferBox = 0;
/*Preference Combo box*/

/*sc-sh move*/
Gtk::Box *pSourceMove = 0;
Gtk::Box *pDestinationMove = 0;
Gtk::Button* MoveOkay = 0;
Gtk::Button* MoveCancel = 0;
/*sc-sh move*/

/*confirm okay cancel*/
Gtk::Button *pConfirmOkay = 0;
Gtk::Button *pConfirmCancel = 0;
/*confirm okay cancel*/

std::vector<Glib::ustring> dir_to_show_names;
Glib::ustring str;
Glib::ustring str1;

/*xml vector*/
Glib::ustring img_tmp_path = "/tmp/Kalanjiyam/Images/";
Glib::ustring thumbnail_tmp_path = "/tmp/Kalanjiyam/Thumbnails/";
Glib::ustring active_file_name = "";
Glib::ustring active_file_name1 = "";
Glib::ustring active_file_name2 = "";
Glib::ustring active_file_name3 = "";
Glib::ustring active_folder_name = "";
Glib::ustring SaveAs_file_name = "";
Glib::ustring pdf_folder_path = "";

/*Open-drawing-variables*/
static double open_global_x;
static double open_global_y;
static double open_global_width;
static double open_global_height;
Glib::ustring open_global_strokecolor;
Glib::ustring open_global_fillcolor;
static int open_global_linewidth;
static int open_global_new_linewidth;
std::vector<int>open_global_new_linewidth_vector;
static double open_global_xposition = 0;
static double open_global_yposition = 0;
static double open_global_centerx;
static double open_global_centery;
static int open_global_xradius;
static int open_global_yradius;
static double open_global_x1;
static double open_global_y1;
static double open_global_x2;
static double open_global_y2;
Glib::ustring open_global_image_data;
Glib::ustring open_global_data;
Glib::ustring open_global_font;
/*Open-drawing-variables*/

static int zoom_step_count = 0;

Image image;
static int loaded_img_count = 1;

static int scno=0;
static int shno=0;
std::string s6;
std::string s7;
Glib::ustring result;
const char *char_ShotNumber;
const char *char_SceneNumber;

int flag_sample=0;
int drawing_tool_number = 0; 


static int correct_scene_shot_position_occured = 0;
static int global_current_scene_number = 1;
static int global_current_shot_number = 1;
static int global_total_panels_in_thumbnail = 1;

std::vector<std::string>global_scene_shot_number_list_vector;
std::vector<std::string>::iterator global_scene_shot_number_list_vector_it;

int flag_delete=0;
int zxc_flag=0;
int scene_number_for_use = 1;
int shot_number_for_use = 1;
int flag_delete1=0;

int ctr_pt_press=0;
int item_pos;
int col_flag=0;
gint response; 
Glib::RefPtr<Goocanvas::Item> my_item;
int vec_pos;
int edit_flag =0;
const char* fillcolor =g_strdup_printf("#%02x%02x%02x",00000,00000,00000);
const char* strokecolor =g_strdup_printf("#%02x%02x%02x",00000,00000,00000);

/*Raise*/
std::vector<int>raise_current_child_temp_vector;
std::vector<int>raise_next_child_temp_vector;
int current_clicked_item;
/*Raise*/

static int to_create_thumbnail1_dot_png_initially = 1;
static int source_index;
static int release_index;
static int ConfirmStatus;

const char* save_file_name;

int scene_sel=0;
int shot_sel=0;
int scene_sel_flag=0;
int global_number_of_children;

/*Pdf*/
const char *global_char_projectname;
const char *global_char_projectclient;
const char *global_char_projectcopy;
const char *global_char_projectsize;
Glib::ustring ProjectName;
Glib::ustring ProjectClient;
Glib::ustring ProjectCopyright;
Glib::ustring Projectsize;
/*Pdf*/

static int text_edit_index_value=0;
static int on_description_save=0;

//For Eraser tool starts
string value_of_x;
string value_of_y;
string value_of_xx;
string value_of_yy;
int find_child_item;
static double path_old_x, path_old_y, last_motion_x, last_motion_y, image_old_x,image_old_y;

std::vector<std::string> my_str1_tag_modified;
std::vector<std::string> my_str1_tag_modified1;
std::string erased_value;
string my_str1_tag_modified5;

Glib::ustring path_tag_after_eraser="";
int current_clicked_item_for_group_erase;
std::vector<std::string>undo_vector_for_group_erase;
int group_indext_number;

std::string erased_path_merge_data;
std::string erased_path_merge1_data;  
int erase_flag = 0;
std::string my_str1_last_tag_modified;
std::string my_str1_tag;
int count_for_my_str1=0;
std::string brush_var1;
std::vector<std::string>split_x_y;  
std::vector<std::string>combined_x_y; 
int eraser_status = 0;
float button_press_x ;
float button_press_image_x ;
float button_press_image_y ;
float button_dragging_x;
float button_dragging_y;
float button_release_x;
float button_press_y ;
float button_release_y;
float global_x_diff ;
float global_y_diff ;
float different_move_x ;
float different_move_y ;
//std::vector<std::string>press_x_y;
string press_x_y; 
int image_eraser_undo_status=0;

int number_for_image;

int eraser_drag_flag = 0;


std::vector<std::string>split_width_height;  
std::vector<std::string>combined_width_height;  

std::vector<std::string>for_group_image_resize;  
std::vector<std::string>for_image_indentification;  
std::vector<std::string>for_group_image_move;  

float event_y_pos=0;
float event_x_pos=0;

float button_press_width ;
float button_release_width;
float button_press_height ;
float button_release_height;

float global_width_diff ;
float global_height_diff ;

float different_move_width ;
float different_move_height ;


std::vector<std::string>press_width_height; 
int image_edit_status=0;

int grouped_item_num=0;

std::vector<std::string>store_brush_value_for_erase;
std::vector<std::string>store_brush_value_for_erase1;

std::vector<std::string>first_vector_for_eraser; 
std::vector<std::string>second_vector_for_eraser; 

static int eraser_release_cnt=1;
static int z_count;
//For Eraser tool ends
string open_node_name_ellipse="open";
string open_node_name_ellipse_string="2";
int open_node_name_curve=0;
int come_from_line_change =0;
static int m_count;
//For Eraser tool ends

string open_node_name_line="open1";
string open_node_name_line_string="2";

int child_find;
int flag_set_for_find_child=0;
int changed_item_num=0;
int erase_dragging_status = 0;
int for_image_set = 0;
//For Eraser tool ends
Glib::ustring open_global_python_data;

int cancel_flag=0;
int flag_for_replace=0;

int ok_flag=0;
int image_status=0;
int right_click_press_status = 0;

float for_group_xx, for_group_yy, for_group_ww, for_group_hh=0;

int control_point_number=0;
KalanjiyamWindow::KalanjiyamWindow()
{

  Py_Initialize();
  PyObject *main = PyImport_AddModule("__main__"); // borrowed

  PyObject *globals = PyModule_GetDict(main); // borrowed

  PyRun_SimpleString("import ast\n"
  "from shapely.geometry import LineString, MultiLineString\n"
  "from shapely import affinity\n"
  "from shapely.geometry import *\n");

  Glib::RefPtr<Gtk::Builder> refBuilder = Gtk::Builder::create();
  refBuilder->add_from_file("/usr/share/applications/Kalanjiyam/Gui/Kalanjiyam.glade");
  refBuilder->get_widget("window1", pDialog);
  pDialog->set_title("Kalanjiyam - 0.2");	
  
  refBuilder->get_widget("window2", pAboutDialog);
  pAboutDialog->set_title("Kalanjiyam - 0.2");	
  refBuilder->get_widget("window3", pPreferenceDialog);
  refBuilder->get_widget("box19", pPreferBox);
  pPreferenceDialog->set_title("Kalanjiyam - 0.2 Properties");		
  refBuilder->get_widget("button9", pPreferenceOkay);  
  pPreferenceOkay->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_properties_okay) );   
  
  refBuilder->get_widget("window4", pInfoDialog);
  pInfoDialog->set_title("Kalanjiyam - Info");
  refBuilder->get_widget("label42", pInfoLabel);

  refBuilder->get_widget("window5", pSceneShotMoveDialog);
  pSceneShotMoveDialog->set_title("Scene Shot Move");	
  refBuilder->get_widget("box23", pSourceMove);
  refBuilder->get_widget("box24", pDestinationMove);
  refBuilder->get_widget("button6", MoveOkay);
  MoveOkay->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::moveOkay) );   
  refBuilder->get_widget("button7", MoveCancel);    
  MoveCancel->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::moveCancel) );  
  refBuilder->get_widget("label43", pSceneShotMoveInfoLabel);    
  
  refBuilder->get_widget("window6", pConfirmDialog);
  pConfirmDialog->set_title("Confirm Dialog Box");	 
  refBuilder->get_widget("button5", pConfirmOkay);
  pConfirmOkay->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::ConfirmOkay) );   
  refBuilder->get_widget("button8", pConfirmCancel);    
  pConfirmCancel->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::ConfirmCancel) );  
  refBuilder->get_widget("label49", pConfirmLabel);    
  
  Gtk::ScrolledWindow* pButton = 0;
  refBuilder->get_widget("scrolledwindow8", pButton);
  Gtk::Box *combo_box = 0;
  refBuilder->get_widget("box2", combo_box);

  /*Image Icon*/	
  gtk_init(NULL, NULL);
  GdkPixbuf *pixbuf;
  GError *gerror;
  /*Image Icon*/

  refBuilder->get_widget("toolbar1",toolbar);
  refBuilder->get_widget("handlebox1",phan);
  refBuilder->get_widget("handlebox3",toolswindow);

  /*full screen mode signal connection starts*/
  Gtk::ToggleToolButton* pfull=0;
  refBuilder->get_widget("tFullScreen", pfull);
  pfull->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_kalanjiyamInfo) );   
  /*full screen mode signal connection starts*/

  refBuilder->get_widget("statusbar1", pSbar);
  pSbar->push("Kalanjiyam - 0.2 Loaded...");

  refBuilder->get_widget("fontbutton1", pFontButton);
  pFontButton->signal_font_set().connect(sigc::mem_fun(*this, &KalanjiyamWindow::font_choose_dialogBox) ); 

  refBuilder->get_widget("eventbox1", event1);
  event1->signal_button_press_event().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_button_press_event) );

  /*select_move tool signal connection starts*/
  Gtk::ToolButton* pMove = 0;
  refBuilder->get_widget("Select/Move", pMove);
  pMove->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::select_move) ); 
  /*select_move tool signal connection ends*/

  /*Line tool signal connection starts*/
  Gtk::ToolButton* pLine = 0;
  refBuilder->get_widget("Line", pLine);
  pLine->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_line_shape) ); 
  /*Line tool signal connection ends*/

  /*Brush tool signal connection starts*/
  Gtk::ToolButton* pBrush = 0;
  refBuilder->get_widget("Brush", pBrush);
  pBrush->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_brush) ); 
  /*Brush tool signal connection ends*/

  /*Eraser tool signal connection starts*/
  Gtk::ToolButton* pEraser = 0;
  refBuilder->get_widget("Eraser", pEraser);
  pEraser->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_eraser) ); 
  /*Eraser tool signal connection ends*/

  /*Ellipse tool signal connection starts*/
  Gtk::ToolButton* pEllipse = 0;
  refBuilder->get_widget("Ellipse", pEllipse);
  pEllipse->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_ellipse) ); 
  /*Ellipse tool signal connection ends*/

  /*Ellipse tool signal connection starts*/
  Gtk::ToolButton* pRectangle = 0;
  refBuilder->get_widget("Rectangle", pRectangle);
  pRectangle->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_rectangle) ); 
  /*Ellipse tool signal connection ends*/

  /*Shape tool signal connection starts*/
  Gtk::ToolButton* pShape1 = 0;
  refBuilder->get_widget("Shapes", pShape1);
  pShape1->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_star1_shape) ); 

  Gtk::Button* pShape1_1 = 0;
  refBuilder->get_widget("button1", pShape1_1);
  pShape1_1->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_star1_shape) ); 

  Gtk::Button* pShape1_2 = 0;
  refBuilder->get_widget("button2", pShape1_2);
  pShape1_2->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_star_shape) ); 

  Gtk::Button* pShape1_3 = 0;
  refBuilder->get_widget("button3", pShape1_3);
  pShape1_3->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_triangle_shape) ); 

  Gtk::Button* pShape1_4 = 0;
  refBuilder->get_widget("button4", pShape1_4);
  pShape1_4->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_arrow_shape) ); 
  /*Shape tool signal connection ends*/

  /*image collection tool signal connection starts*/
  Gtk::ToolButton* pImgCollection = 0;
  refBuilder->get_widget("Img_Collection", pImgCollection);
  pImgCollection->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::show_img_collection) ); 
  /*image collection tool signal connection ends*/

  /*Polyline tool signal connection starts*/
  Gtk::ToolButton* pPolyline = 0;
  refBuilder->get_widget("PolyLine", pPolyline);
  pPolyline->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_polyline) ); 
  /*Polyline tool signal connection ends*/

  /*Curve tool signal connection starts*/
  Gtk::ToolButton* pCurve = 0;
  refBuilder->get_widget("Curve", pCurve);
  pCurve->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::draw_curve) ); 
  /*Curve tool signal connection ends*/

  /*zoom_in tool signal connection starts*/
  Gtk::ToolButton* ttZoomIn = 0;
  refBuilder->get_widget("Zoom", ttZoomIn);
  ttZoomIn->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::zoom_in) ); 

  Gtk::ToolButton* ttZoomIn1 = 0;
  refBuilder->get_widget("tZoomIn", ttZoomIn1);
  ttZoomIn1->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::zoom_in) ); 
  /*zoom_in tool signal connection ends*/

  Gtk::ToolButton* ttZoomOut = 0;
  refBuilder->get_widget("tZoomOut", ttZoomOut);
  ttZoomOut->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::zoom_out) ); 

   Gtk::ToolButton* tNew = 0;
  refBuilder->get_widget("tNew",tNew);
  tNew->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_new)); 

  Gtk::ToolButton* tOpen = 0;
  refBuilder->get_widget("tOpen",tOpen);
  tOpen->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_open)); 


  refBuilder->get_widget("tSave",tSave);
  tSave->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_save)); 
  tSave->set_sensitive(0);

  Gtk::ToolButton* tPrint = 0;
  refBuilder->get_widget("tPrint",tPrint);
  tPrint->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_print_all)); 

  Gtk::ToolButton* tExportToPdf = 0;
  refBuilder->get_widget("tExportToPdf",tExportToPdf);
  tExportToPdf->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_export_full)); 

  Gtk::ToolButton* tCopy = 0;
  refBuilder->get_widget("tCopy",tCopy);
  tCopy->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_copy));

  Gtk::ToolButton* tPaste = 0;
  refBuilder->get_widget("tPaste",tPaste);
  tPaste->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_paste));

  Gtk::ToolButton* tUndo = 0;
  refBuilder->get_widget("tUndo",tUndo);
  tUndo->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_undo));

  Gtk::ToolButton* tRedo = 0;
  refBuilder->get_widget("tRedo",tRedo);
  tRedo->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_redo));

  refBuilder->get_widget("menu-clearObject", pClearSelected);
  pClearSelected->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_clear_selected_object));

  refBuilder->get_widget("menu-clearWindow", pClearWindow);
  pClearWindow->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_clear_window1));

  //view menu
  refBuilder->get_widget("menu-toolbar",tToolbar);
  tToolbar->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_toolbar));

  Gtk::CheckMenuItem *tPropertybar = 0;
  refBuilder->get_widget("menu-propertybar",tPropertybar);
  tPropertybar->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_propertyBar));

  refBuilder->get_widget("menu-toolpallete",tToolpallete);
  tToolpallete->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_toolPallete));
  tToolpallete->set_sensitive(0);

  refBuilder->get_widget("menu-grid",tGrid);
  tGrid->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_grid));
  tGrid->set_sensitive(0);

  refBuilder->get_widget("tShowThumbnail",tShowThumbnail);
  tShowThumbnail->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::show_thumbnail));
  tShowThumbnail->set_sensitive(0);

  //navigation menu
  Gtk::ToolButton* tFirstPanel = 0;
  refBuilder->get_widget("tFirstPanel",tFirstPanel);
  tFirstPanel->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_firstPanel));

  Gtk::ToolButton* tPreviousPanel = 0;
  refBuilder->get_widget("tPreviousPanel",tPreviousPanel);
  tPreviousPanel->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_previousPanel));

  Gtk::ToolButton* tNextPanel = 0;
  refBuilder->get_widget("tNextPanel",tNextPanel);
  tNextPanel->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_nextPanel));

  Gtk::ToolButton* tLastPanel = 0;
  refBuilder->get_widget("tLastPanel",tLastPanel);
  tLastPanel->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_lasttPanel));

  //kalanjiyam menu
  refBuilder->get_widget("tImportImage",tImportImage);
  tImportImage->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addImportImage));
  tImportImage->set_sensitive(0);

  Gtk::ToolButton* tExternalImageEditor = 0;
  refBuilder->get_widget("tExternalImageEditor",tExternalImageEditor);
  tExternalImageEditor->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addExternalImageEditor));  

  /*Text tool*/
  refBuilder->get_widget("Text",tTextTool);
  tTextTool->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::text_tool));  

  refBuilder->get_widget("Text_Okay",tTextOkay);
  tTextOkay->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::text_okay));  

  refBuilder->get_widget("Text_Cancel",tTextCancel);
  tTextCancel->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::text_cancel));  

  refBuilder->get_widget("textview4",pTextTool);
  /*Text tool*/

  /*Notebook*/
  refBuilder->get_widget("notebook1",pNotebook);
  /*Notebook*/

  /*SpinButton*/
  refBuilder->get_widget("spinbutton1",pSpinBorderWidth);
  pSpinBorderWidth->signal_value_changed().connect( sigc::mem_fun(*this, &KalanjiyamWindow::on_pAdjBorder_value_changed) );

  refBuilder->get_widget("spinbutton5",pSpinEraserWidth);
  pSpinEraserWidth->signal_value_changed().connect( sigc::mem_fun(*this, &KalanjiyamWindow::on_pAdjEraser_value_changed) );

  refBuilder->get_widget("spinbutton2",pSpinBorderXRadius);
  pSpinBorderXRadius->signal_value_changed().connect( sigc::mem_fun(*this, &KalanjiyamWindow::on_pAdjBorder_xRadius_value_changed) );

  refBuilder->get_widget("spinbutton3",pSpinBorderYRadius);
  pSpinBorderYRadius->signal_value_changed().connect( sigc::mem_fun(*this, &KalanjiyamWindow::on_pAdjBorder_yRadius_value_changed) );

  refBuilder->get_widget("adjustment1",pAdjBorderWidth);
  refBuilder->get_widget("adjustment2",pAdjBorderXRadius);
  refBuilder->get_widget("adjustment3",pAdjBorderYRadius);
  refBuilder->get_widget("adjustment5",pAdjEraserWidth);
  /*SpinButton*/

  refBuilder->get_widget("box8", pViewport);

  refBuilder->get_widget("menu-new", pNew);
  pNew->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_new) ); 

  refBuilder->get_widget("menu-open", pOpen);
  pOpen->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_open) ); 

  refBuilder->get_widget("menu-save", pSave);
  pSave->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_save) ); 
  pSave->set_sensitive(0);

  refBuilder->get_widget("menu-save_as", pSaveAs);
  pSaveAs->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_saveAs) ); 
  pSaveAs->set_sensitive(0);

  refBuilder->get_widget("Properties",pProperties);
  pProperties->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_properties)); 
  pProperties->set_sensitive(0);

  refBuilder->get_widget("menu-export", pExport);
  //pExport->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_export) ); 

  refBuilder->get_widget("menu-pdf-file4", pExportFile1);
  pExportFile1->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_export) ); 
  pExportFile1->set_sensitive(0);

  refBuilder->get_widget("menu-pdf-file5", pExportFile2);
  pExportFile2->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_export1) ); 
  pExportFile2->set_sensitive(0);

  refBuilder->get_widget("menu-pdf-file6", pExportFile3);
  pExportFile3->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_export2) );
  pExportFile3->set_sensitive(0);

  refBuilder->get_widget("menu_pdf_file_all", pExportFile4);
  pExportFile4->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_export_full) ); 
  pExportFile4->set_sensitive(0);

  refBuilder->get_widget("menu-explore-pdf-file", pPpreview);

  refBuilder->get_widget("menu-pdf-file1", pPpreviewFile1);
  pPpreviewFile1->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_pPreview1) ); 
  pPpreviewFile1->set_sensitive(0);

  refBuilder->get_widget("menu-pdf-file2", pPpreviewFile2);
  pPpreviewFile2->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_pPreview2) ); 
  pPpreviewFile2->set_sensitive(0);

  refBuilder->get_widget("menu-pdf-file3", pPpreviewFile3);
  pPpreviewFile3->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_pPreview3) ); 
  pPpreviewFile3->set_sensitive(0);
    
  refBuilder->get_widget("menu-print", pPrintAll);
  pPrintAll->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_print_all) ); 
  pPrintAll->set_sensitive(0);

  refBuilder->get_widget("menu-print1", pPrintFile1);
  pPrintFile1->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_print_file1) ); 
  pPrintFile1->set_sensitive(0);

  refBuilder->get_widget("menu-print2", pPrintFile2);
  pPrintFile2->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_print_file2) ); 
  pPrintFile2->set_sensitive(0);

  refBuilder->get_widget("menu-print3", pPrintFile3);
  pPrintFile3->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_print_file3) ); 
  pPrintFile3->set_sensitive(0);

  refBuilder->get_widget("menu-quit", pExit);
  pExit->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::file_quit_confirm) );    
  //edit menu

  refBuilder->get_widget("menu-copy", pCopy);
  pCopy->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_copy));
  refBuilder->get_widget("menu-paste", pPaste);
  pPaste->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_paste));

  refBuilder->get_widget("menu-undo", pUndo);
  pUndo->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_undo));
  refBuilder->get_widget("menu-redo", pRedo);
  pRedo->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_redo));

  refBuilder->get_widget("menu-group", pGroup);
  pGroup->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_group));

  refBuilder->get_widget("menu-ungroup", pUnGroup);
  pUnGroup->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_ungroup));

  refBuilder->get_widget("menu-move1", pMoveUp);
  pMoveUp->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_moveUp));
  refBuilder->get_widget("menu-move2", pMoveDown);
  pMoveDown->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_moveDown));
  refBuilder->get_widget("menu-move3", pMoveLeft);
  pMoveLeft->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_moveLeft));
  refBuilder->get_widget("menu-move4", pMoveRight);
  pMoveRight->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_moveRight));

  refBuilder->get_widget("menu-raise1", pRaiseToFront);
  pRaiseToFront->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_raise_to_front));
  refBuilder->get_widget("menu-raise2", pRaiseToTop);
  pRaiseToTop->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_raise_to_top));
  refBuilder->get_widget("menu-lower1", pLowerToBack);
  pLowerToBack->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_lower_to_back));
  refBuilder->get_widget("menu-lower2", pLowerToBottom);
  pLowerToBottom->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::edit_lower_to_bottom));

  //view menu
  refBuilder->get_widget("menu-zoomin", pZoomIn);
  pZoomIn->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_zoomIn)); 
  refBuilder->get_widget("menu-zoomout", pZoomOut);
  pZoomOut->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_zoomOut));
  refBuilder->get_widget("menu-resetzoom", pResetZoom);
  pResetZoom->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_resetZoom));
  refBuilder->get_widget("menu-fullscreen", pFullScreen);
  //pFullScreen->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_fullScreen));
  pFullScreen->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::view_kalanjiyamInfo));

  //navigation menu
  refBuilder->get_widget("menu-firstpanel", pFirstPanel);
  pFirstPanel->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_firstPanel));
  refBuilder->get_widget("menu-previouspanel", pPreviousPanel);
  pPreviousPanel->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_previousPanel));
  refBuilder->get_widget("menu-nextpanel", pNextPanel);
  pNextPanel->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_nextPanel));
  refBuilder->get_widget("menu-lastpanel", pLastPanel);
  pLastPanel->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_lasttPanel));

  //kalanjiyam menu
  refBuilder->get_widget("menu-addscene", pAddScene);
  pAddScene->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addScene));
  refBuilder->get_widget("menu-addshot", pAddShot);
  pAddShot->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addShot));
  refBuilder->get_widget("menu-moveScShot", pScShMove);
  pScShMove->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::scShotMove));

  refBuilder->get_widget("menu-importimage", pImportImage);
  pImportImage->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addImportImage));
  pImportImage->set_sensitive(0);
  
  refBuilder->get_widget("menu-exportimage", pExportImage);
  pExportImage->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addExportImage));
  pExportImage->set_sensitive(0);

  refBuilder->get_widget("menu-loadimageeditor", pLoadExternalEditor);
  pLoadExternalEditor->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addExternalImageEditor));
  refBuilder->get_widget("menu-shortcut", pShortcut);
  pShortcut->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addShortcut));

  //Help menu
  refBuilder->get_widget("menu-quickstart", pQuickStart);
  pQuickStart->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::quickStart));

  refBuilder->get_widget("menu-kalanjiyam-ontheweb", pOnTheWeb);
  pOnTheWeb->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::onTheWeb));

  refBuilder->get_widget("menu-about", pAbout);
  pAbout->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::about));
  /*Menu signal connection ends*/

  /* Kalanjiyam info */
  refBuilder->get_widget("entry1", pProjectName);
  refBuilder->get_widget("entry2", pSceneNumber);
  refBuilder->get_widget("entry3", pShotNumber);
  //refBuilder->get_widget("entry4", pTotalFrames);

  refBuilder->get_widget("spinbutton4",pTotalFrames);
  pTotalFrames->signal_value_changed().connect( sigc::mem_fun(*this, &KalanjiyamWindow::on_total_frames_selection_changed) );
  
  refBuilder->get_widget("entry5", pSceneTitle);
  refBuilder->get_widget("entry6", pProjectClient);
  refBuilder->get_widget("entry7", pProjectCopy);  
  refBuilder->get_widget("textview1", pDialogue);
  refBuilder->get_widget("textview2", pActionNotes);
  refBuilder->get_widget("textview3", pAudioNotes);
  /* Kalanjiyam info*/

  /*Propertybar*/
  refBuilder->get_widget("box6", pBorderWidth);	
  refBuilder->get_widget("box27", pEraserWidth);
  refBuilder->get_widget("box13", pFont);	
  refBuilder->get_widget("box9", pStrokeColor);	
  refBuilder->get_widget("box10", pFillColor);	
  refBuilder->get_widget("box11", pBorderXradius);	
  refBuilder->get_widget("box12", pBorderYradius);	
  refBuilder->get_widget("box14", pShape);	

  pFont->hide();
  pBorderXradius->hide();	
  pBorderYradius->hide();
  pEraserWidth->hide();
  pShape->hide();
  /*Propertybar*/	

  refBuilder->get_widget("drawingarea1", darea);
  darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#000000"));
  darea->set_size_request(10,20);
  darea->add_events( Gdk::BUTTON_PRESS_MASK | Gdk::BUTTON_RELEASE_MASK );
  darea->signal_button_press_event().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_button_press_event1));

  refBuilder->get_widget("drawingarea2", darea2);
  darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));
  open_global_fillcolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) 255,(gint) 255,(gint) 255);
  fillcolor = g_strdup_printf("#%02x%02x%02x",(gint) 255,(gint) 255,(gint) 255);
  darea2->set_size_request(10,20);
  darea2->add_events( Gdk::BUTTON_PRESS_MASK | Gdk::BUTTON_RELEASE_MASK );
  darea2->signal_button_press_event().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_button_press_event2));

  m_canvas.set_bounds(0, 0, 5000, 5000);
  m_canvas.set_scale(m_canvas.get_scale() - 0.2);

  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();

  Glib::RefPtr<Goocanvas::Rect> rect = Goocanvas::Rect::create(0, 0, 5000, 5000);
  root->add_child(rect);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  rect->property_line_width() = 2.0;
  rect->property_radius_x() = 1.0;
  rect->property_radius_y() = 1.0;
  rect->property_stroke_color() = "gray";
  rect->property_fill_color() = "white";
  #endif //GLIBMM_PROPERTIES_ENABLED

  rect = Goocanvas::Rect::create(265, 120, 700, 500);
  root->add_child(rect);
  child_num=child_num+1;
  #ifdef GLIBMM_PROPERTIES_ENABLED
  rect->property_line_width() = 2.0;
  rect->property_radius_x() = 1.0;
  rect->property_radius_y() = 1.0;
  rect->property_stroke_color() = "gray";
  rect->property_fill_color() = "white";
  #endif //GLIBMM_PROPERTIES_ENABLED

  grid = Goocanvas::Grid::create(0,0,5000,5000,15,15,10,10); 	
  root->add_child(grid);
  child_num=child_num+1;

  grid->property_stroke_color() = "black" ;
  grid->property_line_width() = 0.2 ;
  /*Grid creation ends*/	

  root->signal_button_press_event ().connect (sigc::mem_fun (this,&KalanjiyamWindow::on_rect_button_press));
  root->signal_button_release_event().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_rect_button_release_event));
  root->signal_motion_notify_event().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_rect_motion_notify_event));

  pDialog->signal_key_press_event().connect(sigc::mem_fun(*this,&KalanjiyamWindow::on_Window_key_press_event));
  pDialog->signal_key_release_event().connect(sigc::mem_fun(*this,&KalanjiyamWindow::on_Window_key_release_event));

  pAboutDialog->signal_key_press_event().connect(sigc::mem_fun(*this,&KalanjiyamWindow::on_PopUpWindow_key_press_event));
  pPreferenceDialog->signal_key_press_event().connect(sigc::mem_fun(*this,&KalanjiyamWindow::on_PopUpWindow_key_press_event)); 
  pInfoDialog->signal_key_press_event().connect(sigc::mem_fun(*this,&KalanjiyamWindow::on_PopUpWindow_key_press_event));
  pSceneShotMoveDialog->signal_key_press_event().connect(sigc::mem_fun(*this,&KalanjiyamWindow::on_PopUpWindow_key_press_event));
  pConfirmDialog->signal_key_press_event().connect(sigc::mem_fun(*this,&KalanjiyamWindow::on_PopUpWindow_key_press_event));

  /*Combobox adding begins*/
  m_Combo.append("Select");
  m_Combo.append("Wide");
  m_Combo.append("Very Wide Shot"); 
  m_Combo.append("Extreme Wide Shot");
  m_Combo.append("Navel");
  m_Combo.append("Medium");
  m_Combo.append("Close Up");
  m_Combo.append("Medium Close Up");
  m_Combo.append("Extreme Close Up");
  m_Combo.append("Cut Away");
  m_Combo.append("Cut In");
  m_Combo.append("Zoom In");
  m_Combo.append("Pan");
  m_Combo.append("Two Shot");
  m_Combo.append("Over The Shoulder");
  m_Combo.append("Pov"); 
  m_Combo.append("Montage");
  m_Combo.append("CGL");
  m_Combo.append("Weather Shot");
  m_Combo.set_active(0);
  combo_box->add(m_Combo);
  combo_box->show();
  m_Combo.show();
  //Connect signal handler:
  m_Combo.signal_changed().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_combo_changed) );
  show_all_children();
  /*Combobox adding ends*/

  /*Preference Combobox adding begins*/
  preference_m_Combo.append("Select");
  preference_m_Combo.append("PAL : 720w 570h");
  preference_m_Combo.append("NTSC : 720w 480h"); 
  preference_m_Combo.append("HD 720 : 1280w 720h");
  preference_m_Combo.append("HD 1080 : 1920w 1080h");
  pPreferBox->add(preference_m_Combo);
  preference_m_Combo.set_active(0);
  pPreferBox->show();
  preference_m_Combo.show();
  preference_m_Combo.signal_changed().connect(sigc::mem_fun(*this, &KalanjiyamWindow::preference_on_combo_changed) );
  show_all_children();
  /*Preference Combobox adding begins*/

  /*Scene shot move*/
  source_Combo.append("Select");
  source_Combo.set_active(0);
  pSourceMove->add(source_Combo);
  pSourceMove->show();
  source_Combo.show();
  show_all_children();
  
  destination_Combo.append("Select");
  destination_Combo.append("Scene15 Shot15");
  destination_Combo.set_active(0);
  pDestinationMove->add(destination_Combo);
  pDestinationMove->show();
  destination_Combo.show();
  destination_Combo.signal_changed().connect(sigc::mem_fun(*this, &KalanjiyamWindow::destination_on_combo_changed) );
  show_all_children();
  /*Sene shot move*/ 

  /*Layer*/
  refBuilder->get_widget("viewport8", v_port8);

  refBuilder->get_widget("viewport2", vt_port);
  Gtk::ToolButton* add_layer = 0;
  refBuilder->get_widget("toolbutton9", add_layer);
  add_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addScene) ); 
  Gtk::ToolButton* del_layer = 0;
  refBuilder->get_widget("toolbutton10", del_layer);
  del_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::on_button_delete_layer_confirm) ); 

  Gtk::ToolButton* move_first_layer = 0;
  refBuilder->get_widget("toolbutton1", move_first_layer);
  move_first_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_firstPanel) ); 

  Gtk::ToolButton* up_layer = 0;
  refBuilder->get_widget("toolbutton11", up_layer);
  up_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_previousPanel) ); 

  Gtk::ToolButton* down_layer = 0;
  refBuilder->get_widget("toolbutton12", down_layer);
  down_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_nextPanel) ); 

  Gtk::ToolButton* move_last_layer = 0;
  refBuilder->get_widget("toolbutton2", move_last_layer);
  move_last_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_lasttPanel) ); 

  Gtk::ToolButton* expand_layer = 0;
  refBuilder->get_widget("toolbutton3", expand_layer);
  expand_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_expandLayer) ); 

  Gtk::ToolButton* collapse_layer = 0;
  refBuilder->get_widget("toolbutton5", collapse_layer);
  collapse_layer->signal_clicked().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_collapseLayer) ); 

  vt_port->add(my_Tree_View_Test_Tree_View);

  my_Tree_View_Test_Tree_Model  = TreeModel_Dnd::create();

  my_Tree_View_Test_Tree_View.set_model(my_Tree_View_Test_Tree_Model);

  Gtk::TreeModel::Row my_row;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection =my_Tree_View_Test_Tree_View. get_selection(); 
  my_row = *(my_Tree_View_Test_Tree_Model->append());
  refSelection->select(my_row); 

  my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/kalanjiyam_logo.png");
  my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = "Scene1 shot1";

  Gtk::CellRendererPixbuf * renderer = Gtk::manage(new Gtk::CellRendererPixbuf); 
  int cols_count = my_Tree_View_Test_Tree_View.append_column("", *renderer);

  my_Tree_View_Test_Tree_View.append_column("Thumbnail", my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number);

  my_Tree_View_Test_Tree_View.append_column("Scene/Shot", my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String);

  Gtk::TreeViewColumn* pColumn = my_Tree_View_Test_Tree_View.get_column(cols_count-1);

  Gtk::MenuItem* item1; 

  item1 = Gtk::manage(new Gtk::MenuItem("Add Scene", true));
  item1->signal_activate().connect(
  sigc::mem_fun(*this, &KalanjiyamWindow::addScene) );
  m_Menu_Popup.append(*item1);

  item1 = Gtk::manage(new Gtk::MenuItem("Add Shot", true));
  item1->signal_activate().connect(sigc::mem_fun(*this, &KalanjiyamWindow::addShot) );
  m_Menu_Popup.append(*item1);

  item1 = Gtk::manage(new Gtk::MenuItem("Remove Scene/Shot", true));
  item1->signal_activate().connect(
  sigc::mem_fun(*this, &KalanjiyamWindow::on_button_delete_layer_confirm) );
  m_Menu_Popup.append(*item1);

  item1 = Gtk::manage(new Gtk::MenuItem("Move Scene/Shot", true));
  item1->signal_activate().connect(sigc::mem_fun(*this, &KalanjiyamWindow::scShotMove) );
  m_Menu_Popup.append(*item1);


  m_Menu_Popup.accelerate(*this);
  m_Menu_Popup.show_all(); //Show all menu items when the menu pops up

  my_Tree_View_Test_Tree_View.signal_button_press_event().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_right_button_press_event), false);
  my_Tree_View_Test_Tree_View.show();

  refSelection = my_Tree_View_Test_Tree_View. get_selection();
  refSelection->signal_changed().connect(sigc::mem_fun(*this, &KalanjiyamWindow::on_selection_changed));

  show_all_children();
  /*Layer*/

  /*Images Tab*/
  refBuilder->get_widget("viewport6", pImagesTab); 
  pImagesTab->add(my_Tree_View_Image_Test_Tree_View);

  my_Tree_View_Image_Test_Tree_Model  = ImageTreeModel_Dnd::create();
  my_Tree_View_Image_Test_Tree_View.set_model(my_Tree_View_Image_Test_Tree_Model); 

  Gtk::TreeModel::Row my_row1;
  Gtk::TreeModel::Row my_row2;  

  Gtk::CellRendererPixbuf * renderer1 = Gtk::manage(new Gtk::CellRendererPixbuf); 
  int cols_count1 = my_Tree_View_Image_Test_Tree_View.append_column("", *renderer1);
  my_Tree_View_Image_Test_Tree_View.append_column("Image", my_Tree_View_Image_Test_Tree_Model->Image_my_Tree_View_Test_Columns.my_Image_String);
  my_Tree_View_Image_Test_Tree_View.append_column("Name", my_Tree_View_Image_Test_Tree_Model->Image_my_Tree_View_Test_Columns.my_Image_Number);
  Gtk::TreeViewColumn* pColumn1 = my_Tree_View_Image_Test_Tree_View.get_column(cols_count1-1); 

  DIR *dp;
  struct dirent *dirp;
  std::string files;
  const char* string;
  const char* img_file_path = "/usr/share/applications/Kalanjiyam/Gui/Images/";

  /*Shape Images*/
  dir_to_show_names.push_back("Symbols");
  dir_to_show_names.push_back("Animals");
  dir_to_show_names.push_back("Birds");
  dir_to_show_names.push_back("Trees");
  dir_to_show_names.push_back("Vehicles");
  dir_to_show_names.push_back("Flowers");
  dir_to_show_names.push_back("Buildings");
  dir_to_show_names.push_back("Fruits");
  dir_to_show_names.push_back("Nature");
  dir_to_show_names.push_back("Clouds");
  dir_to_show_names.push_back("Furnitures");
  dir_to_show_names.push_back("Lights");
  dir_to_show_names.push_back("Roads");
  dir_to_show_names.push_back("Camera");
  dir_to_show_names.push_back("Mountains");

  for(i=0;i<15;i++) 
  {
    std::string process_dir="/usr/share/applications/Kalanjiyam/Gui/Images/"+ dir_to_show_names[i];
    std::string dir= process_dir + "/Small_Image/";
    if((dp  = opendir(dir.c_str())) == NULL) 
    {
    }

    int tot_tab_img_count = 1;
    while ((dirp = readdir(dp)) != NULL) 
    {
      if ((strcmp(dirp->d_name, "." ) == 0) || (strcmp(dirp->d_name, ".." ) == 0))
      continue;
      else
      {
        std::string img_name_string = std::string(dirp->d_name);
        /*Getting file_name without extension begins*/
        std::string fileName = img_name_string;
        size_t position = fileName.find(".");
        std::string extractName = (std::string::npos == position)? fileName : fileName.substr(0, position);
        /*Getting file_name without extension ends*/
        std::string img_full_name = dir + img_name_string;
        if(tot_tab_img_count==1)	
        {
		global_name=img_name_string;
        int v=global_name.length();
        final=global_name.substr(0,(v-4));
        thump_list.push_back(final);
        my_row1 = *(my_Tree_View_Image_Test_Tree_Model->append());
        my_row1[my_Tree_View_Image_Test_Tree_Model->Image_my_Tree_View_Test_Columns.my_Image_String] = Gdk::Pixbuf::create_from_file(dir+img_name_string);
        my_row1[my_Tree_View_Image_Test_Tree_Model->Image_my_Tree_View_Test_Columns.my_Image_Number] = dir_to_show_names[i];
        tot_tab_img_count=0;
        }
        else
        {
        my_row2 = *(my_Tree_View_Image_Test_Tree_Model->append(my_row1.children()));	
        my_row2[my_Tree_View_Image_Test_Tree_Model->Image_my_Tree_View_Test_Columns.my_Image_String] = Gdk::Pixbuf::create_from_file(dir+img_name_string);
        my_row2[my_Tree_View_Image_Test_Tree_Model->Image_my_Tree_View_Test_Columns.my_Image_Number] = extractName;
        }
      }		
    }
    closedir(dp);
  }
  /*Shape Images*/
  my_Tree_View_Image_Test_Tree_View.signal_button_press_event().connect(sigc::mem_fun(*this, &KalanjiyamWindow::image_tab_button_press_event), false); 
  my_Tree_View_Image_Test_Tree_View.show();

  Glib::RefPtr<Gtk::TreeView::Selection> refSelection1;
  refSelection1 = my_Tree_View_Image_Test_Tree_View. get_selection();
  refSelection1->signal_changed().connect(sigc::mem_fun(*this, &KalanjiyamWindow::image_on_selection_changed));
  show_all_children();
  /*Images Tab*/ 
  toolbar->hide();
  pButton->add(m_canvas);
  m_canvas.show();
  event1->set_visible(false); 
  v_port8->set_visible(true); 

  pDialog->maximize();  
  pDialog->show();
  xml_scene_overall_tag.push_back("0");
  global_scene_shot_number_list_vector.push_back("1,1");
  global_temp_scene_xml = create_temp_scene_xml();
  xml_kalanjiyam_overall_tag.push_back(global_temp_scene_xml);	 //For save. That is, by default for (1,1) xml should be created. add scene/add shot creates xml also.
  pNotebook->get_nth_page(1)->hide();
  pNotebook->get_nth_page(2)->hide();
  pNotebook->get_nth_page(3)->hide();
  pSceneNumber->set_text("1");
  pShotNumber->set_text("1");
  toolbar->show();

}

bool KalanjiyamWindow::on_rect_button_press(const Glib::RefPtr<Goocanvas::Item>& item, GdkEventButton* event)
{
  pNotebook->get_nth_page(2)->hide();
  pNotebook->get_nth_page(3)->hide();
  if(button_press_status==1)
  {
    if(drawing_tool_number==1)
    { 
      if(event->button == 1)
      {
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        Glib::RefPtr<Goocanvas::Polyline> line ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        line = Goocanvas::Polyline::create(old_x, old_y, old_x, old_y);
        root->add_child(line);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        line->property_stroke_color() = open_global_fillcolor_hex;
        line->property_line_width() = border_width;
        line->property_start_arrow() = false ;
        line->property_end_arrow() = false ;
        line->property_arrow_tip_length() = 5.0 ;
        line->property_arrow_length() = 6.0 ;
        line->property_arrow_width() = 6.0 ;
        #else
        line->set_property("stroke_color", open_global_fillcolor_hex));
        line->set_property("line_width", border_width);
        line->set_property("start_arrow", false);
        line->set_property("end_arrow", false);
        line->set_property("arrow_tip_length", 5.0);
        line->set_property("arrow_length", 6.0);
        line->set_property("arrow_width", 6.0);
        #endif
        child_num=child_num+1;
      }
      button_press_status = 0;
      return false ;
    }
    if(drawing_tool_number==2)
      {
      if(event->button == 1)
      {
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        Glib::RefPtr<Goocanvas::Rect> rect ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        rect = Goocanvas::Rect::create(old_x,old_y,0.1,0.1);
        root->add_child(rect);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        rect->property_stroke_color() = open_global_strokecolor_hex ;
        rect->property_fill_color() = open_global_fillcolor_hex ;
        rect->property_line_width() = border_width;
        rect->rotate(0, a, b);
        #else
        rect->set_property("stroke_color", open_global_strokecolor_hex);
        rect->set_property("line_width", border_width);
        #endif
        child_num=child_num+1; 
      }
      button_press_status = 0;
      return false ;
    }

    if(drawing_tool_number==15) /*Rotate tool - motion notify event*/ 
    {
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      int n = root->find_child(item);
      if(n>0)
      {
        if(move_var>0)
        {
          if(event->button == 1)
          {
          _dragging = item;
          new_x=event->x;
          new_y=event->y;
          item->signal_motion_notify_event().connect(sigc::mem_fun (*this, &KalanjiyamWindow::on_rotate_motion_notify_event));  
          }
        }
        else
        {
          pSbar->push("Select Object to Rotate...");
        }
        button_press_status = 0;
        return false ;
      }
    }

    if(drawing_tool_number==3)
    {
      if(event->button == 1)
      {
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        last_child_num=child_num;
        brush_var="M ";
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        double x1=old_x, y1=old_y, x2=old_x, y2=old_y;
        Glib::ustring str1, str2, str3, str4;
        std::stringstream strstr1, strstr2, strstr3, strstr4;
        strstr1<<x1;
        strstr2<<y1;
        strstr3<<x2;
        strstr4<<y2;
        strstr1>>str1;
        strstr2>>str2;
        strstr3>>str3;
        strstr4>>str4;
        if (brush_var=="M ")
        {
        brush_var=brush_var+str1+" "+str2+" L "+str3+" "+str4;
        }
        else
        {
        brush_var=brush_var+" L "+str3+" "+str4;
        }
        Glib::RefPtr<Goocanvas::Path> path ;
        path = Goocanvas::Path::create(brush_var); 	
        root->add_child(path);
        child_num=child_num+1;
        path->property_stroke_color() = open_global_strokecolor_hex ;
        path->property_line_width() = border_width;
      }
      button_press_status = 0;
      return false ;
    }

   if(drawing_tool_number==4)
    {
	  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      int n=root->find_child(item);

	  eraser_width=pSpinEraserWidth->get_value_as_int();
	  if(eraser_width>=1)
	    eraser_width=eraser_width+2;
      if(event->button == 1  || n==-1) // && n!=1 && n!=-1 && n!=grid_number)		
      {
	    if(open_node_name_curve==0 && for_grp_check==0)
	    {	  
			if(child_num>=2)
			{
			  my_str1_tag = "";
			  root = m_canvas.get_root_item();
			  find_child_item =root->find_child(item);
			  count_for_my_str1 = 0;
			  eraser_status = 1;
			  old_x = event->x ;
			  old_y = event->y ;
			  event_x_pos = old_x;
			  event_y_pos = old_y;
			  flag_set_for_find_child=1;
			  current_clicked_item=changed_item_num;

			  my_item = root->get_child(current_clicked_item); 

			  open_node_name_ellipse_string="2";
			  open_node_name_line_string="2";
			  open_global_python_data="";
			  open_node_name_ellipse="";
			  open_node_name_line = "";
			  image_edit_status=0;
			  get_property(my_item ,current_clicked_item); 

			  if(open_node_name_curve==0 || eraser_grouped_child_no.size()!=0)
	    	  {
				  if(eraser_grouped_child_no.size()!=0)
				  {
					image_edit_status=0;
					open_node_name_curve=0;
				  }
			 	  open_node_name_ellipse_string="2";
				  open_node_name_line_string="2";
				  open_global_python_data="";
				  open_node_name_ellipse="";
				  open_node_name_line = "";
				  _dragging = my_item;
				  last_child_num=child_num;
			  }
	  		}
		  }
      }

      button_press_status = 0;
      return false ;
    }
    
if(drawing_tool_number==5)
    {
      if(event->button == 1)
      {
        view_grid_on_off();
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        Glib::RefPtr<Goocanvas::Ellipse> ellipse ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        ellipse = Goocanvas::Ellipse::create(old_x,old_y,1,1);
        root->add_child(ellipse);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        ellipse->property_fill_color() = open_global_fillcolor_hex ;
        ellipse->property_stroke_color() = open_global_strokecolor_hex ;
        ellipse->property_line_width() = border_width;
        #endif
        child_num=child_num+1;
        if(grid_mode==0)
        changed_item_num=child_num;
        else
        changed_item_num=child_num-1;
        view_grid_on_off();
      }
      button_press_status = 0;
      return false ;
    }

    if(drawing_tool_number==6)
      { 
      if(event->button == 1)
      {
        view_grid_on_off();	
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        Glib::RefPtr<Goocanvas::Rect> rect ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        rect = Goocanvas::Rect::create(old_x,old_y,1,1);
        root->add_child(rect);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        rect->property_stroke_color() = open_global_strokecolor_hex;
        rect->property_fill_color() = open_global_fillcolor_hex;
        rect->property_line_width() = border_width;
        rect->property_radius_x() = border_x_radius;
        rect->property_radius_y() = border_y_radius;
        rect->rotate(0, a, b);
        #else
        rect->set_property("stroke_color", open_global_strokecolor_hex);
        rect->set_property("line_width", border_width);
        #endif
        child_num=child_num+1; 
        if(grid_mode==0)
        changed_item_num=child_num;
        else
        changed_item_num=child_num-1;
        view_grid_on_off();
      }
      button_press_status = 0;
      return false; 
    } 
    
    if(drawing_tool_number==7)
    { 
      if(event->button == 1)
      {
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        Glib::RefPtr<Goocanvas::Rect> rect ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        rect = Goocanvas::Rect::create(old_x,old_y,0.1,0.1);
        root->add_child(rect);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        rect->property_stroke_color() = open_global_strokecolor_hex ;
        rect->property_fill_color() = open_global_fillcolor_hex ;
        rect->property_line_width() = border_width;
        rect->property_radius_x() = border_x_radius;
        rect->property_radius_y() = border_y_radius;
        rect->rotate(0, a, b);
        #else
        rect->set_property("stroke_color", open_global_strokecolor_hex);
        rect->set_property("line_width", border_width);
        #endif
        child_num=child_num+1; 
      }
      button_press_status = 0;
      return false;
    } 
    
    if(drawing_tool_number==8)
    { 
      if(event->button == 1)
      {
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        Glib::RefPtr<Goocanvas::Rect> rect ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        rect = Goocanvas::Rect::create(old_x,old_y,0.1,0.1);
        root->add_child(rect);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        rect->property_stroke_color() = open_global_strokecolor_hex ;
        rect->property_fill_color() = open_global_fillcolor_hex ;
        rect->property_line_width() = border_width;
        rect->property_radius_x() = border_x_radius;
        rect->property_radius_y() = border_y_radius;
        rect->rotate(0, a, b);
        #else
        rect->set_property("stroke_color", open_global_strokecolor_hex);
        rect->set_property("line_width", border_width);
        #endif
        child_num=child_num+1; 
      }
      button_press_status = 0;
      return false ;
    } 
    
    if(drawing_tool_number==9)
    { 
      if(event->button == 1)
        {
        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
        Glib::RefPtr<Goocanvas::Rect> rect ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        rect = Goocanvas::Rect::create(old_x,old_y,0.1,0.1);
        root->add_child(rect);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        rect->property_stroke_color() = open_global_strokecolor_hex ;
        rect->property_fill_color() = open_global_fillcolor_hex ;
        rect->property_line_width() = border_width;
        rect->property_radius_x() = border_x_radius;
        rect->property_radius_y() = border_y_radius;
        rect->rotate(0, a, b);
        #else
        rect->set_property("stroke_color", open_global_strokecolor_hex);
        rect->set_property("line_width", border_width);
        #endif
        child_num=child_num+1; 
      }
      button_press_status = 0;
      return false ;
    } 
    
    if(drawing_tool_number==10)
    { 
      if(event->button == 1)
      {
        view_grid_on_off();
        _dragging = item ;
        if(polyline_cnt==0)
        {
          old_x = event->x ;
          old_y = event->y ;
          last_child_num=child_num;
          Glib::RefPtr<Goocanvas::Ellipse> ellipse ;
          Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
          ellipse = Goocanvas::Ellipse::create(old_x , old_y , 0.5, 0.5);
          root->add_child(ellipse);
          child_num=child_num+1;
          brush_var="M ";
          #ifdef GLIBMM_PROPERTIES_ENABLED
          ellipse->property_fill_color() = open_global_fillcolor_hex ;	
          ellipse->property_stroke_color() = open_global_strokecolor_hex ;	
          ellipse->set_property("line_width", border_width);	
          #endif
          //polyline_cnt=polyline_cnt+1;
          view_grid_on_off();
        }
        else
        {
          new_x = event->x ;
          new_y = event->y ;
          Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
          if(grid_mode==0)
          root->remove_child(child_num);
          else
          root->remove_child(child_num-1);
          child_num=child_num-1;
          double x1=old_x, y1=old_y, x2=new_x, y2=new_y;
          Glib::ustring str1, str2, str3, str4;
          std::stringstream strstr1, strstr2, strstr3, strstr4;
          strstr1<<x1;
          strstr2<<y1;
          strstr3<<x2;
          strstr4<<y2;
          strstr1>>str1;
          strstr2>>str2;
          strstr3>>str3;
          strstr4>>str4;
          if (brush_var=="M ")
          {
          brush_var=brush_var+str1+" "+str2+" L "+str3+" "+str4;
          }
          else
          {
          brush_var=brush_var+" L "+str3+" "+str4;
          }
          Glib::RefPtr<Goocanvas::Path> path ;
          path = Goocanvas::Path::create(brush_var); 	
          root->add_child(path);
          child_num=child_num+1;
          path->property_stroke_color() = open_global_strokecolor_hex ;
          path->property_line_width() = border_width;
          path->get_property("x",open_global_xposition =0);
          path->get_property("y",open_global_yposition =0);
          path->get_property("height",open_global_height =0);
          path->get_property("width",open_global_width =0);
          old_x=new_x;
          old_y=new_y;
  
		  if(grid_mode==0)
			changed_item_num=child_num;
		  else
			changed_item_num=child_num-1;

          view_grid_on_off();
        }
      }
	open_global_python_data="";
    open_global_data = brush_var;
    open_global_linewidth = border_width;
    Glib::ustring path_open_tag = "<Path";
    Glib::ustring path_close_tag;
    Glib::ustring path_fill_color;
    path_close_tag = " Polyline </Path>";	
    Glib::ustring path_i_tag = " data=\"";
    Glib::ustring path_stroke_color = " strokecolor=\"";
    Glib::ustring path_line_width = " linewidth=\"";

    Glib::ustring path_height_tag = " height=\"";
    Glib::ustring path_width_tag = " width=\"";

    Glib::ustring path_xposition = " xposition=\"";
    Glib::ustring path_yposition = " yposition=\"";

    Glib::ustring path_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
    Glib::ustring path_width_tag_value = boost::lexical_cast<std::string>(open_global_width);

    Glib::ustring path_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
    Glib::ustring path_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
    Glib::ustring path_width_value = boost::lexical_cast<std::string>(open_global_linewidth);
    Glib::ustring path_tag;
    path_tag = path_open_tag + path_i_tag + open_global_data + "\"" + path_stroke_color + open_global_strokecolor_hex + "\"" + path_line_width + path_width_value + "\""  + path_xposition + path_xposition_value + "\"" + path_yposition + path_yposition_value + "\"" + path_width_tag + path_width_tag_value + "\"" + path_height_tag + path_height_tag_value + "\">" + path_close_tag;
    if(polyline_cnt==0)
	{
      xml_scene_overall_tag.push_back(path_tag);

		if(undo_status==0)
		{
		  if(undo_count>0)
		  {
			undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
			undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
			undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
			undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
			undo_count=0;
		  }

		  if(undo_redo_tag_vector.size()==0)
		  {
			 undo_redo_tag_vector.push_back(path_tag);
			 undo_redo_child_number_vector.push_back(changed_item_num);
			 int status=0;
			 int position=-1;
			 undo_redo_delete_status_vector.push_back(status);
			 undo_redo_position_vector.push_back(position);
			 standing_position=undo_redo_tag_vector.size()-1;
		  }
		  else if(undo_redo_tag_vector.size()>0)
		  {
			int same_tag_status=0;
			const char* value1 = path_tag.c_str();
			for(int i=0; i<undo_redo_tag_vector.size(); i++)
			{
			std::string value2 = undo_redo_tag_vector[i];
			const char* value3 = value2.c_str();
			if (strcmp(value1,value3) == 0)
			same_tag_status=1;
			}
			if(same_tag_status==0)
			{	
			  undo_redo_tag_vector.push_back(path_tag);
			  undo_redo_child_number_vector.push_back(changed_item_num);
			  int status=0;
			  int position=-1;
			  undo_redo_delete_status_vector.push_back(status);
			  undo_redo_position_vector.push_back(position);
			  standing_position=undo_redo_tag_vector.size()-1;
			}
			else
			{	
			}
		  }
		}
	}
    else
	{
	  xml_scene_overall_tag.at(xml_scene_overall_tag.size()-1) = path_tag;
	  //undo-redo-code-starts here
	  //undo-redo-code-starts here
		if(undo_status==0)
		{

		  if(undo_count>0)
		  {
			undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
			undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
			undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
			undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
			undo_count=0;
		  }

		  if(undo_redo_tag_vector.size()==0)
		  {
		  undo_redo_tag_vector.at(undo_redo_tag_vector.size()-1) = path_tag;
		  undo_redo_child_number_vector.at(undo_redo_child_number_vector.size()-1) = changed_item_num;
		  undo_redo_delete_status_vector.at(undo_redo_delete_status_vector.size()-1) = 0;
		  undo_redo_position_vector.at(undo_redo_position_vector.size()-1) = -1;
		  standing_position=undo_redo_tag_vector.size()-1;
		  }
		  else if(undo_redo_tag_vector.size()>0)
		  {
			int same_tag_status=0;
			const char* value1 = path_tag.c_str();
			for(int i=0; i<undo_redo_tag_vector.size(); i++)
			{
			std::string value2 = undo_redo_tag_vector[i];
			const char* value3 = value2.c_str();
			if (strcmp(value1,value3) == 0)
			same_tag_status=1;
			}
			if(same_tag_status==0)
			{	
			  undo_redo_tag_vector.at(undo_redo_tag_vector.size()-1) = path_tag;
			  undo_redo_child_number_vector.at(undo_redo_child_number_vector.size()-1) = changed_item_num;
			  undo_redo_delete_status_vector.at(undo_redo_delete_status_vector.size()-1) = 0;
			  undo_redo_position_vector.at(undo_redo_position_vector.size()-1) = -1;
			  standing_position=undo_redo_tag_vector.size()-1;
			}
			else
			{	
			}
		  }
	  }
	//undo-redo-code-ends here
	//undo-redo-code-ends here
	}
    polyline_cnt=polyline_cnt+1;
    button_press_status = 0;
    return false ;
    } 

    if(drawing_tool_number==11)
    {
      Goocanvas::Bounds b; 
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      int n=root->find_child(item);
	  find_child_item=root->find_child(item);
	  current_clicked_item=root->find_child(item);
      int grid_number=root->find_child(grid);
      if(event->button == 1 && n!=0 && n!=1 && n!=-1 && n!=grid_number)		//Only if the item is neither gray rectangle nor canvas item, that will selected
      {
		for_grp_check=0;
		b=item->get_bounds();
		double s1=b.get_x1();
		double s2=b.get_x2();
		double s3=b.get_y1();
		double s4=b.get_y2();
		wid=s2-s1;
		hei=s4-s3;

	    item->get_property(Glib::ustring("x"),button_press_x =0);
	    item->get_property(Glib::ustring("y"),button_press_y =0);
	    eraser_drag_flag = 0;
		count_for_my_str1 = 0;

        _dragging = item ;
        old_x = event->x ;
        old_y = event->y ;
		path_old_x = old_x;
		path_old_y = old_y;
		image_old_x = old_x;
		image_old_y = old_y;
		erase_dragging_status=0;
        grouping_flag=0;
        find_group_or_not(n,"single_if","sort_true","but_press");

		for_group_xx = grp_xx;
		for_group_yy = grp_yy;
		for_group_ww = grp_ww;
		for_group_hh = grp_hh;

        if(n<=xml_scene_overall_tag.size()+1)
        {
          std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
          const std::string input_xml = test;
          vector<char> xml_copy(input_xml.begin(), input_xml.end());
          xml_copy.push_back('\0');
          xml_document<> doc;
          doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
          xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
          xml_node<>* Scene = Kalanjiyam->first_node("Scene");
          xml_node<> * abc; 
          int before_paste_total_child_num=child_num;
          while (Scene != NULL )
          {
            for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
            {
              for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
              {
                  const char * node_name = abc->name();
                  const char * node_value = abc->value();		
                  open_node_name = node_name;
                  open_node_value = node_value;
                  const char * attribute_name = attribute->name();	
                  const char * attribute_value = attribute->value();	
			
                  if (strcmp(node_name, "Image") == 0 && grouped_child_no.size()==0)//asdf
                  {	
					count_for_my_str1=0;
					image_status=1;
					for_image_move();
					if (strcmp(attribute_name, "data") == 0 && grouped_child_no.size()==0) 
					{
						open_global_data = attribute_value;
					}
					if (strcmp(attribute_name, "py_data") == 0 && grouped_child_no.size()==0) 
					{
						open_global_python_data = attribute_value;
					}
				  }
                  if (strcmp(node_name, "Text") == 0)
                  {
					text_status=1;
                    if (strcmp(attribute_name, "data") == 0) 
                    {
                    open_global_data = attribute_value;
                    pTextTool->get_buffer()->set_text(open_global_data);
                    }
                    if(strcmp(attribute_name, "font") == 0) 
                    {
                    Pango::FontDescription font;
                    Pango::FontDescription font1;
                    Glib::ustring font_name = attribute_value;
                    pFontButton->set_font_name(attribute_value);

                    font1 = Pango::FontDescription(font_name);  
                    Glib::ustring family_name = font1.get_family(); 

                    font.set_family(family_name);
                    pTextTool->modify_font(font);
                    }
                  }
              }
            }
            Scene = Scene->next_sibling("Scene");	
          } 
        }
      }
      else	//If click out side of the object the control points will disappear	
      {
        pTextTool->get_buffer()->set_text("");
        col_flag=0;	
        if(move_var==1 && group_child_region_no.size()==0)		//While the grouping rectangles are not there, remove 8+1 control items
        {
        control_points_remove();
        move_var=0;
        }
        else if(move_var==1 && group_child_region_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
        {
        selected_items_remove();
        move_var=0;
        }
      } 
      button_press_status = 0;
      return false;
    }
    if(drawing_tool_number==14)
    {
      if(event->button == 1)
      {
        _dragging = item ;
		open_node_name_curve=1;
        if(curve_cnt==0)
        {
          old_x = event->x ;
          old_y = event->y ;
          Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
          if(grid_mode==1)
            last_child_num=child_num-1;
          else if(grid_mode==0)
            last_child_num==child_num;
          brush_var="M ";
          curve_cnt=curve_cnt+1; 
          starting_x=old_x;
        }
        else
        {
          new_a = event->x ;
          new_b = event->y ;
          curve_cnt=curve_cnt+1;
        }
        dragging_var=curve_cnt;
      }
      button_press_status = 0;
      return false;
    }
  }


}

void KalanjiyamWindow::first(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}

void KalanjiyamWindow::second(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}

void KalanjiyamWindow::third(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}

void KalanjiyamWindow::fourth(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}

void KalanjiyamWindow::fifth(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}


void KalanjiyamWindow::sixth(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}

void KalanjiyamWindow::seventh(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}

void KalanjiyamWindow::eighth(int a,int b,int c,int d)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(a, b, c, d);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_stroke_color() = "black";
  line->property_line_width() = 6.0;
  line->property_start_arrow() = true ;
  line->property_end_arrow() = true ;
  line->property_arrow_tip_length() = 1.5 ;
  line->property_arrow_length() = 1.5 ;
  line->property_arrow_width() = 2.0 ;
  #endif
  child_num=child_num+1;
}

bool KalanjiyamWindow::on_rect_motion_notify_event(const Glib::RefPtr<Goocanvas::Item>& item, GdkEventMotion* event)
{
  if(drawing_tool_number==1)
  {
    if((item && _dragging) && item == _dragging)
    {
      view_grid_on_off();
      new_x = event->x ;
      new_y = event->y ;
      double a;
      double b;
      if(new_x>old_x)
      a = new_x - old_x;
      else
      a = old_x - new_x;
      if(new_y>old_y)
      b = new_y - old_y;
      else
      b = old_y - new_y;
      if(a>0 && b>0)
      {
        Glib::RefPtr<Goocanvas::Polyline> line ;
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        if(grid_mode==0)
        root->remove_child(child_num);
        else
        root->remove_child(child_num-1);
        child_num=child_num-1;
        line = Goocanvas::Polyline::create(old_x, old_y, new_x, new_y);
        root->add_child(line);
        #ifdef GLIBMM_PROPERTIES_ENABLED
        line->property_stroke_color() = open_global_strokecolor_hex;
        line->property_line_width() = border_width;
        line->property_start_arrow() = false ;
        line->property_end_arrow() = false ;
        line->property_arrow_tip_length() = 5.0 ;
        line->property_arrow_length() = 6.0 ;
        line->property_arrow_width() = 6.0 ;
        line->get_property(Glib::ustring("height"),open_global_height =0);
        line->get_property(Glib::ustring("width"),open_global_width= 0);	
        #else
        line->set_property("stroke_color", open_global_strokecolor_hex);
        line->set_property("line_width", border_width);
        line->set_property("start_arrow", false);
        line->set_property("end_arrow", false);
        line->set_property("arrow_tip_length", 5.0);
        line->set_property("arrow_length", 6.0);
        line->set_property("arrow_width", 6.0);
        #endif
        child_num=child_num+1;
      }
      view_grid_on_off();
    }
    return false ;
  }
  if(drawing_tool_number==2)
  {
    if((item && _dragging) && item == _dragging)
    {
      view_grid_on_off();
      new_x = event->x ;
      new_y = event->y ;
      if(new_x>old_x && new_y>old_y)
      {
        w = new_x - old_x;
        h = new_y - old_y;
        p1_x = old_x;
        p1_y = old_y+h*0.4;
        p2_x = old_x+w*0.8;
        p2_y = old_y+h*0.4;
        p3_x = old_x+w*0.8;
        p3_y = old_y+h*0.3;
        p4_x = new_x;
        p4_y = old_y+h*0.5;	
        p5_x = old_x+w*0.8;
        p5_y = new_y-h*0.3;
        p6_x = old_x+w*0.8;
        p6_y = new_y-h*0.4;
        p7_x = old_x;
        p7_y = new_y-h*0.4;
      }
      else if(new_x<old_x && new_y>old_y)
      {
        w = old_x - new_x;
        h = new_y - old_y;
        p1_x = new_x;
        p1_y = old_y+h*0.4;
        p2_x = new_x+w*0.8;
        p2_y = old_y+h*0.4;
        p3_x = new_x+w*0.8;
        p3_y = old_y+h*0.3;
        p4_x = old_x;
        p4_y = old_y+h*0.5;	
        p5_x = new_x+w*0.8;
        p5_y = new_y-h*0.3;
        p6_x = new_x+w*0.8;
        p6_y = new_y-h*0.4;
        p7_x = new_x;
        p7_y = new_y-h*0.4;
      }
      if(new_x>old_x && new_y<old_y)
      {
        w = new_x - old_x;
        h = old_y - new_y;
        p1_x = old_x;
        p1_y = new_y+h*0.4;
        p2_x = old_x+w*0.8;
        p2_y = new_y+h*0.4;
        p3_x = old_x+w*0.8;
        p3_y = new_y+h*0.3;
        p4_x = new_x;
        p4_y = new_y+h*0.5;	
        p5_x = old_x+w*0.8;
        p5_y = old_y-h*0.3;
        p6_x = old_x+w*0.8;
        p6_y = old_y-h*0.4;
        p7_x = old_x;
        p7_y = old_y-h*0.4;
      }
      else if(new_x<old_x && new_y<old_y)
      {
        w = old_x - new_x;
        h = old_y - new_y;
        p1_x = new_x;
        p1_y = new_y+h*0.4;
        p2_x = new_x+w*0.8;
        p2_y = new_y+h*0.4;
        p3_x = new_x+w*0.8;
        p3_y = new_y+h*0.3;
        p4_x = old_x;
        p4_y = new_y+h*0.5;	
        p5_x = new_x+w*0.8;
        p5_y = old_y-h*0.3;
        p6_x = new_x+w*0.8;
        p6_y = old_y-h*0.4;
        p7_x = new_x;
        p7_y = old_y-h*0.4;
      }
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      if(grid_mode==0)
      root->remove_child(child_num);
      else
      root->remove_child(child_num-1);
      child_num=child_num-1;
      double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y, x4=p4_x, y4=p4_y, x5=p5_x, y5=p5_y, x6=p6_x, y6=p6_y, x7=p7_x, y7=p7_y;
      Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14;
      std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8, strstr9, strstr10, strstr11, strstr12, strstr13, strstr14;
      strstr1<<x1;
      strstr2<<y1;
      strstr3<<x2;
      strstr4<<y2;
      strstr5<<x3;
      strstr6<<y3;
      strstr7<<x4;
      strstr8<<y4;
      strstr9<<x5;
      strstr10<<y5;
      strstr11<<x6;
      strstr12<<y6;
      strstr13<<x7;
      strstr14<<y7;
      strstr1>>str1;
      strstr2>>str2;
      strstr3>>str3;
      strstr4>>str4;
      strstr5>>str5;
      strstr6>>str6;
      strstr7>>str7;
      strstr8>>str8;
      strstr9>>str9;
      strstr10>>str10;
      strstr11>>str11;
      strstr12>>str12;
      strstr13>>str13;
      strstr14>>str14;
      std::string i;
      i="M "+str1+" "+str2+" L "+str3+" "+str4+" L "+str5+" "+str6+" L "+str7+" "+str8+" L "+str9+" "+str10+" L "+str11+" "+str12+" L "+str13+" "+str14+" Z";
      Glib::RefPtr<Goocanvas::Path> path ;
      path = Goocanvas::Path::create(i); 	
      root->add_child(path);
      child_num=child_num+1;
      path->property_stroke_color() = open_global_strokecolor_hex ;	
      path->property_fill_color() = open_global_fillcolor_hex;	
      path->property_line_width() = border_width ;	
      view_grid_on_off();
    }
    return false ;
  }
  if(drawing_tool_number==3)
  {
    if((item && _dragging) && item == _dragging)
    {
      view_grid_on_off();
      new_x = event->x;
      new_y = event->y;
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      if(grid_mode==0)
      root->remove_child(child_num);
      else
      root->remove_child(child_num-1);
      child_num=child_num-1;
      double x1=old_x, y1=old_y, x2=new_x, y2=new_y;
      Glib::ustring str1, str2, str3, str4;
      std::stringstream strstr1, strstr2, strstr3, strstr4;
      strstr1<<x1;
      strstr2<<y1;
      strstr3<<x2;
      strstr4<<y2;
      strstr1>>str1;
      strstr2>>str2;
      strstr3>>str3;
      strstr4>>str4;
      if (brush_var=="M ")
      {
      brush_var=brush_var+str1+" "+str2+" L "+str3+" "+str4;
      }
      else
      {
      brush_var=brush_var+" L "+str3+" "+str4;
      }
      Glib::RefPtr<Goocanvas::Path> path ;
      path = Goocanvas::Path::create(brush_var); 	
      root->add_child(path);
      child_num=child_num+1;
      path->property_stroke_color() = open_global_strokecolor_hex ;
      path->property_line_width() = border_width;
      view_grid_on_off();
    }
    return false ;
  }

 Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
// int n1=root->find_child(item);
// int grid_number1=root->find_child(grid);
if(drawing_tool_number==4 && flag_set_for_find_child==1 && child_num>=2 && for_grp_check==0)	 //n1!=0 && n1!=1 && n1!=-1 && n1!=grid_number1 && group_var=="" && group_child_region_no.size()==0 )
 {	
	boost::timer t; // start timing
	new_x = event->x;
	new_y = event->y;
	std::string Location = "X: " + boost::lexical_cast<std::string>(new_x) + " Y: " + boost::lexical_cast<std::string>(new_y);
	pSbar->push(Location);
	if((my_item && _dragging) && my_item == _dragging)
	{
	erase_dragging_status = 1;
	view_grid_on_off();
	new_x = event->x;
	new_y = event->y;
	std::string Location = "X: " + boost::lexical_cast<std::string>(new_x) + " Y: " + boost::lexical_cast<std::string>(new_y);
	pSbar->push(Location);
	value_of_x=boost::lexical_cast<std::string>(new_x);
	value_of_y=boost::lexical_cast<std::string>(new_y);
	Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
	value_of_xx=boost::lexical_cast<std::string>(old_x);
	value_of_yy=boost::lexical_cast<std::string>(old_y);
	float width_range = open_global_width + open_global_xposition;	
	float height_range = open_global_height + open_global_yposition;

  if(flag_set_for_find_child==1)	
  {
	
 		std::string value_for_second_vector;
	    float ab=  boost::lexical_cast<float>(value_of_y);
	    float cd=  boost::lexical_cast<float>(value_of_x);

	    string value_of_new_y;
	    string value_of_new_x;
        int eraser_width_new = eraser_width/2;

		/*NEW X NEW Y CALCULATION*/

		if(new_x>=old_x && new_y>=old_y)
		{
		  a=new_x-old_x;
		  b=new_y-old_y;
		  if(a>b)
		  {
		  if(old_x > new_x)
			{
				 value_of_new_y= boost::lexical_cast<std::string>(ab+eraser_width_new);
				 value_of_new_x=value_of_x;
				 value_of_x=value_of_x;
				 value_of_y=boost::lexical_cast<std::string>(ab-eraser_width_new);

			}
			else if(old_x < new_x)
			{
				value_of_new_y= boost::lexical_cast<std::string>(ab-eraser_width_new);
				value_of_new_x=value_of_x;
				 value_of_x=value_of_x;
				 value_of_y=boost::lexical_cast<std::string>(ab+eraser_width_new);
			}
		  }
		  else
		  {
			if(old_y > new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd-eraser_width_new);

 					value_of_x=boost::lexical_cast<std::string>(cd+eraser_width_new);
				 	value_of_y=value_of_y;
			}
			else if(old_y < new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd+eraser_width_new);
						value_of_x=boost::lexical_cast<std::string>(cd-eraser_width_new);
				 	value_of_y=value_of_y;
			}
		  }
		 }
		else if(new_x>=old_x && new_y<=old_y)
		{
		  a=new_x-old_x;
		  b=old_y-new_y;
		  if(a>b)
		  {
		   if(old_x > new_x)
			{
				value_of_new_y= boost::lexical_cast<std::string>(ab+eraser_width_new);
				value_of_new_x=value_of_x;
				value_of_x=value_of_x;
				value_of_y=boost::lexical_cast<std::string>(ab-eraser_width_new);
			}
			else if(old_x < new_x)
			{
				value_of_new_y= boost::lexical_cast<std::string>(ab-eraser_width_new);
				value_of_new_x=value_of_x;
				value_of_x=value_of_x;
				value_of_y=boost::lexical_cast<std::string>(ab+eraser_width_new);
			}
		  }
		  else
		  {	
			if(old_y > new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd-eraser_width_new);
					value_of_x=boost::lexical_cast<std::string>(cd+eraser_width_new);
				 	value_of_y=value_of_y;
			}
			else if(old_y < new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd+eraser_width_new);
					value_of_x=boost::lexical_cast<std::string>(cd-eraser_width_new);
				 	value_of_y=value_of_y;
			}
		  }
		}
		else if(new_x<=old_x && new_y>=old_y)
		{
		  a=old_x-new_x;
		  b=new_y-old_y;
		  if(a>b)
		  {
			if(old_x > new_x)
			{
				value_of_new_y= boost::lexical_cast<std::string>(ab+eraser_width_new);
				value_of_new_x=value_of_x;
				value_of_x=value_of_x;
				value_of_y=boost::lexical_cast<std::string>(ab-eraser_width_new);
			}
			else if(old_x < new_x)
			{
				value_of_new_y= boost::lexical_cast<std::string>(ab-eraser_width_new);
				value_of_new_x=value_of_x;
				value_of_x=value_of_x;
				value_of_y=boost::lexical_cast<std::string>(ab+eraser_width_new);
			}
		  }
		  else
		  {
			if(old_y > new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd-eraser_width_new);
					value_of_x=boost::lexical_cast<std::string>(cd+eraser_width_new);
				 	value_of_y=value_of_y;
			}
			else if(old_y < new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd+eraser_width_new);
					value_of_x=boost::lexical_cast<std::string>(cd-eraser_width_new);
				 	value_of_y=value_of_y;
			}
		  }
		}
		else if(new_x<=old_x && new_y<=old_y)
		{
		  a=old_x-new_x;
		  b=old_y-new_y;
		  if(a>b)
		  {
			if(old_x > new_x)
			{
				value_of_new_y= boost::lexical_cast<std::string>(ab+eraser_width_new);
				value_of_new_x=value_of_x;
				value_of_x=value_of_x;
				value_of_y=boost::lexical_cast<std::string>(ab-eraser_width_new);
			}
			else if(old_x < new_x)
			{
				value_of_new_y= boost::lexical_cast<std::string>(ab-eraser_width_new);
				value_of_new_x=value_of_x;
				value_of_x=value_of_x;
				value_of_y=boost::lexical_cast<std::string>(ab+eraser_width_new);
			}
		  }
		  else
		  {
			if(old_y > new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd-eraser_width_new);
					value_of_x=boost::lexical_cast<std::string>(cd+eraser_width_new);
				 	value_of_y=value_of_y;
			}

			else if(old_y < new_y)
			{
					value_of_new_y= value_of_y;
					value_of_new_x= boost::lexical_cast<std::string>(cd+eraser_width_new);
					value_of_x=boost::lexical_cast<std::string>(cd-eraser_width_new);
				 	value_of_y=value_of_y;
			}
		  }
		}

     	std::string value_for_first_vector1=value_of_xx+","+value_of_yy;
		my_str1_tag_modified5 = value_for_first_vector1;

		value_for_second_vector=value_of_new_x+","+value_of_new_y;
		my_str1_tag_modified1.push_back(value_for_second_vector);

		std::string value_for_first_vector=value_of_x+","+value_of_y;
		my_str1_tag_modified.push_back(value_for_first_vector);
		//count_for_my_str1++;
		/*This function for call dragging Erase */

if(image_edit_status==1 && eraser_grouped_child_no.size()==0)
{
  dragging_erase();
}
else
	{
	if(eraser_grouped_child_no.size()!=0)
		{

		for(int g=0;g<eraser_grouped_child_no.size();g++)
		{
			group_indext_number = g;
		
			current_clicked_item=eraser_grouped_child_no[g];
			eraser_status=1;
			my_item = root->get_child(current_clicked_item); 

			float open_global_hei= open_global_height;
			float open_global_wid= open_global_width;
			float open_global_x_pos = open_global_xposition;
			float open_global_y_pos = open_global_yposition;
	
		   for(int g=0;g<for_image_indentification.size();g++)
		   {
			  int counts=1;
			  string get_image_number = for_image_indentification[g] ;
			  Glib::ustring image_number;
			  Glib::ustring child_number_for_image;

			  tokenizer<> tok(get_image_number);

			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
				if(counts==1)
				image_number =*beg;
				else
				child_number_for_image=*beg;
				counts++;
			   }	
				 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
				 int  image_int = boost::lexical_cast<int>(image_number);	

			   if(current_clicked_item==child_number_for_image_int)
					{
						  number_for_image = image_int;
						  for_image_set = 1;
					}		
			}

			group_select=0;
		    get_property(my_item ,current_clicked_item);
			group_select=1;
			dragging_erase();
		}
	}
	 else
		dragging_erase();
	}
		/*This function for call dragging Erase */
        }
        view_grid_on_off();
    }
    old_x=new_x;
    old_y=new_y;
  double elapsed_time = t.elapsed();
std::cout<<"this is the time we want***********"<<elapsed_time<<"\n"<<"\n";
    return false ;
 }

  if(drawing_tool_number==5)
  {
    if((item && _dragging) && item == _dragging)
    {
      new_x = event->x ;
      new_y = event->y ;
      double a = new_x + old_x;
      double b = new_y + old_y;
      double x;
      double y;
      if(new_x>old_x)
      x = new_x - old_x;
      else
      x = old_x - new_x;
      if(new_y>old_y)
      y = new_y - old_y;
      else
      y = old_y - new_y;
      if(x>0 && y>0)
      {
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        changed_item=root->get_child(changed_item_num);
        changed_item->set_property("x",a/2);
        changed_item->set_property("y",b/2);
        changed_item->set_property("line_width", border_width);
        if(group_var=="Shift_L" || group_var=="Shift_R")
        {
          if(x>y)
          x=x;
          else
          x=y;
          changed_item->set_property("radius_x",x);
          changed_item->set_property("radius_y",x);
        }
        else
        {
        changed_item->set_property("radius_x",x);
        changed_item->set_property("radius_y",y);
        }
      }
    }
    return false ;
  }

  if(drawing_tool_number==6  )
  { 
    if((item && _dragging) && item == _dragging)
    {
      new_x = event->x ;
      new_y = event->y ;
      double a;
      double b;
      double x;
      double y;
      if(new_x>old_x)
      {
      a = new_x - old_x;
      x = old_x;
      }
      else
      {
      a = old_x - new_x;
      x = new_x;
      }
      if(new_y>old_y)
      {
      b = new_y - old_y;
      y = old_y;	
      }
      else
      {
      b = old_y - new_y;
      y = new_y;
      }
      if(a>0 && b>0)
      {
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        changed_item=root->get_child(changed_item_num);
        changed_item->set_property("x",x);
        changed_item->set_property("y",y);
        if(group_var=="Shift_L" || group_var=="Shift_R")
        {
          if(a>b)
          a=a;
          else
          a=b;
          changed_item->set_property("width",a);
          changed_item->set_property("height",a);
        }
        else
        {
          changed_item->set_property("width",a);
          changed_item->set_property("height",b);
        }
      }
    }
    return false ;
  } 

  if(drawing_tool_number==7)
  { 
    if((item && _dragging) && item == _dragging)
    {
      view_grid_on_off();
      new_x = event->x ;
      new_y = event->y ;
      if(new_x>old_x && new_y>old_y)
      {
        w = new_x - old_x;
        h = new_y - old_y;
        p1_x = old_x+w/2;
        p1_y = old_y;
        p2_x = old_x+w/6;
        p2_y = new_y;
        p3_x = new_x-w/6;
        p3_y = new_y;
        p4_x = old_x;
        p4_y = old_y+h/3;
        p5_x = new_x;
        p5_y = old_y+h/3;	
      }
      else if(new_x<old_x && new_y>old_y)
      {
        w = old_x - new_x;
        h = new_y - old_y;
        p1_x = new_x+w/2;
        p1_y = old_y;
        p2_x = new_x+w/6;
        p2_y = new_y;
        p3_x = old_x-w/6;
        p3_y = new_y;
        p4_x = new_x;
        p4_y = old_y+h/3;
        p5_x = old_x;
        p5_y = old_y+h/6;
      }
      else if(new_x>old_x && new_y<old_y)
      {
        w = new_x - old_x;
        h = old_y - new_y;
        p1_x = old_x+w/2;
        p1_y = new_y;
        p2_x = old_x+w/6;
        p2_y = old_y;
        p3_x = new_x-w/6;
        p3_y = old_y;
        p4_x = old_x;
        p4_y = new_y+h/3;
        p5_x = new_x;
        p5_y = new_y+h/3;
      }
      else if(new_x<old_x && new_y<old_y)
      {
        w = old_x - new_x;
        h = old_y - new_y;
        p1_x = new_x+w/2;
        p1_y = new_y;
        p2_x = new_x+w/6;
        p2_y = old_y;
        p3_x = old_x-w/6;
        p3_y = old_y;
        p4_x = new_x;
        p4_y = new_y+h/3;
        p5_x = old_x;
        p5_y = new_y+h/3;
      }
      else
      {
        w=0;
        h=0;
      }
      if(w>0 && h>0)
      {
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        if(grid_mode==0)
        root->remove_child(child_num);
        else
        root->remove_child(child_num-1);
        child_num=child_num-1;
        double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y, x4=p4_x, y4=p4_y, x5=p5_x, y5=p5_y;
        Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8, str9, str10;
        std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8, strstr9, strstr10;
        strstr1<<x1;
        strstr2<<y1;
        strstr3<<x2;
        strstr4<<y2;
        strstr5<<x3;
        strstr6<<y3;
        strstr7<<x4;
        strstr8<<y4;
        strstr9<<x5;
        strstr10<<y5;
        strstr1>>str1;
        strstr2>>str2;
        strstr3>>str3;
        strstr4>>str4;
        strstr5>>str5;
        strstr6>>str6;
        strstr7>>str7;
        strstr8>>str8;
        strstr9>>str9;
        strstr10>>str10;
        std::string i;
        i="M "+str3+" "+str4+" L "+str1+" "+str2+" L "+str5+" "+str6+" L "+str7+" "+str8+" L "+str9+" "+str10+" Z";
        Glib::RefPtr<Goocanvas::Path> path ;
        path = Goocanvas::Path::create(i); 	
        root->add_child(path);
        path->property_stroke_color() = open_global_strokecolor_hex;
        path->property_fill_color() = open_global_fillcolor_hex;
        path->property_line_width() = border_width ;
        child_num=child_num+1;
      }
      view_grid_on_off();
    }
    return false ;
  } 

  if(drawing_tool_number==8)
  { 
    if((item && _dragging) && item == _dragging)
    {
      view_grid_on_off();
      new_x = event->x ;
      new_y = event->y ;
      if(new_x>old_x && new_y>old_y)
      {
        w = new_x - old_x;
        h = new_y - old_y;
        p1_x = old_x+w/2;
        p1_y = old_y;
        p2_x = new_x-w/2.8;
        p2_y = old_y+h/3;
        p3_x = new_x;
        p3_y = old_y+h/3;
        p4_x = old_x+w*3/4;
        p4_y = old_y+h/1.6;
        p5_x = new_x-w/7;
        p5_y = new_y;
        p6_x = old_x+w/2;
        p6_y = old_y+h*3.2/4;
        p7_x = old_x+w/7;
        p7_y = new_y;
        p8_x = old_x+w*1/4;
        p8_y = old_y+h/1.6;
        p9_x = old_x;
        p9_y = old_y+h/3;
        p10_x = old_x+w/2.8;
        p10_y = old_y+h/3;
      }
      else if(new_x<old_x && new_y>old_y)
      {
        w = old_x - new_x;
        h = new_y - old_y;
        p1_x = new_x+w/2;
        p1_y = old_y;
        p2_x = old_x-w/2.8;
        p2_y = old_y+h/3;
        p3_x = old_x;
        p3_y = old_y+h/3;
        p4_x = new_x+w*3/4;
        p4_y = old_y+h/1.6;
        p5_x = old_x-w/7;
        p5_y = new_y;
        p6_x = new_x+w/2;
        p6_y = old_y+h*3.2/4;
        p7_x = new_x+w/7;
        p7_y = new_y;
        p8_x = new_x+w*1/4;
        p8_y = old_y+h/1.6;
        p9_x = new_x;
        p9_y = old_y+h/3;
        p10_x = new_x+w/2.8;
        p10_y = old_y+h/3;
      }
      else if(new_x>old_x && new_y<old_y)
      {
        w = new_x - old_x;
        h = old_y - new_y;
        p1_x = old_x+w/2;
        p1_y = new_y;
        p2_x = new_x-w/2.8;
        p2_y = new_y+h/3;
        p3_x = new_x;
        p3_y = new_y+h/3;
        p4_x = old_x+w*3/4;
        p4_y = new_y+h/1.6;
        p5_x = new_x-w/7;
        p5_y = old_y;
        p6_x = old_x+w/2;
        p6_y = new_y+h*3.2/4;
        p7_x = old_x+w/7;
        p7_y = old_y;
        p8_x = old_x+w*1/4;
        p8_y = new_y+h/1.6;
        p9_x = old_x;
        p9_y = new_y+h/3;
        p10_x = old_x+w/2.8;
        p10_y = new_y+h/3;
      }
      else if(new_x<old_x && new_y<old_y)
      {
        w = old_x - new_x;
        h = old_y - new_y;
        p1_x = new_x+w/2;
        p1_y = new_y;
        p2_x = old_x-w/2.8;
        p2_y = new_y+h/3;
        p3_x = old_x;
        p3_y = new_y+h/3;
        p4_x = new_x+w*3/4;
        p4_y = new_y+h/1.6;
        p5_x = old_x-w/7;
        p5_y = old_y;
        p6_x = new_x+w/2;
        p6_y = new_y+h*3.2/4;
        p7_x = new_x+w/7;
        p7_y = old_y;
        p8_x = new_x+w*1/4;
        p8_y = new_y+h/1.6;
        p9_x = new_x;
        p9_y = new_y+h/3;
        p10_x = new_x+w/2.8;
        p10_y = new_y+h/3;
      }
      else
      {
        w=0;
        h=0;
      }
      if(w>0 && h>0)
      {
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        if(grid_mode==0)
        root->remove_child(child_num);
        else
        root->remove_child(child_num-1);
        child_num=child_num-1;
        double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y, x4=p4_x, y4=p4_y, x5=p5_x, y5=p5_y, x6=p6_x, y6=p6_y, x7=p7_x, y7=p7_y, x8=p8_x, y8=p8_y, x9=p9_x, 	 y9=p9_y, x10=p10_x, y10=p10_y;
        Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14, str15, str16, str17, str18, str19, str20;
        std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8, strstr9, strstr10, strstr11, strstr12, strstr13, strstr14, strstr15, strstr16, strstr17, strstr18, strstr19, strstr20;
        strstr1<<x1;
        strstr2<<y1;
        strstr3<<x2;
        strstr4<<y2;
        strstr5<<x3;
        strstr6<<y3;
        strstr7<<x4;
        strstr8<<y4;
        strstr9<<x5;
        strstr10<<y5;
        strstr11<<x6;
        strstr12<<y6;
        strstr13<<x7;
        strstr14<<y7;
        strstr15<<x8;
        strstr16<<y8;
        strstr17<<x9;
        strstr18<<y9;
        strstr19<<x10;
        strstr20<<y10;
        strstr1>>str1;
        strstr2>>str2;
        strstr3>>str3;
        strstr4>>str4;
        strstr5>>str5;
        strstr6>>str6;
        strstr7>>str7;
        strstr8>>str8;
        strstr9>>str9;
        strstr10>>str10;
        strstr11>>str11;
        strstr12>>str12;
        strstr13>>str13;
        strstr14>>str14;
        strstr15>>str15;
        strstr16>>str16;
        strstr17>>str17;
        strstr18>>str18;
        strstr19>>str19;
        strstr20>>str20;
        std::string i;
        i="M "+str1+" "+str2+" L "+str3+" "+str4+" L "+str5+" "+str6+" L "+str7+" "+str8+" L "+str9+" "+str10+" L "+str11+" "+str12+" L "+str13+" "+str14+" L "+str15+" "+str16+" L "+str17+" "+str18+" L "+str19+" "+str20+" Z";
        Glib::RefPtr<Goocanvas::Path> path ;
        path = Goocanvas::Path::create(i); 	
        root->add_child(path);
        path->property_stroke_color() = open_global_strokecolor_hex;
        path->property_fill_color() = open_global_fillcolor_hex;
        path->property_line_width() = border_width ;
        child_num=child_num+1;
      }
      view_grid_on_off();	
    }
    return false ;
  } 

  if(drawing_tool_number==9)
    {
    if((item && _dragging) && item == _dragging)
    {
      view_grid_on_off();
      new_x = event->x ; 
      new_y = event->y ;
      if(new_x>old_x && new_y>old_y)
      {
        w = new_x - old_x;
        h = new_y - old_y;
        p1_x = old_x+w/2;
        p1_y = old_y;
        p2_x = old_x;
        p2_y = new_y;
        p3_x = new_x;
        p3_y = new_y;	
      }
      else if(new_x<old_x && new_y>old_y)
      {
        w = old_x - new_x;
        h = new_y - old_y;
        p1_x = new_x+w/2;
        p1_y = old_y;
        p2_x = new_x;
        p2_y = new_y;
        p3_x = old_x;
        p3_y = new_y;
      }
      else if(new_x>old_x && new_y<old_y)
      {
        w = new_x - old_x;
        h = old_y - new_y;
        p1_x = old_x+w/2;
        p1_y = new_y;
        p2_x = old_x;
        p2_y = old_y;
        p3_x = new_x;
        p3_y = old_y;
      }
      else if(new_x<old_x && new_y<old_y)
      {
        w = old_x - new_x;
        h = old_y - new_y;
        p1_x = new_x+w/2;
        p1_y = new_y;
        p2_x = new_x;
        p2_y = old_y;
        p3_x = old_x;
        p3_y = old_y;
      } 
      else
      {
        w=0;
        h=0;
      }
      if(w>0 && h>0) 
      {
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        if(grid_mode==0)
        root->remove_child(child_num);
        else
        root->remove_child(child_num-1);
        child_num=child_num-1;
        double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y;
        Glib::ustring str1, str2, str3, str4, str5, str6;
        std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6;
        strstr1<<x1;
        strstr2<<y1;
        strstr3<<x2;
        strstr4<<y2;
        strstr5<<x3;
        strstr6<<y3;
        strstr1>>str1;
        strstr2>>str2;
        strstr3>>str3;
        strstr4>>str4;
        strstr5>>str5;
        strstr6>>str6;
        std::string i;
       // i="M "+str1+" "+str2+" L "+str3+" "+str4+" L "+str5+" "+str6+" Z";
i="M "+str1+" "+str2+" L "+str5+" "+str6+" L "+str3+" "+str4+" Z";

        Glib::RefPtr<Goocanvas::Path> path ;
        path = Goocanvas::Path::create(i); 	
        root->add_child(path);
        path->property_stroke_color() = open_global_strokecolor_hex;
        path->property_fill_color() = open_global_fillcolor_hex;
        path->property_line_width() = border_width ;
        child_num=child_num+1;
      }
      view_grid_on_off();
    }
    return false ;
  } 
  
  if(drawing_tool_number==10)
  {
    if((item && _dragging) && item == _dragging)
    {
    }
    return false ;
  } 

  //Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  int n=root->find_child(item);
  int grid_number=root->find_child(grid);
  if(drawing_tool_number==11 && n!=0  && n!=1 && n!=-1 && n!=grid_number && group_var=="" && group_child_region_no.size()==0 )
  {

    int item_no_find=root->find_child(item);
    new_x = event->x ;	
    new_y = event->y ;
    std::string Location = "X: " + boost::lexical_cast<std::string>(new_x) + " Y: " + boost::lexical_cast<std::string>(new_y);
    pSbar->push(Location);
    if(move_var==1)
    { 
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      control_item_num=root->find_child(item);
      control_item1=root->get_child(child_num-7);
      control_item2=root->get_child(child_num-6);
      control_item3=root->get_child(child_num-5);
      control_item4=root->get_child(child_num-4);
      control_item5=root->get_child(child_num-3);
      control_item6=root->get_child(child_num-2);
      control_item7=root->get_child(child_num-1);
      control_item8=root->get_child(child_num);
      if(control_item_num==child_num-7)	
    	  control_item1->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item1->set_property("stroke_color", Glib::ustring("black"));
      if(control_item_num==child_num-6)	
    	  control_item2->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item2->set_property("stroke_color", Glib::ustring("black"));
      if(control_item_num==child_num-5)	
    	  control_item3->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item3->set_property("stroke_color", Glib::ustring("black"));
      if(control_item_num==child_num-4)	
    	  control_item4->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item4->set_property("stroke_color", Glib::ustring("black"));
      if(control_item_num==child_num-3)	
    	  control_item5->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item5->set_property("stroke_color", Glib::ustring("black"));
      if(control_item_num==child_num-2)	
    	  control_item6->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item6->set_property("stroke_color", Glib::ustring("black"));
      if(control_item_num==child_num-1)	
    	  control_item7->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item7->set_property("stroke_color", Glib::ustring("black"));
      if(control_item_num==child_num)		
    	  control_item8->set_property("stroke_color", Glib::ustring("red")); 
      else
    	  control_item8->set_property("stroke_color", Glib::ustring("black"));
    }
    if(item && _dragging && item == _dragging && event->x>-100 && event->y>-100 && event->x<1580 && event->y<780) 
    {
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();



	  if(text_status==1)
	  {
		xx=item->property_x();	 
		yy=item->property_y();
		ww=wid;
		hh=hei;
	  }
	  else
	  {
		xx=item->property_x();	 
		yy=item->property_y();
		ww=item->property_width();
		hh=item->property_height();
	  }
      new_x = event->x ;	
      new_y = event->y ;
      x = new_x-old_x;
      y = new_y-old_y;
	  global_x_diff = x;
	  global_y_diff = y;

      if(grouping_flag==1)
      {
        if(move_var==0)
        {
          grp_xx=grp_xx+x;
          grp_yy=grp_yy+y;
          Glib::RefPtr<Goocanvas::Rect> rect1 ;
          rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
          #ifdef GLIBMM_PROPERTIES_ENABLED
          rect1->property_stroke_color() = "red" ;
          rect1->property_line_width() = 0.5 ;
          #endif
          root->add_child(rect1);
          child_num=child_num+1;
          first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
          second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
          third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
          fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
          fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
          sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
          seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
          eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);
          for(int i=0; i<grouped_child_no.size(); i++)
          {
            int n=grouped_child_no[i];
            changed_item=root->get_child(n);
            xx=changed_item->property_x();	 
            yy=changed_item->property_y();
            xx=xx+x;
            yy=yy+y;
            changed_item->set_property("x",xx);
            changed_item->set_property("y",yy);
          }
          xx1=grp_xx;      yy1=grp_yy;
          ww1=grp_ww;      hh1=grp_hh;
          move_var=move_var+1;
          old_x = event->x ;	
          old_y = event->y ;
        }
        else
        {
          control_item_num=root->find_child(item);
          if(control_item_num!=child_num-7 && control_item_num!=child_num-6 && control_item_num!=child_num-5 && control_item_num!=child_num-4 && control_item_num!=child_num-3 && control_item_num!=child_num-2 && control_item_num!=child_num-1 && control_item_num!=child_num)
          { 				
            grp_xx=grp_xx+x;
            grp_yy=grp_yy+y;
            if(move_var>0)
            {
            control_points_remove();
            }
            Glib::RefPtr<Goocanvas::Rect> rect1 ;
            rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
            #ifdef GLIBMM_PROPERTIES_ENABLED
            rect1->property_stroke_color() = "red" ;
            rect1->property_line_width() = 0.5 ;
            #endif
            root->add_child(rect1);
            child_num=child_num+1;
            first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
            second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
            third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
            fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
            fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
            sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
            seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
            eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);
            for(int i=0; i<grouped_child_no.size(); i++)
            {
              int n=grouped_child_no[i];
              changed_item=root->get_child(n);
              xx=changed_item->property_x();	 
              yy=changed_item->property_y();
              xx=xx+x;
              yy=yy+y;
              changed_item->set_property("x",xx);
              changed_item->set_property("y",yy);
			
			  grouped_item_num = 1;
              xx1=grp_xx;      yy1=grp_yy;
              ww1=grp_ww;      hh1=grp_hh;

			//DRAGGING 

			/*CHECK IMAGE IN THE GROUP*/

	        if(count_for_my_str1==0)
			{  
				for(int g=0;g<for_image_indentification.size();g++)
				{
				  item->get_property(Glib::ustring("x"),button_dragging_x =0);
				  item->get_property(Glib::ustring("y"),button_dragging_y =0);
				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;
				  tokenizer<> tok(get_image_number);
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	
					 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);

				     if(child_number_for_image_int==grouped_child_no[i])
					 {
						  number_for_image = image_int;
						/*GET IMAGE DATAT */
						  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
		
						  const std::string input_xml = test;
						  vector<char> xml_copy(input_xml.begin(), input_xml.end());
						  xml_copy.push_back('\0');
						  xml_document<> doc;
						  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
						  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
						  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
						  xml_node<> * abc; 
						  while (Scene != NULL )
						  {
							for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
							{
							  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
							  {
								  const char * node_name = abc->name();
								  const char * node_value = abc->value();		
								  open_node_name = node_name;
								  open_node_value = node_value;
								  const char * attribute_name = attribute->name();	
								  const char * attribute_value = attribute->value();	

									  if (strcmp(node_name, "Image") == 0)//asdf
									  {	
											count_for_my_str1=0;
											if (strcmp(attribute_name, "data") == 0) 
											{
												open_global_data = attribute_value;
											}
											if (strcmp(attribute_name, "py_data") == 0) 
											{
												open_global_python_data = attribute_value;
											}
									  }
								}
						  }
						  Scene = Scene->next_sibling("Scene");	
						}

					  for_image_group_move1(child_number_for_image_int);					 
					  string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);

					  string pushed_value = child_number_string + "@" + open_global_data;

					  for_group_image_move.push_back(pushed_value );


					  } 
				  }
			}// FIRST DRAG PUSH BACK------

				else
				 {
		  			for(int g1=0;g1<for_group_image_move.size();g1++)	
					{
						  std::string store_value = for_group_image_move[g1];
						  std::string item_check= for_group_image_move[g1];
						 tokenizer<> tok(item_check);
						 int count=1;
						 Glib::ustring item_no;
						 std::string delimiter = "@";
						 size_t pos = 0;
						 std::string token;
						 while ((pos =store_value.find(delimiter)) != std::string::npos) 
						 {
							token =  store_value .substr(0, pos);
							store_value.erase(0, pos + delimiter.length());
						 }

						 int  item_no_int = boost::lexical_cast<int>(token);
						 open_global_data=store_value;
						if(item_no_int==grouped_child_no[i])
						{
						  for_image_group_move1(item_no_int);
						  for_group_image_move.at(g1) = token + "@" + open_global_data;
						}
					 }
				 } // SECOND DRAG READS DATA FROM VECTOR ARRAY
		/*GET IMAGE DATAT */
	/*CHECK IMAGE IN THE GROUP*/
    }
	    count_for_my_str1++;	
        old_x = event->x ;	
        old_y = event->y ;
       }
      }
     }			
      if(grouping_flag==0)
      {
        if(move_var==0)
        {
          xx=xx+x;
          yy=yy+y;
          Glib::RefPtr<Goocanvas::Rect> rect1 ;
          rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
          #ifdef GLIBMM_PROPERTIES_ENABLED
          rect1->property_stroke_color() = "red" ;
          rect1->property_line_width() = 0.5 ;
          #endif
          root->add_child(rect1);
          child_num=child_num+1;

          first(xx-16,yy-16,xx,yy);
          second(xx+ww+16,yy-16,xx+ww,yy);
          third(xx-16,yy+hh+16,xx,yy+hh);
          fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
          fifth(xx+ww/2,yy-22,xx+ww/2,yy);
          sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
          seventh(xx-22,yy+hh/2,xx,yy+hh/2);
          eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);

          item->set_property("x",xx);
          item->set_property("y",yy);
          xx1=xx;      yy1=yy;
          ww1=ww;      hh1=hh;

          move_var=move_var+1;
          changed_item_num=root->find_child(item);
          old_x = event->x ;	
          old_y = event->y ;
        }
        else
        {
          control_item_num=root->find_child(item);
          if(control_item_num!=child_num-7 && control_item_num!=child_num-6 && control_item_num!=child_num-5 && control_item_num!=child_num-4 && control_item_num!=child_num-3 && control_item_num!=child_num-2 && control_item_num!=child_num-1 && control_item_num!=child_num)
          { 	

            xx=xx+x;
            yy=yy+y;
            if(move_var>0)
            {
             control_points_remove();
            }
            Glib::RefPtr<Goocanvas::Rect> rect1 ;
            rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
            #ifdef GLIBMM_PROPERTIES_ENABLED
            rect1->property_stroke_color() = "red" ;
            rect1->property_line_width() = 0.5 ;
            #endif
            root->add_child(rect1);
            child_num=child_num+1;
            first(xx-16,yy-16,xx,yy);
            second(xx+ww+16,yy-16,xx+ww,yy);
            third(xx-16,yy+hh+16,xx,yy+hh);
            fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
            fifth(xx+ww/2,yy-22,xx+ww/2,yy);
            sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
            seventh(xx-22,yy+hh/2,xx,yy+hh/2);
            eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);

            item->set_property("x",xx);
            item->set_property("y",yy);
            xx1=xx;      yy1=yy;
            ww1=ww;      hh1=hh;
            changed_item_num=root->find_child(item);

	      if(image_status==1)  // DRAGGING EVENT 
		  {

			item->get_property(Glib::ustring("x"),button_dragging_x =0);
			item->get_property(Glib::ustring("y"),button_dragging_y =0);
			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=button_dragging_x-button_press_x;
			global_y_diff=button_dragging_y-button_press_y;
			button_press_x = button_dragging_x;
			button_press_y = button_dragging_y;

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";

			string strvalue1;
			string strvalue2;
			stringstream stream(my_str1_tag);
			while( getline(stream, strvalue1, ' ') )
				split_x_y.push_back(strvalue1);

			string dis_x_str;
			string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();

			if((global_y_diff!=0)||(global_x_diff!=0))
			{
				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}
				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}

				open_global_data =  my_str1_tag;
				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

				PyObject *main = PyImport_AddModule("__main__"); // borrowed
				/*if (main == NULL)
					//error();
				return 0;*/
				PyObject *globals = PyModule_GetDict(main); // borrowed
				PyObject *py_data = PyString_FromString(open_global_python_data1);
				/*if (py_data == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata", py_data) ;
				//return 0;
				   //error();
				Py_DECREF(py_data);

				PyObject *py_data1 = PyString_FromString(dis_x_str1);
				/*if (py_data1 == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata1", py_data1);
				//return 0;*/
				   //error();
				Py_DECREF(py_data1);


				PyObject *py_data2 = PyString_FromString(dis_y_str1);
				/*if (py_data2 == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata2", py_data2);
				//return 0;
				   //error();
				Py_DECREF(py_data2);
				PyRun_SimpleString("import ast\n"
			"from shapely.geometry import Polygon, MultiPolygon\n"
			"from shapely.geometry import *\n"
			"from shapely.ops import cascaded_union\n"
			"Multipo = pythondata\n"
			"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
			"Multipo = Multipo.replace(')))','))')\n"
			"Multipo = Multipo.replace(', ((','split[(')\n"
			"Multipo = Multipo.replace('))',')]')\n"
			"Multipo = Multipo.replace('), (',')],[(')\n"
			"Multipo = Multipo.replace(', ','),(')\n"
			"Multipo = Multipo.replace(' ',',')\n"
			"Multipo = Multipo.split('split')\n"
			"s = []\n"
			"for i in Multipo:\n"
			"	a = i.split('],[')\n"
			"	if len(a) >=2:\n"
			"		i = i.replace('],[','],[[',1)\n"
			"		i = '[' + i + ']]'\n"
			"		i = ast.literal_eval(i)\n"
			"		m = []\n"
			"		n = []\n"
			"		o = []\n"
			"		for j in i[0]:\n"
			"			k = j[0]+float(pythondata1)\n"
			"			l = j[1]+float(pythondata2)\n"
			"			m.append((k,l))\n"
			"		for a in i[1]:\n"
			"			for b in a:\n"
			"				k = b[0]+float(pythondata1)\n"
			"				l = b[1]+float(pythondata2)\n"
			"				o.append((k,l))\n"
			"			n.append(o)\n"
			"		s.append(Polygon(m,n).buffer(0))\n"
			"	else:\n"
			"		i = ast.literal_eval(i)\n"
			"		m = []\n"
			"		for j in i:\n"
			"			k = j[0]+float(pythondata1)\n"
			"			l = j[1]+float(pythondata2)\n"
			"			m.append((k,l))\n"
			"		s.append(Polygon(m).buffer(0))\n"
			"C = cascaded_union(s)\n"
			"C1 = str(C)\n");
			PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
			PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
			PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
			string changed_val = PyString_AsString(eraserera);

			open_global_python_data = changed_val;
			}
		 }

		   Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(control_item_num);
		   imgg->set_property("clip_path", Glib::ustring(open_global_data));
	   }				

           old_x = event->x ;	
           old_y = event->y ;
          }
          else
          {
            find_group_or_not(changed_item_num,"double_if","sort_true","but_notify");
            changed_item=root->get_child(changed_item_num);

			double new_border_width = (border_width/open_global_width)*(ww1);
			if(control_item_num==child_num-3 || control_item_num==child_num-2)		// Control Point Number  5 or 6
				new_border_width = (border_width/open_global_height)*(hh1);
			open_global_new_linewidth = (int)round(new_border_width);
			if(open_global_new_linewidth<2)
			open_global_new_linewidth = 1;
			int image_resizing =0;
			std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[changed_item_num-1]+" </Scene> </Kalanjiyam>";
			const std::string input_xml = test;
			vector<char> xml_copy(input_xml.begin(), input_xml.end());
			xml_copy.push_back('\0');
			xml_document<> doc;
			doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
			xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
			xml_node<>* Scene = Kalanjiyam->first_node("Scene");
			xml_node<> * abc; 
			int before_paste_total_child_num=child_num;
			while (Scene != NULL )
			{
			for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
			{
			  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
			  {
				  const char * node_name = abc->name();
				  const char * node_value = abc->value();		
				  open_node_name = node_name;
				  open_node_value = node_value;
				  const char * attribute_name = attribute->name();	
				  const char * attribute_value = attribute->value();	
				  if (strcmp(node_name, "Text") == 0)
				  {
					text_status=1;
				  }
				  if (strcmp(node_name, "Image") == 0)
				  {
					image_resizing=1;
				  }
			  }
			}
			Scene = Scene->next_sibling("Scene");	
			} 

            control_item_num=root->find_child(item);
            if(control_item_num==child_num-7)		// Control Point Number 1
            { 
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }
              if(global_group_status==-1 && text_status!=1)
              {
                xx1=xx1+x;		yy1=yy1+y;
                ww1=ww1-x;		hh1=hh1-y;
                if(ww1>15 && hh1>15)
                {
				  if(new_x>old_x || new_y>old_y)
					changed_item->set_property("line_width", open_global_new_linewidth);
				  else
				  {
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				  }

                  changed_item->set_property("x",xx1);	// object item which is selected 
                  changed_item->set_property("y",yy1); 
                  changed_item->set_property("width",ww1);
                  changed_item->set_property("height",hh1);
                  control_path=root->get_child(child_num-8);	// red color control path
                  control_path->set_property("x",xx1);
                  control_path->set_property("y",yy1);
                  control_path->set_property("width",ww1);
                  control_path->set_property("height",hh1);
				  last_motion_x=event->x; last_motion_y=event->y;
                
				  if(image_resizing==1)
				  {
					control_point_number=1;
					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));
                  	imgg->set_property("width",ww1);
                  	imgg->set_property("height",hh1);	
		            imgg->set_property("x",xx1);
		            imgg->set_property("y",yy1);
					imgg->set_property("scale_to_fit",true);	
					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;
					
					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }

                }
              }
              else
              {
				open_global_new_linewidth_vector.clear();
				for(int i=0; i<grouped_child_no.size(); i++)
				{
				  text_status=0;
				  int n=grouped_child_no[i];
				  changed_item=root->get_child(n);
				  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
			      const std::string input_xml = test;
				  vector<char> xml_copy(input_xml.begin(), input_xml.end());
				  xml_copy.push_back('\0');
				  xml_document<> doc;
				  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
				  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
				  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
				  xml_node<> * abc; 
				  int before_paste_total_child_num=child_num;
				  while (Scene != NULL )
				  {
					for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Text") == 0)
						  {
							text_status=1;
						  }
						  if (strcmp(attribute_name, "linewidth") == 0)
							open_global_linewidth = atof(attribute_value);
						  if (strcmp(attribute_name, "width") == 0)
							open_global_width = atof(attribute_value);
					   }
					 }
						Scene = Scene->next_sibling("Scene");	
				  } 
				  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();

                  xx=xx+((x/grp_ww)*(-xx+grp_xx))+x;
                  yy=yy+((y/grp_hh)*(-yy+grp_yy))+y;
                  ww=ww-((x/grp_ww)*ww); 
                  hh=hh-((y/grp_hh)*hh); 

                  if(ww>15 && hh>15)
                  {
                  changed_item->set_property("x",xx);
                  changed_item->set_property("y",yy);
                  changed_item->set_property("width",ww);
                  changed_item->set_property("height",hh);
				  last_motion_x=event->x; last_motion_y=event->y;

 				  /*CHECK THE IMAEG IN TNHE GRUOUP*/
				  for_group_xx = grp_xx+x;
				  for_group_yy = grp_yy+y;
				  for_group_ww = grp_ww-x;
				  for_group_hh = grp_hh-y;

				if(count_for_my_str1<grouped_child_no.size())
				{  
				  grouped_item_num = 1;
				for(int g=0;g<for_image_indentification.size();g++)
				{

				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;
				  tokenizer<> tok(get_image_number);
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	
				 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
				 int  image_int = boost::lexical_cast<int>(image_number);

				control_point_number=1;

			    if(child_number_for_image_int==grouped_child_no[i])
				{
				      number_for_image = image_int;
					  /*GET IMAGE DATAT */
					  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
		
					  const std::string input_xml = test;
					  vector<char> xml_copy(input_xml.begin(), input_xml.end());
					  xml_copy.push_back('\0');
					  xml_document<> doc;
					  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					  xml_node<> * abc; 
					  while (Scene != NULL )
					  {
						for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
						{
						  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
						  {
							  const char * node_name = abc->name();
							  const char * node_value = abc->value();		
							  open_node_name = node_name;
							  open_node_value = node_value;
							  const char * attribute_name = attribute->name();	
							  const char * attribute_value = attribute->value();	

								  if (strcmp(node_name, "Image") == 0)//asdf
								  {	
										if (strcmp(attribute_name, "data") == 0) 
										{
											open_global_data = attribute_value;
										}
										if (strcmp(attribute_name, "py_data") == 0) 
										{
											open_global_python_data = attribute_value;
										}
								  }
							}
					  }
					Scene = Scene->next_sibling("Scene");	
					}

					 Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);
					 group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
					 string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
					 string pushed_value = child_number_string + "@" + open_global_data;
				     for_group_image_resize.push_back(pushed_value );
					 image_status=1;
					  } 
				    }
				 }// FIRST DRAG PUSH BACK------

				else
				 {
		  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
					{
						 std::string store_value = for_group_image_resize[g1];
						 std::string item_check= for_group_image_resize[g1];
						 tokenizer<> tok(item_check);
						 int count=1;
						 Glib::ustring item_no;
						 std::string delimiter = "@";
						 size_t pos = 0;
						 std::string token;
						 while ((pos =store_value.find(delimiter)) != std::string::npos) 
						 {
							token =  store_value .substr(0, pos);
							store_value.erase(0, pos + delimiter.length());
						 }

						 int  item_no_int = boost::lexical_cast<int>(token);
						 open_global_data=store_value;

						 if(item_no_int==grouped_child_no[i])
						 {
							Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);

							group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
							for_group_image_resize.at(g1) = token + "@" + open_global_data;

							image_status=1;
						}
					}
				 
				 } // SECOND DRAG READS DATA FROM VECTOR ARRAY
		}
		  		/*GET IMAGE DATAT */
		  		/*CHECK THE IMAEG IN TNHE GRUOUP*/

				count_for_my_str1++;
				double new_border_width = (open_global_linewidth/open_global_width)*(ww);
				open_global_new_linewidth = (int)round(new_border_width);
				if(open_global_new_linewidth<2)
					open_global_new_linewidth = 1;
				if(new_x>old_x || new_y>old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}

			  }
			}
				control_path=root->get_child(child_num-8);	// red color control path
				if(grp_ww>15 && grp_hh>15)
				{
				control_path->set_property("x",grp_xx);
				control_path->set_property("y",grp_yy);
				control_path->set_property("width",grp_ww);
				control_path->set_property("height",grp_hh);
				}
			  }
			}
			else if(control_item_num==child_num-6) // Control Point Number 2
			{ 
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }

			  if(global_group_status==-1 && text_status!=1)
			  {
				if(new_x<old_x || new_y>old_y)
					changed_item->set_property("line_width", open_global_new_linewidth);
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				}

                xx1=xx1;		yy1=yy1+y;
                ww1=ww1+x;		hh1=hh1-y;
                if(ww1>15 && hh1>15)
                {
                  changed_item->set_property("x",xx1);	// object item which is selected
                  changed_item->set_property("y",yy1);
                  changed_item->set_property("width",ww1);
                  changed_item->set_property("height",hh1);
                  control_path=root->get_child(child_num-8);	// red color control path
                  control_path->set_property("x",xx1);
                  control_path->set_property("y",yy1);
                  control_path->set_property("width",ww1);
                  control_path->set_property("height",hh1);	
				  last_motion_x=event->x; last_motion_y=event->y;
				  if(image_resizing==1)
				  {
					control_point_number=2;

					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));
                  	imgg->set_property("width",ww1);
                  	imgg->set_property("height",hh1);	
		            imgg->set_property("x",xx1);
		            imgg->set_property("y",yy1);
					imgg->set_property("scale_to_fit",true);	

					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;

					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }
                }
              }
              else
              {
				open_global_new_linewidth_vector.clear();
                for(int i=0; i<grouped_child_no.size(); i++)
                {
				  text_status=0;
                  int n=grouped_child_no[i];
                  changed_item=root->get_child(n);
					std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
					const std::string input_xml = test;
					vector<char> xml_copy(input_xml.begin(), input_xml.end());
					xml_copy.push_back('\0');
					xml_document<> doc;
					doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					xml_node<> * abc; 
					int before_paste_total_child_num=child_num;
					while (Scene != NULL )
					{
					for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Text") == 0)
						  {
							text_status=1;
						  }
						  if (strcmp(attribute_name, "linewidth") == 0)
							open_global_linewidth = atof(attribute_value);
						  if (strcmp(attribute_name, "width") == 0)
							open_global_width = atof(attribute_value);
					  }
					}
					Scene = Scene->next_sibling("Scene");	
					} 

				  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();
                  xx=xx+((x/grp_ww)*(xx-grp_xx));
                  yy=yy+((y/grp_hh)*(-yy+grp_yy))+y;
                  ww=ww+((x/grp_ww)*ww); 
                  hh=hh-((y/grp_hh)*hh); 
                  if(ww>15 && hh>15)
                  {
                  changed_item->set_property("x",xx);
                  changed_item->set_property("y",yy);
                  changed_item->set_property("width",ww);
                  changed_item->set_property("height",hh);
				  last_motion_x=event->x; last_motion_y=event->y;
				  for_group_xx = grp_xx;
				  for_group_yy = grp_yy+y;
				  for_group_ww = grp_ww+x;
				  for_group_hh = grp_hh-y;
				  if(count_for_my_str1<grouped_child_no.size())
				  {  
				   grouped_item_num = 1;
				  for(int g=0;g<for_image_indentification.size();g++)
				  {
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
				 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
				 int  image_int = boost::lexical_cast<int>(image_number);
				 control_point_number=2;
			     if(child_number_for_image_int==grouped_child_no[i])
					{
					  number_for_image = image_int;
					  /*GET IMAGE DATAT */
					  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
		
					  const std::string input_xml = test;
					  vector<char> xml_copy(input_xml.begin(), input_xml.end());
					  xml_copy.push_back('\0');
					  xml_document<> doc;
					  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					  xml_node<> * abc; 
					  while (Scene != NULL )
					  {
						for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
						{
						  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
						  {
							  const char * node_name = abc->name();
							  const char * node_value = abc->value();		
							  open_node_name = node_name;
							  open_node_value = node_value;
							  const char * attribute_name = attribute->name();	
							  const char * attribute_value = attribute->value();	

								  if (strcmp(node_name, "Image") == 0)//asdf
								  {	
										if (strcmp(attribute_name, "data") == 0) 
										{
											open_global_data = attribute_value;
										}
										if (strcmp(attribute_name, "py_data") == 0) 
										{
											open_global_python_data = attribute_value;
										}
								  }
							}
					  }
					Scene = Scene->next_sibling("Scene");	
					}

						  Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);
						  group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
						  string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
						  string pushed_value = child_number_string + "@" + open_global_data;
					      for_group_image_resize.push_back(pushed_value );
						  image_status=1;

						  } 
					  }

						}// FIRST DRAG PUSH BACK------

						else
						 {
	 			  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
							{
								 std::string store_value = for_group_image_resize[g1];
								 std::string item_check= for_group_image_resize[g1];
								 tokenizer<> tok(item_check);
								 int count=1;
								 Glib::ustring item_no;
								 std::string delimiter = "@";
								 size_t pos = 0;
								 std::string token;
								 while ((pos =store_value.find(delimiter)) != std::string::npos) 
								 {
									token =  store_value .substr(0, pos);
									store_value.erase(0, pos + delimiter.length());
								 }

								int  item_no_int = boost::lexical_cast<int>(token);
								open_global_data=store_value;

								if(item_no_int==grouped_child_no[i])
								{
							 		Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);
									group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
									for_group_image_resize.at(g1) = token + "@" + open_global_data;
									image_status=1;
								}
							}
						 
						 } // SECOND DRAG READS DATA FROM VECTOR ARRAY

				}
					/*GET IMAGE DATAT */
					/*CHECK THE IMAEG IN TNHE GRUOUP*/
					count_for_my_str1++;

					double new_border_width = (open_global_linewidth/open_global_width)*(ww);
					open_global_new_linewidth = (int)round(new_border_width);
					if(open_global_new_linewidth<2)
					open_global_new_linewidth = 1;
					if(new_x<old_x || new_y>old_y)
					{
						changed_item->set_property("line_width", open_global_new_linewidth);
						open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
					}
					else
					{
						open_global_new_linewidth = open_global_linewidth;
						changed_item->set_property("line_width", open_global_new_linewidth);
						open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
					}

				  }
                }
                control_path=root->get_child(child_num-8);	// red color control path
                if(grp_ww>15 && grp_hh>15)
                {
                control_path->set_property("x",grp_xx);
                control_path->set_property("y",grp_yy);
                control_path->set_property("width",grp_ww);
                control_path->set_property("height",grp_hh);
                }
              }
            }
            else if(control_item_num==child_num-5) // Control Point Number 3
            { 
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }

              if(global_group_status==-1 && text_status!=1)
              {
				if(new_x>old_x || new_y<old_y)
					changed_item->set_property("line_width", open_global_new_linewidth);
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				}

                xx1=xx1+x;		yy1=yy1;
                ww1=ww1-x;		hh1=hh1+y;
                if(ww1>15 && hh1>15)
                {
                  changed_item->set_property("x",xx1);	// object item which is selected
                  changed_item->set_property("y",yy1);
                  changed_item->set_property("width",ww1);
                  changed_item->set_property("height",hh1);
                  control_path=root->get_child(child_num-8);	// red color control path
                  control_path->set_property("x",xx1);
                  control_path->set_property("y",yy1);
                  control_path->set_property("width",ww1);
                  control_path->set_property("height",hh1);	
				  last_motion_x=event->x; last_motion_y=event->y;
				if(image_resizing==1)
				  {
					control_point_number=3;
					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));
                  	//imgg->set_property("width",ww1);
                  	//imgg->set_property("height",hh1);	
					imgg->set_property("scale_to_fit",true);	

					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;

					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }
                }
              }
              else
              {
				open_global_new_linewidth_vector.clear();
                for(int i=0; i<grouped_child_no.size(); i++)
                {
				  text_status=0;
                  int n=grouped_child_no[i];
                  changed_item=root->get_child(n);
					std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
					const std::string input_xml = test;
					vector<char> xml_copy(input_xml.begin(), input_xml.end());
					xml_copy.push_back('\0');
					xml_document<> doc;
					doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					xml_node<> * abc; 
					int before_paste_total_child_num=child_num;
					while (Scene != NULL )
					{
					for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Text") == 0)
						  {
							text_status=1;
						  }
						  if (strcmp(attribute_name, "linewidth") == 0)
							open_global_linewidth = atof(attribute_value);
						  if (strcmp(attribute_name, "width") == 0)
							open_global_width = atof(attribute_value);
					  }
					}
					Scene = Scene->next_sibling("Scene");	
					} 
				  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();
                  xx=xx+((x/grp_ww)*(-xx+grp_xx))+x;
                  yy=yy+((y/grp_hh)*(yy-grp_yy));
                  ww=ww-((x/grp_ww)*ww); 
                  hh=hh+((y/grp_hh)*hh); 
                  if(ww>15 && hh>15)
                  {
                  changed_item->set_property("x",xx);
                  changed_item->set_property("y",yy);
                  changed_item->set_property("width",ww);
                  changed_item->set_property("height",hh);
				  last_motion_x=event->x; last_motion_y=event->y;
		
				 /*CHECK THE IMAEG IN TNHE GRUOUP*/

				  for_group_xx = grp_xx+x;
				  for_group_yy = grp_yy;
				  for_group_ww = grp_ww-x;
				  for_group_hh = grp_hh+y;

			if(count_for_my_str1<grouped_child_no.size())
			{  
			  grouped_item_num = 1;
			for(int g=0;g<for_image_indentification.size();g++)
			{

			  int counts=1;
			  string get_image_number = for_image_indentification[g] ;
			  Glib::ustring image_number;
			  Glib::ustring child_number_for_image;
			  tokenizer<> tok(get_image_number);
			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
				if(counts==1)
				image_number =*beg;
				else
				child_number_for_image=*beg;
				counts++;
			   }	

				 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
				 int  image_int = boost::lexical_cast<int>(image_number);
				 control_point_number=3;
			   if(child_number_for_image_int==grouped_child_no[i])
				{
					  number_for_image = image_int;
					  /*GET IMAGE DATAT */
					  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
		
					  const std::string input_xml = test;
					  vector<char> xml_copy(input_xml.begin(), input_xml.end());
					  xml_copy.push_back('\0');
					  xml_document<> doc;
					  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					  xml_node<> * abc; 
					  while (Scene != NULL )
					  {
						for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
						{
						  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
						  {
							  const char * node_name = abc->name();
							  const char * node_value = abc->value();		
							  open_node_name = node_name;
							  open_node_value = node_value;
							  const char * attribute_name = attribute->name();	
							  const char * attribute_value = attribute->value();	
							  if (strcmp(node_name, "Image") == 0)//asdf
							  {	
									if (strcmp(attribute_name, "data") == 0) 
									{
										open_global_data = attribute_value;
									}
									if (strcmp(attribute_name, "py_data") == 0) 
									{
										open_global_python_data = attribute_value;
									}
							  }
							}
					  }
					Scene = Scene->next_sibling("Scene");	
					}

			 		Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);  
				    group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
				    string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
				    string pushed_value = child_number_string + "@" + open_global_data;
			        for_group_image_resize.push_back(pushed_value );
				    image_status=1;
					  } 
				  }
				}// FIRST DRAG PUSH BACK------

				else
				 {
		  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
					{
						 std::string store_value = for_group_image_resize[g1];
						 std::string item_check= for_group_image_resize[g1];
						 tokenizer<> tok(item_check);
						 int count=1;
						 Glib::ustring item_no;
						 std::string delimiter = "@";
						 size_t pos = 0;
						 std::string token;
						 while ((pos =store_value.find(delimiter)) != std::string::npos) 
						 {
							token =  store_value .substr(0, pos);
							store_value.erase(0, pos + delimiter.length());
						 }

						 int  item_no_int = boost::lexical_cast<int>(token);
						 open_global_data=store_value;

						if(item_no_int==grouped_child_no[i])
						{
							Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);
							group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
							for_group_image_resize.at(g1) = token + "@" + open_global_data;
							image_status=1;
						}
					}
				 
				 } // SECOND DRAG READS DATA FROM VECTOR ARRAY
		}
		/*GET IMAGE DATAT */

		/*CHECK THE IMAEG IN TNHE GRUOUP*/

				count_for_my_str1++;

				double new_border_width = (open_global_linewidth/open_global_width)*(ww);
				open_global_new_linewidth = (int)round(new_border_width);
				if(open_global_new_linewidth<2)
				open_global_new_linewidth = 1;
				if(new_x>old_x || new_y<old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
			  }
			}
                control_path=root->get_child(child_num-8);	// red color control path
                if(grp_ww>15 && grp_hh>15)
                {
                control_path->set_property("x",grp_xx);
                control_path->set_property("y",grp_yy);
                control_path->set_property("width",grp_ww);
                control_path->set_property("height",grp_hh);
                }
              }
            }
            else if(control_item_num==child_num-4) // Control Point Number 4
            { 
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }

              if(global_group_status==-1 && text_status!=1)
              {
				if(new_x<old_x || new_y<old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				}

                xx1=xx1;		yy1=yy1;
                ww1=ww1+x;		hh1=hh1+y;
                if(ww1>15 && hh1>15)
                {

                changed_item->set_property("width",ww1);	// object item which is selected
                changed_item->set_property("height",hh1);
                control_path=root->get_child(child_num-8);	// red color control path
                control_path->set_property("width",ww1);
                control_path->set_property("height",hh1);
				last_motion_x=event->x; last_motion_y=event->y;
				if(image_resizing==1)
				  {
					control_point_number=4;
					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));	
					imgg->set_property("scale_to_fit",true);	
					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;
					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }
                }

              }
              else
              {
				open_global_new_linewidth_vector.clear();
                for(int i=0; i<grouped_child_no.size(); i++)
                {
				  text_status=0;
                  int n=grouped_child_no[i];
                  changed_item=root->get_child(n);
					std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
					const std::string input_xml = test;
					vector<char> xml_copy(input_xml.begin(), input_xml.end());
					xml_copy.push_back('\0');
					xml_document<> doc;
					doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					xml_node<> * abc; 
					int before_paste_total_child_num=child_num;
					while (Scene != NULL )
					{
					for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Text") == 0)
							text_status=1;
						  if (strcmp(attribute_name, "linewidth") == 0)
							open_global_linewidth = atof(attribute_value);
						  if (strcmp(attribute_name, "width") == 0)
							open_global_width = atof(attribute_value);
					  }
					}
					Scene = Scene->next_sibling("Scene");	
					} 
				  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();
                  xx=xx+((x/grp_ww)*(xx-grp_xx));
                  yy=yy+((y/grp_hh)*(yy-grp_yy));
                  ww=ww+((x/grp_ww)*ww); 
                  hh=hh+((y/grp_hh)*hh); 
                  if(ww>15 && hh>15)
                  {
                  changed_item->set_property("x",xx);
                  changed_item->set_property("y",yy);
                  changed_item->set_property("width",ww);
                  changed_item->set_property("height",hh);
				  last_motion_x=event->x; last_motion_y=event->y;

				  /*CHECK THE IMAEG IN TNHE GRUOUP*/
				  for_group_xx = grp_xx;
				  for_group_yy = grp_yy;
				  for_group_ww = grp_ww+x;
				  for_group_hh = grp_hh+y;

				if(count_for_my_str1<grouped_child_no.size())
				{  
				  grouped_item_num = 1;
				for(int g=0;g<for_image_indentification.size();g++)
				{
				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;
				  tokenizer<> tok(get_image_number);
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	

					 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);
					 control_point_number=4;

			      if(child_number_for_image_int==grouped_child_no[i])
					{
					  number_for_image = image_int;
	
						/*GET IMAGE DATAT */
						  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
			
						  const std::string input_xml = test;
						  vector<char> xml_copy(input_xml.begin(), input_xml.end());
						  xml_copy.push_back('\0');
						  xml_document<> doc;
						  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
						  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
						  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
						  xml_node<> * abc; 
						  while (Scene != NULL )
						  {
							for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
							{
							  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
							  {
								  const char * node_name = abc->name();
								  const char * node_value = abc->value();		
								  open_node_name = node_name;
								  open_node_value = node_value;
								  const char * attribute_name = attribute->name();	
								  const char * attribute_value = attribute->value();	

									  if (strcmp(node_name, "Image") == 0)//asdf
									  {	
											if (strcmp(attribute_name, "data") == 0) 
											{
												open_global_data = attribute_value;
											}
											if (strcmp(attribute_name, "py_data") == 0) 
											{
												open_global_python_data = attribute_value;
											}
									  }
								}
						  }
						Scene = Scene->next_sibling("Scene");	
					}

					Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);
					group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
					string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
					string pushed_value = child_number_string + "@" + open_global_data;
					for_group_image_resize.push_back(pushed_value );
					image_status=1;

					  } 
				  }

				}// FIRST DRAG PUSH BACK------

				else
				 {
		  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
					{
						  std::string store_value = for_group_image_resize[g1];
						  std::string item_check= for_group_image_resize[g1];
						 tokenizer<> tok(item_check);
						 int count=1;
						 Glib::ustring item_no;
						 std::string delimiter = "@";
						 size_t pos = 0;
						 std::string token;
						 while ((pos =store_value.find(delimiter)) != std::string::npos) 
						 {
							token =  store_value .substr(0, pos);
							store_value.erase(0, pos + delimiter.length());
						 }

						 int  item_no_int = boost::lexical_cast<int>(token);
						 open_global_data=store_value;

						if(item_no_int==grouped_child_no[i])
						{
							Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);
							group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
							for_group_image_resize.at(g1) = token + "@" + open_global_data;
							image_status=1;
						}
					}
				
				 } // SECOND DRAG READS DATA FROM VECTOR ARRAY
		}
				/*GET IMAGE DATAT */
		  		/*CHECK THE IMAEG IN TNHE GRUOUP*/

				count_for_my_str1++;
				double new_border_width = (open_global_linewidth/open_global_width)*(ww);
				open_global_new_linewidth = (int)round(new_border_width);
				if(open_global_new_linewidth<2)
					open_global_new_linewidth = 1;
				if(new_x<old_x || new_y<old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
		 	  }
            }
                control_path=root->get_child(child_num-8);	// red color control path
                if(grp_ww>15 && grp_hh>15)
                {
                control_path->set_property("x",grp_xx);
                control_path->set_property("y",grp_yy);
                control_path->set_property("width",grp_ww);
                control_path->set_property("height",grp_hh);
                }
              }

            }
            else if(control_item_num==child_num-3) // Control Point Number 5
            { 
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }

              if(global_group_status==-1 && text_status!=1)
              {
				if(new_y>old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				}
                xx1=xx1;       yy1=yy1+y;		
                hh1=hh1-y;
                if(ww1>15 && hh1>15)
                { 
                changed_item->set_property("x",xx1);	// object item which is selected
                changed_item->set_property("y",yy1);
                changed_item->set_property("height",hh1);
                control_path=root->get_child(child_num-8);	// red color control path
                control_path->set_property("x",xx1);
                control_path->set_property("y",yy1);
                control_path->set_property("height",hh1);
				last_motion_x=event->x; last_motion_y=event->y;
				if(image_resizing==1)
				  {
					control_point_number=5;
					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));
					imgg->set_property("scale_to_fit",true);	
					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;
					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }
                }
              }
              else
              {
				open_global_new_linewidth_vector.clear();
                for(int i=0; i<grouped_child_no.size(); i++)
                {
				  text_status=0;
                  int n=grouped_child_no[i];
                  changed_item=root->get_child(n);
				  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
				  const std::string input_xml = test;
				  vector<char> xml_copy(input_xml.begin(), input_xml.end());
				  xml_copy.push_back('\0');
				  xml_document<> doc;
				  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
				  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
				  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
				  xml_node<> * abc; 
				  int before_paste_total_child_num=child_num;
				while (Scene != NULL )
				{
				 for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
				 {
				  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
				  {
					  const char * node_name = abc->name();
					  const char * node_value = abc->value();		
					  open_node_name = node_name;
					  open_node_value = node_value;
					  const char * attribute_name = attribute->name();	
					  const char * attribute_value = attribute->value();	
					  if (strcmp(node_name, "Text") == 0)
					  {
						text_status=1;
					  }
					  if (strcmp(attribute_name, "linewidth") == 0)
						open_global_linewidth = atof(attribute_value);
					  if (strcmp(attribute_name, "width") == 0)
						open_global_width = atof(attribute_value);
				  }
				}
				Scene = Scene->next_sibling("Scene");	
				} 
				  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();
                  xx=xx+((x/grp_ww)*(xx-grp_xx));
                  yy=yy+((y/grp_hh)*(-yy+grp_yy))+y;
                  ww=ww+((x/grp_ww)*ww); 
                  hh=hh-((y/grp_hh)*hh); 
                  if(hh>15)
                  {
                  changed_item->set_property("y",yy);
                  changed_item->set_property("height",hh);
				  last_motion_x=event->x; last_motion_y=event->y;

				/*CHECK THE IMAEG IN TNHE GRUOUP*/

				for_group_xx = grp_xx;
				for_group_yy = grp_yy+y;
				for_group_ww = grp_ww;
				for_group_hh = grp_hh-y;

			if(count_for_my_str1<grouped_child_no.size())
			{  
			  grouped_item_num = 1;
			for(int g=0;g<for_image_indentification.size();g++)
			{
			  int counts=1;
			  string get_image_number = for_image_indentification[g] ;
			  Glib::ustring image_number;
			  Glib::ustring child_number_for_image;
			  tokenizer<> tok(get_image_number);
			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
				if(counts==1)
				image_number =*beg;
				else
				child_number_for_image=*beg;
				counts++;
			   }	
				 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
				 int  image_int = boost::lexical_cast<int>(image_number);
				 control_point_number=5;
			     if(child_number_for_image_int==grouped_child_no[i])
				{
					  number_for_image = image_int;
	
					 /*GET IMAGE DATAT */
					  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
		
					  const std::string input_xml = test;
					  vector<char> xml_copy(input_xml.begin(), input_xml.end());
					  xml_copy.push_back('\0');
					  xml_document<> doc;
					  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					  xml_node<> * abc; 
					  while (Scene != NULL )
					  {
						for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
						{
						  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
						  {
							  const char * node_name = abc->name();
							  const char * node_value = abc->value();		
							  open_node_name = node_name;
							  open_node_value = node_value;
							  const char * attribute_name = attribute->name();	
							  const char * attribute_value = attribute->value();	
							  if (strcmp(node_name, "Image") == 0)//asdf
							  {	
									if (strcmp(attribute_name, "data") == 0) 
									{
										open_global_data = attribute_value;
									}
									if (strcmp(attribute_name, "py_data") == 0) 
									{
										open_global_python_data = attribute_value;
									}
							  }
							}
					    }
					  Scene = Scene->next_sibling("Scene");	
					}

					Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);
					group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
					string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
					string pushed_value = child_number_string + "@" + open_global_data;
					for_group_image_resize.push_back(pushed_value );
					image_status=1;

				  } 
			  }

			}// FIRST DRAG PUSH BACK------

			else
			 {
	  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
				{
					  std::string store_value = for_group_image_resize[g1];
					  std::string item_check= for_group_image_resize[g1];
					 tokenizer<> tok(item_check);
					 int count=1;
					 Glib::ustring item_no;
					 std::string delimiter = "@";
					 size_t pos = 0;
					 std::string token;
					 while ((pos =store_value.find(delimiter)) != std::string::npos) 
					 {
						token =  store_value .substr(0, pos);
						store_value.erase(0, pos + delimiter.length());
					 }

					 int  item_no_int = boost::lexical_cast<int>(token);
					open_global_data=store_value;

//								open_python=store_value;
					if(item_no_int==grouped_child_no[i])
					{
						Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);
						group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
						for_group_image_resize.at(g1) = token + "@" + open_global_data;
						image_status=1;
					}
				}
			 
			 } // SECOND DRAG READS DATA FROM VECTOR ARRAY

	}
				/*GET IMAGE DATAT */

				/*CHECK THE IMAEG IN TNHE GRUOUP*/

				count_for_my_str1++;
				double new_border_width = (open_global_linewidth/open_global_height)*(hh);
				open_global_new_linewidth = (int)round(new_border_width);
				if(open_global_new_linewidth<2)
					open_global_new_linewidth = 1;
				if(new_y>old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
			  } 
		   }
				control_path=root->get_child(child_num-8);	// red color control path
				if(grp_hh>15)
				{
				control_path->set_property("y",grp_yy);
				control_path->set_property("height",grp_hh);
				}
			  }
			}
			else if(control_item_num==child_num-2) // Control Point Number 6
			{ 
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }

			  if(global_group_status==-1 && text_status!=1)
			  {
				if(new_y<old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				}

                xx1=xx1;       yy1=yy1;
                hh1=hh1+y;
                if(ww1>15 && hh1>15)
                { 
                changed_item->set_property("height",hh1);	// object item which is selected
                control_path=root->get_child(child_num-8);	// red color control path
                control_path->set_property("height",hh1);	
				last_motion_x=event->x; last_motion_y=event->y;
				if(image_resizing==1)
				  {
					control_point_number=6;
					
					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));
					imgg->set_property("scale_to_fit",true);	
					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;

					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }
                }
              }
              else
              {
				open_global_new_linewidth_vector.clear();
                for(int i=0; i<grouped_child_no.size(); i++)
                {
				  text_status=0;
                  int n=grouped_child_no[i];
                  changed_item=root->get_child(n);
					std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
					const std::string input_xml = test;
					vector<char> xml_copy(input_xml.begin(), input_xml.end());
					xml_copy.push_back('\0');
					xml_document<> doc;
					doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					xml_node<> * abc; 
					int before_paste_total_child_num=child_num;
					while (Scene != NULL )
					{
					for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Text") == 0)
						  {
							text_status=1;
						  }
						  if (strcmp(attribute_name, "linewidth") == 0)
							open_global_linewidth = atof(attribute_value);
						  if (strcmp(attribute_name, "width") == 0)
							open_global_width = atof(attribute_value);
					  }
					}
					Scene = Scene->next_sibling("Scene");	
				} 
				  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();
                  xx=xx+((x/grp_ww)*(xx-grp_xx));
                  yy=yy+((y/grp_hh)*(yy-grp_yy));
                  ww=ww+((x/grp_ww)*ww); 
                  hh=hh+((y/grp_hh)*hh); 
                  if(hh>15)
                  {
                  changed_item->set_property("y",yy);
                  changed_item->set_property("height",hh);
				  last_motion_x=event->x; last_motion_y=event->y;

/*CHECK THE IMAEG IN TNHE GRUOUP*/

				for_group_xx = grp_xx;
				for_group_yy = grp_yy;
				for_group_ww = grp_ww;
				for_group_hh = grp_hh+y;

			if(count_for_my_str1<grouped_child_no.size())
			{  
			  grouped_item_num = 1;
			for(int g=0;g<for_image_indentification.size();g++)
			{

			  int counts=1;
			  string get_image_number = for_image_indentification[g] ;
			  Glib::ustring image_number;
			  Glib::ustring child_number_for_image;
			  tokenizer<> tok(get_image_number);
			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
				if(counts==1)
				image_number =*beg;
				else
				child_number_for_image=*beg;
				counts++;
			   }	
				 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
				 int  image_int = boost::lexical_cast<int>(image_number);
				 control_point_number=6;
			   if(child_number_for_image_int==grouped_child_no[i])
					{
					  number_for_image = image_int;
					  /*GET IMAGE DATAT */
					  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
					  const std::string input_xml = test;
					  vector<char> xml_copy(input_xml.begin(), input_xml.end());
					  xml_copy.push_back('\0');
					  xml_document<> doc;
					  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
					  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
					  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
					  xml_node<> * abc; 
					  while (Scene != NULL )
					  {
						for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
						{
						  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
						  {
							  const char * node_name = abc->name();
							  const char * node_value = abc->value();		
							  open_node_name = node_name;
							  open_node_value = node_value;
							  const char * attribute_name = attribute->name();	
							  const char * attribute_value = attribute->value();	
							  if (strcmp(node_name, "Image") == 0)//asdf
							  {	
									if (strcmp(attribute_name, "data") == 0) 
									{
										open_global_data = attribute_value;
									}
									if (strcmp(attribute_name, "py_data") == 0) 
									{
										open_global_python_data = attribute_value;
									}
							  }
							}
					  }
					Scene = Scene->next_sibling("Scene");	
					}

					Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);
					group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
					string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
					string pushed_value = child_number_string + "@" + open_global_data;
					for_group_image_resize.push_back(pushed_value );
					image_status=1;
					  } 
				  }
				}// FIRST DRAG PUSH BACK------

					else
					 {
 			  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
						{
							 std::string store_value = for_group_image_resize[g1];
							 std::string item_check= for_group_image_resize[g1];
							 tokenizer<> tok(item_check);
							 int count=1;
							 Glib::ustring item_no;
							 std::string delimiter = "@";
							 size_t pos = 0;
							 std::string token;
							 while ((pos =store_value.find(delimiter)) != std::string::npos) 
							 {
								token =  store_value .substr(0, pos);
								store_value.erase(0, pos + delimiter.length());
							 }

							 int  item_no_int = boost::lexical_cast<int>(token);
							 open_global_data=store_value;

							if(item_no_int==grouped_child_no[i])
							{
								Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);
								group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
								for_group_image_resize.at(g1) = token + "@" + open_global_data;
								image_status=1;
							}
						}
					 } // SECOND DRAG READS DATA FROM VECTOR ARRAY
			}
				/*GET IMAGE DATAT */

				/*CHECK THE IMAEG IN TNHE GRUOUP*/
				count_for_my_str1++;
				double new_border_width = (open_global_linewidth/open_global_height)*(hh);
				open_global_new_linewidth = (int)round(new_border_width);
				if(open_global_new_linewidth<2)
				open_global_new_linewidth = 1;
				if(new_y<old_y)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}

				  }
                }
                control_path=root->get_child(child_num-8);	// red color control path
                if(grp_hh>15)
                {
                control_path->set_property("y",grp_yy);
                control_path->set_property("height",grp_hh);
                }
              }
            }
            else if(control_item_num==child_num-1) // Control Point Number 7
            { 
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }

              if(global_group_status==-1 && text_status!=1)
              {
				if(new_x>old_x)
					changed_item->set_property("line_width", open_global_new_linewidth);
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				}
                xx1=xx1+x;     yy1=yy1;
                ww1=ww1-x;
                if(ww1>15 && hh1>15)
                { 
                changed_item->set_property("x",xx1);	// object item which is selected
                changed_item->set_property("y",yy1);
                changed_item->set_property("width",ww1);
                control_path=root->get_child(child_num-8);	// red color control path
                control_path->set_property("x",xx1);
                control_path->set_property("y",yy1);
                control_path->set_property("width",ww1);
				last_motion_x=event->x; last_motion_y=event->y;
				if(image_resizing==1)
				  {
					control_point_number=7;
				
					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));
					imgg->set_property("scale_to_fit",true);	

					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;

					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }
                }
              }
              else
              {
				open_global_new_linewidth_vector.clear();
                for(int i=0; i<grouped_child_no.size(); i++)
                {
				  text_status=0;
                  int n=grouped_child_no[i];
                  changed_item=root->get_child(n);
				  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
				  const std::string input_xml = test;
				  vector<char> xml_copy(input_xml.begin(), input_xml.end());
				  xml_copy.push_back('\0');
				  xml_document<> doc;
				  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
			 	  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
			 	  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
				  xml_node<> * abc; 
				  int before_paste_total_child_num=child_num;
				  while (Scene != NULL )
				  {
				  for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
				  {
				   for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
				   {
					  const char * node_name = abc->name();
					  const char * node_value = abc->value();		
					  open_node_name = node_name;
					  open_node_value = node_value;
					  const char * attribute_name = attribute->name();	
					  const char * attribute_value = attribute->value();	
					  if (strcmp(node_name, "Text") == 0)
					  {
						text_status=1;
					  }
					  if (strcmp(attribute_name, "linewidth") == 0)
						open_global_linewidth = atof(attribute_value);
					  if (strcmp(attribute_name, "width") == 0)
						open_global_width = atof(attribute_value);
				   }
				 }
				 Scene = Scene->next_sibling("Scene");	
				} 
			  	  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();
                  xx=xx+((x/grp_ww)*(-xx+grp_xx))+x;
                  yy=yy+((y/grp_hh)*(yy-grp_yy));
                  ww=ww-((x/grp_ww)*ww); 
                  hh=hh+((y/grp_hh)*hh); 
                  if(ww>15)
                  {
                  changed_item->set_property("x",xx);
                  changed_item->set_property("width",ww);
				  last_motion_x=event->x; last_motion_y=event->y;

				/*CHECK THE IMAEG IN TNHE GRUOUP*/

				for_group_xx = grp_xx+x;
				for_group_yy = grp_yy;
				for_group_ww = grp_ww-x;
				for_group_hh = grp_hh;

			if(count_for_my_str1<grouped_child_no.size())
			{  
			  grouped_item_num = 1;
			for(int g=0;g<for_image_indentification.size();g++)
			{

			  int counts=1;
			  string get_image_number = for_image_indentification[g] ;
			  Glib::ustring image_number;
			  Glib::ustring child_number_for_image;
			  tokenizer<> tok(get_image_number);
			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
				if(counts==1)
				image_number =*beg;
				else
				child_number_for_image=*beg;
				counts++;
			   }	
			  int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
			  int  image_int = boost::lexical_cast<int>(image_number);
			   control_point_number=7;

			   if(child_number_for_image_int==grouped_child_no[i])
				{
				  number_for_image = image_int;
				  /*GET IMAGE DATAT */
				  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
	
				  const std::string input_xml = test;
				  vector<char> xml_copy(input_xml.begin(), input_xml.end());
				  xml_copy.push_back('\0');
				  xml_document<> doc;
				  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
				  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
				  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
				  xml_node<> * abc; 
				  while (Scene != NULL )
				  {
					for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Image") == 0)//asdf
						  {	
							if (strcmp(attribute_name, "data") == 0) 
							{
								open_global_data = attribute_value;
							}
							if (strcmp(attribute_name, "py_data") == 0) 
							{
								open_global_python_data = attribute_value;
							}
						  }
						}
					  }
					Scene = Scene->next_sibling("Scene");	
					}

					Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);
					group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
					string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
					string pushed_value = child_number_string + "@" + open_global_data;
					for_group_image_resize.push_back(pushed_value );
					image_status=1;
				   } 
				 }
				}// FIRST DRAG PUSH BACK------

				else
				 {
		  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
					{
						 std::string store_value = for_group_image_resize[g1];
						 std::string item_check= for_group_image_resize[g1];
						 tokenizer<> tok(item_check);
						 int count=1;
						 Glib::ustring item_no;
						 std::string delimiter = "@";
						 size_t pos = 0;
						 std::string token;
						 while ((pos =store_value.find(delimiter)) != std::string::npos) 
						 {
							token =  store_value .substr(0, pos);
							store_value.erase(0, pos + delimiter.length());
						 }

						 int  item_no_int = boost::lexical_cast<int>(token);
						 open_global_data=store_value;
						if(item_no_int==grouped_child_no[i])
						{
							Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);
							group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
							for_group_image_resize.at(g1) = token + "@" + open_global_data;
							image_status=1;
						}
					}
				 } // SECOND DRAG READS DATA FROM VECTOR ARRAY
       		}
					/*GET IMAGE DATAT */

				    /*CHECK THE IMAEG IN TNHE GRUOUP*/

				count_for_my_str1++;

				double new_border_width = (open_global_linewidth/open_global_width)*(ww);
				open_global_new_linewidth = (int)round(new_border_width);
				if(open_global_new_linewidth<2)
					open_global_new_linewidth = 1;
				if(new_x>old_x)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
			  }
            }
                control_path=root->get_child(child_num-8);	// red color control path
                if(grp_ww>15)
                {
                control_path->set_property("x",grp_xx);
                control_path->set_property("width",grp_ww);
                }
              }
            }
            else if(control_item_num==child_num)  // Control Point Number 8
            {
			  if(eraser_drag_flag==0)
			  {
				  changed_item->get_property(Glib::ustring("width"),button_press_width =0);
				  changed_item->get_property(Glib::ustring("height"),button_press_height =0);
				  eraser_drag_flag++;
			  }

              if(global_group_status==-1 && text_status!=1)
              {
				if(new_x<old_x)
					changed_item->set_property("line_width", open_global_new_linewidth);
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
				}
                xx1=xx1;       
                yy1=yy1;
                ww1=ww1+x;
                if(ww1>15 && hh1>15)
                { 
                changed_item->set_property("width",ww1);	// object item which is selected
                control_path=root->get_child(child_num-8);	// red color control path
                control_path->set_property("width",ww1);
				last_motion_x=event->x; last_motion_y=event->y;
				if(image_resizing==1)
				  {
					control_point_number=8;
					image_resize(path_old_x,path_old_y,last_motion_x,last_motion_y);
					Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(changed_item_num);
					imgg->set_property("clip_path", Glib::ustring(open_global_data));
					imgg->set_property("scale_to_fit",true);	
					open_global_xposition = xx1; 
					open_global_yposition = yy1;
					open_global_width = ww1; 
					open_global_height = hh1;
					path_old_x = event->x; 
					path_old_y = event->y;
					image_status = 1;
				  }
                }
              }
              else
              {
				open_global_new_linewidth_vector.clear();
                for(int i=0; i<grouped_child_no.size(); i++)
                {
				  text_status=0;
                  int n=grouped_child_no[i];
                  changed_item=root->get_child(n);
				  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";
				  const std::string input_xml = test;
				  vector<char> xml_copy(input_xml.begin(), input_xml.end());
				  xml_copy.push_back('\0');
				  xml_document<> doc;
				  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
				  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
				  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
				  xml_node<> * abc; 
				  int before_paste_total_child_num=child_num;
				  while (Scene != NULL )
				  {
				   for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Text") == 0)
						  {
							text_status=1;
						  }
						  if (strcmp(attribute_name, "linewidth") == 0)
							open_global_linewidth = atof(attribute_value);
						  if (strcmp(attribute_name, "width") == 0)
							open_global_width = atof(attribute_value);
					  }
					}
				   Scene = Scene->next_sibling("Scene");	
				  } 
				  if(text_status!=1)
				  {
                  xx=changed_item->property_x();	 
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();	
                  hh=changed_item->property_height();
                  xx=xx+((x/grp_ww)*(xx-grp_xx));
                  yy=yy+((y/grp_hh)*(yy-grp_yy));
                  ww=ww+((x/grp_ww)*ww); 
                  hh=hh+((y/grp_hh)*hh); 
                  if(ww>15)
                  {
                  changed_item->set_property("x",xx);
                  changed_item->set_property("width",ww);
				  last_motion_x=event->x; last_motion_y=event->y;

 				/*CHECK THE IMAEG IN TNHE GRUOUP*/
				for_group_xx = grp_xx;
				for_group_yy = grp_yy;
				for_group_ww = grp_ww+x;
				for_group_hh = grp_hh;

			if(count_for_my_str1<grouped_child_no.size())
			{  
			  grouped_item_num = 1;
			for(int g=0;g<for_image_indentification.size();g++)
			{

			  int counts=1;
			  string get_image_number = for_image_indentification[g] ;
			  Glib::ustring image_number;
			  Glib::ustring child_number_for_image;
			  tokenizer<> tok(get_image_number);
			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
				if(counts==1)
				image_number =*beg;
				else
				child_number_for_image=*beg;
				counts++;
			   }	
				 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
				 int  image_int = boost::lexical_cast<int>(image_number);
				 control_point_number=8;

			     if(child_number_for_image_int==grouped_child_no[i])
				  {
				  number_for_image = image_int;

				  /*GET IMAGE DATAT */
				  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[child_number_for_image_int-1]+" </Scene> </Kalanjiyam>";
	
				  const std::string input_xml = test;
				  vector<char> xml_copy(input_xml.begin(), input_xml.end());
				  xml_copy.push_back('\0');
				  xml_document<> doc;
				  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
				  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
				  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
				  xml_node<> * abc; 
				  while (Scene != NULL )
				  {
					for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
					{
					  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
					  {
						  const char * node_name = abc->name();
						  const char * node_value = abc->value();		
						  open_node_name = node_name;
						  open_node_value = node_value;
						  const char * attribute_name = attribute->name();	
						  const char * attribute_value = attribute->value();	
						  if (strcmp(node_name, "Image") == 0)//asdf
						  {	
								if (strcmp(attribute_name, "data") == 0) 
								{
									open_global_data = attribute_value;
								}
								if (strcmp(attribute_name, "py_data") == 0) 
								{
									open_global_python_data = attribute_value;
								}
						  }
					  }
				    }
				  Scene = Scene->next_sibling("Scene");	
			    }

				Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(child_number_for_image_int);
				group_image_resize(child_number_for_image_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
				string child_number_string = boost::lexical_cast<std::string>(child_number_for_image_int);
				string pushed_value = child_number_string + "@" + open_global_data;
				for_group_image_resize.push_back(pushed_value );
				image_status=1;
				} 
			  }

			}// FIRST DRAG PUSH BACK------
			else
			 {
	  			for(int g1=0;g1<for_group_image_resize.size();g1++)	
				{
					  std::string store_value = for_group_image_resize[g1];
					  std::string item_check= for_group_image_resize[g1];
					 tokenizer<> tok(item_check);
					 int count=1;
					 Glib::ustring item_no;
					 std::string delimiter = "@";
					 size_t pos = 0;
					 std::string token;
					 while ((pos =store_value.find(delimiter)) != std::string::npos) 
					 {
						token =  store_value .substr(0, pos);
						store_value.erase(0, pos + delimiter.length());
					 }

					 int  item_no_int = boost::lexical_cast<int>(token);
					 open_global_data=store_value;
					if(item_no_int==grouped_child_no[i])
					{
						Glib::RefPtr<Goocanvas::Item> new_item  = root->get_child(item_no_int);
						group_image_resize(item_no_int,image_old_x,image_old_y,last_motion_x,last_motion_y);					 
						for_group_image_resize.at(g1) = token + "@" + open_global_data;
						image_status=1;
					}
				}
			 
			 } // SECOND DRAG READS DATA FROM VECTOR ARRAY
	}
				/*GET IMAGE DATAT */
	 		    /*CHECK THE IMAEG IN TNHE GRUOUP*/


				count_for_my_str1++;


				double new_border_width = (open_global_linewidth/open_global_width)*(ww);
				open_global_new_linewidth = (int)round(new_border_width);
				if(open_global_new_linewidth<2)
				open_global_new_linewidth = 1;
				if(new_x<old_x)
				{
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
				else
				{
					open_global_new_linewidth = open_global_linewidth;
					changed_item->set_property("line_width", open_global_new_linewidth);
					open_global_new_linewidth_vector.push_back(open_global_new_linewidth);
				}
			  }
            }
                control_path=root->get_child(child_num-8);	// red color control path
                if(grp_ww>15)
                {
                control_path->set_property("x",grp_xx);
                control_path->set_property("width",grp_ww);
                }
              }
            }
            control_item1=root->get_child(child_num-7);
            control_item1->set_property("stroke_color", Glib::ustring("gray"));
            control_item2=root->get_child(child_num-6);
            control_item2->set_property("stroke_color", Glib::ustring("gray"));
            control_item3=root->get_child(child_num-5);
            control_item3->set_property("stroke_color", Glib::ustring("gray"));
            control_item4=root->get_child(child_num-4);
            control_item4->set_property("stroke_color", Glib::ustring("gray"));
            control_item5=root->get_child(child_num-3);
            control_item5->set_property("stroke_color", Glib::ustring("gray"));
            control_item6=root->get_child(child_num-2);
            control_item6->set_property("stroke_color", Glib::ustring("gray"));
            control_item7=root->get_child(child_num-1);
            control_item7->set_property("stroke_color", Glib::ustring("gray"));
            control_item8=root->get_child(child_num);
            control_item8->set_property("stroke_color", Glib::ustring("gray"));
            old_x = event->x ;	
            old_y = event->y ;
            //If the child is in group, should pop all values at each release event //code starts here
            int child_no_size=grouped_child_no.size();
            for(int i=0; i<child_no_size; i++)
            {
            grouped_child_no.pop_back();
            group_xx.pop_back();
            group_yy.pop_back();
            group_end_xx.pop_back();
            group_end_yy.pop_back();
            }
          }
        }
      }
    }


	if( image_status==1)  
	{
		image_old_x = event->x;
		image_old_y = event->y;
	}
   return false;
 }

  if(drawing_tool_number==14 )
  {
    int grid_status=0;
    if(grid_mode==1)
    { 
      view_grid_on_off();
      grid_status=1;
    }
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    if(curve_cnt>=1) 
    {
      Glib::RefPtr<Goocanvas::Ellipse> ellipse ;
      ellipse = Goocanvas::Ellipse::create(old_x, old_y, 0.1, 0.1);
      root->add_child(ellipse);
      child_num=child_num+1;
      #ifdef GLIBMM_PROPERTIES_ENABLED
      ellipse->property_fill_color() = open_global_fillcolor_hex ;
      ellipse->property_stroke_color() = open_global_strokecolor_hex ;
      ellipse->property_line_width() = 1 ;
      #endif       
      for(child_var=last_child_num+1; child_var<=child_num; child_var++)
      {
      root->remove_child(last_child_num+1);	
      }
      child_num=last_child_num; 
    }
    new_x = event->x ;
    new_y = event->y ;

    if(item && _dragging && item == _dragging && curve_cnt>1)
    {
      a = new_x-new_a; 
      b = new_y-new_b;
      double x1=old_x, y1=old_y, x2=new_a, y2=new_b,	x3=old_x-a, y3=old_y-b, x4=new_a-a, y4=new_b-b;
      Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8;
      std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8;
      strstr1<<x1;
      strstr2<<y1;
      strstr3<<x2;
      strstr4<<y2;
      strstr5<<x3;
      strstr6<<y3;
      strstr7<<x4;
      strstr8<<y4;
      strstr1>>str1;
      strstr2>>str2;
      strstr3>>str3;
      strstr4>>str4;
      strstr5>>str5;
      strstr6>>str6;
      strstr7>>str7;
      strstr8>>str8;
      curve_var="M "+str1+" "+str2+" C "+str5+" "+str6+" "+str7+" "+str8+" "+str3+" "+str4;
      last_child_num=child_num;
      Glib::RefPtr<Goocanvas::Path> path ;
      path = Goocanvas::Path::create(curve_var); 	
      root->add_child(path);
      child_num=child_num+1; 
      path->property_stroke_color() = open_global_strokecolor_hex;	
      path->property_line_width() = 1;  
      Glib::RefPtr<Goocanvas::Polyline> line ;
      Glib::RefPtr<Goocanvas::Ellipse> ellipse ;
      line = Goocanvas::Polyline::create(new_a-a, new_b-b, new_x, new_y);
      root->add_child(line);
      child_num=child_num+1;
      #ifdef GLIBMM_PROPERTIES_ENABLED
      line->property_stroke_color() = "Red";
      line->property_line_width() = 1;
      #endif
      ellipse = Goocanvas::Ellipse::create(new_a-a , new_b-b , 2.0, 2.0);
      root->add_child(ellipse);
      child_num=child_num+1;
      #ifdef GLIBMM_PROPERTIES_ENABLED
      ellipse->property_fill_color() = open_global_fillcolor_hex ;
      ellipse->property_stroke_color() = "Red";
      ellipse->property_line_width() = 1;
      #endif
      ellipse = Goocanvas::Ellipse::create(new_x , new_y , 2.0, 2.0);
      root->add_child(ellipse);
      child_num=child_num+1;
      #ifdef GLIBMM_PROPERTIES_ENABLED
      ellipse->property_fill_color() = open_global_fillcolor_hex ;
      ellipse->property_stroke_color() = "Red";
      ellipse->property_line_width() = 1;
      #endif
      dragging_var=dragging_var+1;
    }
    else
    {
      if(curve_cnt!=0)
      {
        last_child_num=child_num;
        if(curve_cnt==dragging_var) 
        {
        old_x=old_x; old_y=old_y;
        }
        else
        {
        old_x=new_a; old_y=new_b;
        }
        Glib::RefPtr<Goocanvas::Polyline> line = Goocanvas::Polyline::create(old_x, old_y, new_x, new_y);
        root->add_child(line);
        child_num=child_num+1; 
        #ifdef GLIBMM_PROPERTIES_ENABLED
        line->property_stroke_color() = "Red" ; //color of the line
        line->property_line_width() = 1;
        line->property_start_arrow() = false ;
        line->property_end_arrow() = false ;
        line->property_arrow_tip_length() = 5.0 ;
        line->property_arrow_length() = 6.0 ;
        line->property_arrow_width() = 6.0 ;
        #endif
      }
    }
    if(grid_status==1)
    view_grid_on_off();
    return false;
  }

}

bool
KalanjiyamWindow::on_rect_button_release_event(const Glib::RefPtr<Goocanvas::Item>& item, GdkEventButton* event)
{
  button_press_status = 1;
  double my_x;
  my_x =event->x;
  if(drawing_tool_number==11 && right_click_press_status==0)
  {
	int erased_item_resize=0;
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    int n=root->find_child(item);
    int grid_number=root->find_child(grid);

    if(event->button==1 && n!=0 && n!=1 && n!=-1 && n!=grid_number)
    {


	item->get_property(Glib::ustring("x"),button_release_x =0);
	item->get_property(Glib::ustring("y"),button_release_y =0);

	different_move_x = button_release_x - button_press_x;

	different_move_y = button_release_y - button_press_y;

	Glib::ustring different_move_x_str = boost::lexical_cast<std::string>(different_move_x);
	Glib::ustring different_move_y_str = boost::lexical_cast<std::string>(different_move_y);
	Glib::ustring item_no_str = boost::lexical_cast<std::string>(n);
	Glib::ustring joined_x_y_item = different_move_x_str+ ","+ different_move_y_str;
	//press_x_y.push_back(joined_x_y_item);
	press_x_y=joined_x_y_item;

      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
	  if(text_status==1)
	  {
			xx=item->property_x();	 
			yy=item->property_y();
			ww=wid;
			hh=hei;
	 }
	 else
	 {
		  xx=item->property_x();	 
		  yy=item->property_y();
		  ww=item->property_width();
		  hh=item->property_height();
	 }

      new_x = event->x ;	
      new_y = event->y ;
      x = new_x-old_x;
      y = new_y-old_y;

      if(group_var=="Shift_L" || group_var=="Shift_R")	//Child items select for grouping with Shift key
      {	
        if(move_var>0) 
        {
          if(grouping_flag==1)	//If the click item is a grouped item.
          {
            int group_child_same_no=-1;
            for(int i=0; i<group_child_no.size(); i++)
            {
              if(group_child_no[i]==n)
              {
              group_child_same_no=i;
              break;
              }
            }
            if(group_child_same_no!=-1)		//To unselect if the item/group is select two times
            {
              int grouped_child_same_no=-1;
              for(int i=0; i<grouped_child_no.size(); i++)
              {
                for(int j=0; j<group_child_no.size(); j++)
                {
                  if(grouped_child_no[i]==group_child_no[j])
                  {
                    root->remove_child(group_child_region_no[j]);
                    child_num=child_num-1;
                    group_item_no=group_item_no-1;
                    if(group_item_no==0) 
                    move_var=0;
                    for(int k=j; k<group_child_no.size()-1; k++)
                    {
                    group_child_no[k]=group_child_no[k+1];
                    group_xx[k]=group_xx[k+1];
                    group_yy[k]=group_yy[k+1];
                    group_end_xx[k]=group_end_xx[k+1];
                    group_end_yy[k]=group_end_yy[k+1];
                    }
                    group_child_no.pop_back(); 
                    group_child_region_no.pop_back();
                    group_xx.pop_back();
                    group_yy.pop_back();
                    group_end_xx.pop_back();
                    group_end_yy.pop_back();
                  }
                }
              }
            }
            else
            {
              if(group_item_no==0)	//First time group select
              {
int object_num=root->find_child(item);
if(object_num!=child_num-7 && object_num!=child_num-6 && object_num!=child_num-5 && object_num!=child_num-4 && object_num!=child_num-3 && object_num!=child_num-2 && object_num!=child_num-1 && object_num!=child_num)
{

                control_points_remove();
                find_group_or_not(last_child_num,"single_if","sort_false","grp_select");
                //To check if the clicked item is in a group or not ? //code starts here
                if(n!=last_child_num) 
                {
                find_group_or_not(n,"single_if","sort_false","grp_select");		
                }
                //To check if the clicked item is in a group or not ? //code ends here
}
              }
              else	//Second time onwards group select
              {
              find_group_or_not(n,"single_if","sort_false","grp_select");
              }
            }
            last_child_num=n;			
          }
          else	//If the click item is a single item (i.e   grouping_flag==0)
          {
            int group_child_same_no=-1;
            for(int i=0; i<group_child_no.size(); i++)
            {
              if(group_child_no[i]==n)
              {
              group_child_same_no=i;
              break;
              }
            }				
            if(group_child_same_no!=-1)	//To unselect if the item/group is select two times
            {
              root->remove_child(group_child_region_no[group_child_same_no]);	
              child_num=child_num-1;
              group_item_no=group_item_no-1;
              if(group_item_no==0) 
              move_var=0;
              for(int i=group_child_same_no; i<group_child_no.size()-1; i++)
              {
              group_child_no[i]=group_child_no[i+1];
              group_xx[i]=group_xx[i+1];
              group_yy[i]=group_yy[i+1];
              group_end_xx[i]=group_end_xx[i+1];
              group_end_yy[i]=group_end_yy[i+1];
              }
              group_child_no.pop_back(); 
              group_child_region_no.pop_back();
              group_xx.pop_back();
              group_yy.pop_back();
              group_end_xx.pop_back();
              group_end_yy.pop_back();
            }
            else
            {
              if(group_item_no==0)	//First time group Select
              {
				int object_num=root->find_child(item);
				if(object_num!=child_num-7 && object_num!=child_num-6 && object_num!=child_num-5 && object_num!=child_num-4 && object_num!=child_num-3 && object_num!=child_num-2 && object_num!=child_num-1 && object_num!=child_num)
				{

                control_points_remove();
                find_group_or_not(last_child_num,"single_if","sort_false","grp_select");
                if(n!=last_child_num) 	//If the clicked child item is not the last clicked child item
                {
                  changed_item=root->get_child(n);
                  group_child_no.push_back(n);
                  xx=changed_item->property_x();
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();
                  hh=changed_item->property_height();
                  group_xx.push_back(xx);
                  group_yy.push_back(yy);
                  group_end_xx.push_back(xx+ww);
                  group_end_yy.push_back(yy+hh);
                  Glib::RefPtr<Goocanvas::Rect> rect1 ;
                  rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
                  #ifdef GLIBMM_PROPERTIES_ENABLED
                  rect1->property_stroke_color() = "red" ;
                  rect1->property_line_width() = 0.5 ;
                  #endif
                  root->add_child(rect1);
                  child_num=child_num+1;
                  group_child_region_no.push_back(child_num);
                  group_item_no=group_item_no+1; 
                }
}	
              }
              else	//Second time onwards group select
              {
                changed_item=root->get_child(n);
                group_child_no.push_back(n);
                xx=changed_item->property_x();
                yy=changed_item->property_y();
                ww=changed_item->property_width();
                hh=changed_item->property_height();
                group_xx.push_back(xx);
                group_yy.push_back(yy);
                group_end_xx.push_back(xx+ww);
                group_end_yy.push_back(yy+hh);
                Glib::RefPtr<Goocanvas::Rect> rect1 ;
                rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
                #ifdef GLIBMM_PROPERTIES_ENABLED
                rect1->property_stroke_color() = "red" ;
                rect1->property_line_width() = 0.5 ;
                #endif
                root->add_child(rect1);
                child_num=child_num+1;
                group_child_region_no.push_back(child_num);
                group_item_no=group_item_no+1;
              }
            }
            last_child_num=n;
          }
        }
      }
      else if(group_var=="" && group_item_no>0)	//If the item is clicked without shift on the item, the grouping rectangles are removed
      {
        selected_items_remove();
        if(grouping_flag==1)
        {
          Glib::RefPtr<Goocanvas::Rect> rect1 ;
          rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
          #ifdef GLIBMM_PROPERTIES_ENABLED
          rect1->property_stroke_color() = "red" ;
          rect1->property_line_width() = 0.5 ;
          #endif
          root->add_child(rect1);
          child_num=child_num+1;
          first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
          second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
          third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
          fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
          fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
          sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
          seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
          eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);
        }
        else if(grouping_flag==0)
        {
          Glib::RefPtr<Goocanvas::Rect> rect1 ;
          rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
          #ifdef GLIBMM_PROPERTIES_ENABLED
          rect1->property_stroke_color() = "red" ;
          rect1->property_line_width() = 0.5 ;
          #endif
          root->add_child(rect1);
          child_num=child_num+1;

          first(xx-16,yy-16,xx,yy);
          second(xx+ww+16,yy-16,xx+ww,yy);
          third(xx-16,yy+hh+16,xx,yy+hh);
          fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
          fifth(xx+ww/2,yy-22,xx+ww/2,yy);
          sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
          seventh(xx-22,yy+hh/2,xx,yy+hh/2);
          eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);
        }
        changed_item_num=root->find_child(item);
        last_child_num=n;
      }
      else 
      {
        if(grouping_flag==0)
        {
          if(move_var==0)
          {
            xx=xx+x;
            yy=yy+y;
            Glib::RefPtr<Goocanvas::Rect> rect1 ;
            rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
            #ifdef GLIBMM_PROPERTIES_ENABLED
            rect1->property_stroke_color() = "red" ;
            rect1->property_line_width() = 0.5 ;
            #endif
            root->add_child(rect1);
            child_num=child_num+1;
            first(xx-16,yy-16,xx,yy);
            second(xx+ww+16,yy-16,xx+ww,yy);
            third(xx-16,yy+hh+16,xx,yy+hh);
            fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
            fifth(xx+ww/2,yy-22,xx+ww/2,yy);
            sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
            seventh(xx-22,yy+hh/2,xx,yy+hh/2);
            eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);
            item->set_property("x",xx);
            item->set_property("y",yy);
            xx1=xx;      yy1=yy;
            ww1=ww;      hh1=hh;
            move_var=move_var+1;
            changed_item_num=root->find_child(item);
            last_child_num=n;
          }
          else
          {
            control_item_num=root->find_child(item);
            if(control_item_num!=child_num-7 && control_item_num!=child_num-6 && control_item_num!=child_num-5 && control_item_num!=child_num-4 && control_item_num!=child_num-3 && control_item_num!=child_num-2 && control_item_num!=child_num-1 && control_item_num!=child_num)
            {
              xx=xx+x;
              yy=yy+y;
              if(move_var>0)
              {
              control_points_remove();
              }
              Glib::RefPtr<Goocanvas::Rect> rect1 ;
              rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
              #ifdef GLIBMM_PROPERTIES_ENABLED
              rect1->property_stroke_color() = "red" ;
              rect1->property_line_width() = 0.5 ;
              #endif
              root->add_child(rect1);
              child_num=child_num+1;
              first(xx-16,yy-16,xx,yy);
              second(xx+ww+16,yy-16,xx+ww,yy);
              third(xx-16,yy+hh+16,xx,yy+hh);
              fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
              fifth(xx+ww/2,yy-22,xx+ww/2,yy);
              sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
              seventh(xx-22,yy+hh/2,xx,yy+hh/2);
              eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);
              item->set_property("x",xx);
              item->set_property("y",yy);
              xx1=xx;      yy1=yy;
              ww1=ww;      hh1=hh;
              changed_item_num=root->find_child(item);
              current_clicked_item = changed_item_num;

		if(image_status==1)
			{

			item->get_property(Glib::ustring("x"),button_dragging_x =0);
			item->get_property(Glib::ustring("y"),button_dragging_y =0);

			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=button_dragging_x-button_press_x;
			global_y_diff=button_dragging_y-button_press_y;
			button_press_x = button_dragging_x;
			button_press_y = button_dragging_y;

		
			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";

			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


			if((global_y_diff!=0)||(global_x_diff!=0))
			{
				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;
				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

				PyObject *main = PyImport_AddModule("__main__"); // borrowed
				/*if (main == NULL)
					//error();
				return 0;*/
				PyObject *globals = PyModule_GetDict(main); // borrowed
				PyObject *py_data = PyString_FromString(open_global_python_data1);
				/*if (py_data == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata", py_data) ;
				//return 0;
				   //error();
				Py_DECREF(py_data);

				PyObject *py_data1 = PyString_FromString(dis_x_str1);
				/*if (py_data1 == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata1", py_data1);
				//return 0;*/
				   //error();
				Py_DECREF(py_data1);


				PyObject *py_data2 = PyString_FromString(dis_y_str1);
				/*if (py_data2 == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata2", py_data2);
				//return 0;
				   //error();
				Py_DECREF(py_data2);


								PyRun_SimpleString("import ast\n"
							"from shapely.geometry import Polygon, MultiPolygon\n"
							"from shapely.geometry import *\n"
							"from shapely.ops import cascaded_union\n"
							"Multipo = pythondata\n"
							"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
							"Multipo = Multipo.replace(')))','))')\n"
							"Multipo = Multipo.replace(', ((','split[(')\n"
							"Multipo = Multipo.replace('))',')]')\n"
							"Multipo = Multipo.replace('), (',')],[(')\n"
							"Multipo = Multipo.replace(', ','),(')\n"
							"Multipo = Multipo.replace(' ',',')\n"
							"Multipo = Multipo.split('split')\n"
							"s = []\n"
							"for i in Multipo:\n"
							"	a = i.split('],[')\n"
							"	if len(a) >=2:\n"
							"		i = i.replace('],[','],[[',1)\n"
							"		i = '[' + i + ']]'\n"
							"		i = ast.literal_eval(i)\n"
							"		m = []\n"
							"		n = []\n"
							"		o = []\n"
							"		for j in i[0]:\n"
							"			k = j[0]+float(pythondata1)\n"
							"			l = j[1]+float(pythondata2)\n"
							"			m.append((k,l))\n"
							"		for a in i[1]:\n"
							"			for b in a:\n"
							"				k = b[0]+float(pythondata1)\n"
							"				l = b[1]+float(pythondata2)\n"
							"				o.append((k,l))\n"
							"			n.append(o)\n"
							"		s.append(Polygon(m,n).buffer(0))\n"
							"	else:\n"
							"		i = ast.literal_eval(i)\n"
							"		m = []\n"
							"		for j in i:\n"
							"			k = j[0]+float(pythondata1)\n"
							"			l = j[1]+float(pythondata2)\n"
							"			m.append((k,l))\n"
							"		s.append(Polygon(m).buffer(0))\n"
							"C = cascaded_union(s)\n"
							"C1 = str(C)\n");


			PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
			PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
			PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
			string changed_val = PyString_AsString(eraserera);

			open_global_python_data = changed_val;
			}
			}

			Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(control_item_num);
			imgg->set_property("clip_path", Glib::ustring(open_global_data));
			}			

              last_child_num=n;
            }
            else
            { 
              ctr_pt_press=1;
              find_group_or_not(changed_item_num,"double_if","sort_false","but_release");
              changed_item=root->get_child(changed_item_num);
			  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[changed_item_num-1]+" </Scene> </Kalanjiyam>";
			  const std::string input_xml = test;
			  vector<char> xml_copy(input_xml.begin(), input_xml.end());
			  xml_copy.push_back('\0');
			  xml_document<> doc;
			  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
			  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
			  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
			  xml_node<> * abc; 
			  int before_paste_total_child_num=child_num;
			  while (Scene != NULL )
			  {
				for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
				{
				  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
				  {
					  const char * node_name = abc->name();
					  const char * node_value = abc->value();		
					  open_node_name = node_name;
					  open_node_value = node_value;
					  const char * attribute_name = attribute->name();	
					  const char * attribute_value = attribute->value();	
					  if (strcmp(node_name, "Text") == 0)
					  {
						text_status=1;
					  }
				  }
				}
				Scene = Scene->next_sibling("Scene");	
			  } 

              control_item_num=root->find_child(item);
              if(control_item_num==child_num-7)		// Control Point Number 1
              { 
                if(global_group_status==-1 && text_status!=1)
                {
int resize_path=0;
find_child_item=root->find_child(changed_item);
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
          {
			resize_path=1;
          }
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

double path_diff_x = path_old_x - last_motion_x;
double path_diff_y = path_old_y - last_motion_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition+open_global_width;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition+open_global_height;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;
int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}
Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value=i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];

if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
//
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=path_old_x - last_motion_x;
y=path_old_y - last_motion_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(-xx+grp_xx))+x;
open_global_yposition=yy+((y/grp_hh)*(-yy+grp_yy))+y;
open_global_width = ww-((x/grp_ww)*ww);
open_global_height = hh-((y/grp_hh)*hh);

double path_diff_x = path_old_x - last_motion_x;
double path_diff_y = path_old_y - last_motion_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx+grp_ww;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy+grp_hh;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
//
z_count=0; 
while( getline(stream, strvalue1, ' ') )
{
  if(strvalue1=="z" || strvalue1=="Z")
  {
	z_count++;
	first_vector_for_eraser.push_back("z");
  }
  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
  {
	if(i==0)
	{
	  strvalue2=strvalue1;
	  i++;
	}
	else
	{
	  strvalue2=strvalue2+","+strvalue1;
	  first_vector_for_eraser.push_back(strvalue2);
	  i=0;
	}
  }
}

if(z_count<2)
{
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(i==0)
		my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
		else if(i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]";
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
else if(z_count>=2)
{
	int z_cnt=1, j=0;
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(j==0)
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
			j++;
		}
		else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], [";
			j=0; z_cnt++;
		}
		else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]]";
		else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], ";
			j=0; z_cnt++;
		}
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
//
}
//
Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

//
if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
//
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
//
}
//

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

//
if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
//
string first_value = erase_value.substr(0,1);
if(first_value=="M")
{
boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
boost::replace_all(erase_value, "((", "(");
boost::replace_all(erase_value, "))", ")");
}

string token, mystring(erase_value), mystring1;
int loop_cnt=1;
while(token != mystring)
{
  token = mystring.substr(0,mystring.find_first_of(")"));
  mystring = mystring.substr(mystring.find_first_of(")") + 1);
  if(mystring.size()==0)
  break;
  if(loop_cnt==1)
  mystring1 = token.substr(10,token.size()-10);
  else
  mystring1 = token.substr(3,token.size()-3);

  second_vector_for_eraser.push_back(mystring1);

  loop_cnt++;

}
open_global_data="";
for(int i=0; i<second_vector_for_eraser.size(); i++)
{ 
  open_global_data=open_global_data+"M ";
  string old_data = second_vector_for_eraser[i];
  string tok, mystr(old_data);
  int loop_count=1;
  while(tok != mystr)
  {
    tok = mystr.substr(0,mystr.find_first_of(","));
    mystr = mystr.substr(mystr.find_first_of(",") + 1);
    if(loop_count==1)
    {
  	  open_global_data=open_global_data+tok;
    }
    else
    {
      open_global_data=open_global_data+" L"+tok;
    }
    loop_count++;
  }
  open_global_data=open_global_data+" z ";
}
//
}
//

edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(-xx+grp_xx))+x;
open_global_yposition=yy+((y/grp_hh)*(-yy+grp_yy))+y;
open_global_width = ww-((x/grp_ww)*ww);
open_global_height = hh-((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

	open_node_name_line_string="2";
    line_check=0;
	open_global_python_data="";
	open_node_name_line = "";

}
}


                }
              }
              else if(control_item_num==child_num-6) // Control Point Number 2
              { 
                if(global_group_status==-1 && text_status!=1)
                {

int resize_path=0;
find_child_item=root->find_child(changed_item);
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
          {
			resize_path=1;
          }
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = path_old_y - last_motion_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition+open_global_height;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);


if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{

			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;


if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}

edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value = i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
//
//
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=last_motion_x - path_old_x;
y=path_old_y - last_motion_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(-yy+grp_yy))+y;
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh-((y/grp_hh)*hh);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = path_old_y - last_motion_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy+grp_hh;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
//
z_count=0; 
while( getline(stream, strvalue1, ' ') )
{
  if(strvalue1=="z" || strvalue1=="Z")
  {
	z_count++;
	first_vector_for_eraser.push_back("z");
  }
  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
  {
	if(i==0)
	{
	  strvalue2=strvalue1;
	  i++;
	}
	else
	{
	  strvalue2=strvalue2+","+strvalue1;
	  first_vector_for_eraser.push_back(strvalue2);
	  i=0;
	}
  }
}

if(z_count<2)
{
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(i==0)
		my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
		else if(i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]";
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
else if(z_count>=2)
{
	int z_cnt=1, j=0;
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(j==0)
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
			j++;
		}
		else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], [";
			j=0; z_cnt++;
		}
		else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]]";
		else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], ";
			j=0; z_cnt++;
		}
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
//
}
//
Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
string first_value = erase_value.substr(0,1);
if(first_value=="M")
{
boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
boost::replace_all(erase_value, "((", "(");
boost::replace_all(erase_value, "))", ")");
}

string token, mystring(erase_value), mystring1;
int loop_cnt=1;
while(token != mystring)
{
  token = mystring.substr(0,mystring.find_first_of(")"));
  mystring = mystring.substr(mystring.find_first_of(")") + 1);
  if(mystring.size()==0)
  break;
  if(loop_cnt==1)
  mystring1 = token.substr(10,token.size()-10);
  else
  mystring1 = token.substr(3,token.size()-3);

  second_vector_for_eraser.push_back(mystring1);

  loop_cnt++;

}
open_global_data="";
for(int i=0; i<second_vector_for_eraser.size(); i++)
{ 
  open_global_data=open_global_data+"M ";
  string old_data = second_vector_for_eraser[i];
  string tok, mystr(old_data);
  int loop_count=1;
  while(tok != mystr)
  {
    tok = mystr.substr(0,mystr.find_first_of(","));
    mystr = mystr.substr(mystr.find_first_of(",") + 1);
    if(loop_count==1)
    {
  	  open_global_data=open_global_data+tok;
    }
    else
    {
      open_global_data=open_global_data+" L"+tok;
    }
    loop_count++;
  }
  open_global_data=open_global_data+" z ";
}
}
edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(-yy+grp_yy))+y;
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh-((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;
//
	open_node_name_line_string="2";
    line_check=0;
	open_global_python_data="";
	open_node_name_line = "";
//

}
}
//
                }
              }
              else if(control_item_num==child_num-5) // Control Point Number 3
              { 
                if(global_group_status==-1 && text_status!=1)
                {

int resize_path=0;
find_child_item=root->find_child(changed_item);	
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

double path_diff_x = path_old_x - last_motion_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition+open_global_width;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value = i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];	
//
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
//
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=path_old_x - last_motion_x;
y=last_motion_y - path_old_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(-xx+grp_xx))+x;
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww-((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);

double path_diff_x = path_old_x - last_motion_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx+grp_ww;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
//
z_count=0; 
while( getline(stream, strvalue1, ' ') )
{
  if(strvalue1=="z" || strvalue1=="Z")
  {
	z_count++;
	first_vector_for_eraser.push_back("z");
  }
  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
  {
	if(i==0)
	{
	  strvalue2=strvalue1;
	  i++;
	}
	else
	{
	  strvalue2=strvalue2+","+strvalue1;
	  first_vector_for_eraser.push_back(strvalue2);
	  i=0;
	}
  }
}

if(z_count<2)
{
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(i==0)
		my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
		else if(i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]";
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
else if(z_count>=2)
{
	int z_cnt=1, j=0;
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(j==0)
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
			j++;
		}
		else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], [";
			j=0; z_cnt++;
		}
		else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]]";
		else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], ";
			j=0; z_cnt++;
		}
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;


if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
string first_value = erase_value.substr(0,1);
if(first_value=="M")
{
boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
boost::replace_all(erase_value, "((", "(");
boost::replace_all(erase_value, "))", ")");
}

string token, mystring(erase_value), mystring1;
int loop_cnt=1;
while(token != mystring)
{
  token = mystring.substr(0,mystring.find_first_of(")"));
  mystring = mystring.substr(mystring.find_first_of(")") + 1);
  if(mystring.size()==0)
  break;
  if(loop_cnt==1)
  mystring1 = token.substr(10,token.size()-10);
  else
  mystring1 = token.substr(3,token.size()-3);

  second_vector_for_eraser.push_back(mystring1);

  loop_cnt++;

}
open_global_data="";
for(int i=0; i<second_vector_for_eraser.size(); i++)
{ 
  open_global_data=open_global_data+"M ";
  string old_data = second_vector_for_eraser[i];
  string tok, mystr(old_data);
  int loop_count=1;
  while(tok != mystr)
  {
    tok = mystr.substr(0,mystr.find_first_of(","));
    mystr = mystr.substr(mystr.find_first_of(",") + 1);
    if(loop_count==1)
    {
  	  open_global_data=open_global_data+tok;
    }
    else
    {
      open_global_data=open_global_data+" L"+tok;
    }
    loop_count++;
  }
  open_global_data=open_global_data+" z ";
}
}
edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(-xx+grp_xx))+x;
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww-((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;
//
	open_node_name_line_string="2";
    line_check=0;
	open_global_python_data="";
	open_node_name_line = "";
//
}
}
                }
              }
              else if(control_item_num==child_num-4) // Control Point Number 4
              {
                if(global_group_status==-1 && text_status!=1)
                {
int resize_path=0;
find_child_item=root->find_child(changed_item);	
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();
eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value=i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];

if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=last_motion_x - path_old_x;
y=last_motion_y - path_old_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";
}
}
                }
              }
              else if(control_item_num==child_num-3) // Control Point Number 5
              { 
                if(global_group_status==-1 && text_status!=1)
                {
int resize_path=0;
find_child_item=root->find_child(changed_item);	
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = path_old_y - last_motion_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition+(open_global_width/2);
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition+open_global_height;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
//
//
for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value = i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];	
//
//
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=last_motion_x - path_old_x;
y=path_old_y - last_motion_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(-yy+grp_yy))+y;
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh-((y/grp_hh)*hh);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = path_old_y - last_motion_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx+(grp_ww/2);
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy+grp_hh;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
//
z_count=0; 
while( getline(stream, strvalue1, ' ') )
{
  if(strvalue1=="z" || strvalue1=="Z")
  {
	z_count++;
	first_vector_for_eraser.push_back("z");
  }
  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
  {
	if(i==0)
	{
	  strvalue2=strvalue1;
	  i++;
	}
	else
	{
	  strvalue2=strvalue2+","+strvalue1;
	  first_vector_for_eraser.push_back(strvalue2);
	  i=0;
	}
  }
}

if(z_count<2)
{
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(i==0)
		my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
		else if(i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]";
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
else if(z_count>=2)
{
	int z_cnt=1, j=0;
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(j==0)
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
			j++;
		}
		else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], [";
			j=0; z_cnt++;
		}
		else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]]";
		else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], ";
			j=0; z_cnt++;
		}
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
string first_value = erase_value.substr(0,1);
if(first_value=="M")
{
boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
boost::replace_all(erase_value, "((", "(");
boost::replace_all(erase_value, "))", ")");
}

string token, mystring(erase_value), mystring1;
int loop_cnt=1;
while(token != mystring)
{
  token = mystring.substr(0,mystring.find_first_of(")"));
  mystring = mystring.substr(mystring.find_first_of(")") + 1);
  if(mystring.size()==0)
  break;
  if(loop_cnt==1)
  mystring1 = token.substr(10,token.size()-10);
  else
  mystring1 = token.substr(3,token.size()-3);

  second_vector_for_eraser.push_back(mystring1);

  loop_cnt++;

}
open_global_data="";
for(int i=0; i<second_vector_for_eraser.size(); i++)
{ 
  open_global_data=open_global_data+"M ";
  string old_data = second_vector_for_eraser[i];
  string tok, mystr(old_data);
  int loop_count=1;
  while(tok != mystr)
  {
    tok = mystr.substr(0,mystr.find_first_of(","));
    mystr = mystr.substr(mystr.find_first_of(",") + 1);
    if(loop_count==1)
    {
  	  open_global_data=open_global_data+tok;
    }
    else
    {
      open_global_data=open_global_data+" L"+tok;
    }
    loop_count++;
  }
  open_global_data=open_global_data+" z ";
}
}
edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(-yy+grp_yy))+y;
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh-((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;
//
	open_node_name_line_string="2";
    line_check=0;
	open_global_python_data="";
	open_node_name_line = "";
//
}
}
                }
              }
              else if(control_item_num==child_num-2) // Control Point Number 6
              { 
                if(global_group_status==-1 && text_status!=1)
                {
int resize_path=0;
find_child_item=root->find_child(changed_item);
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition+(open_global_width/2);
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
//
//
for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value = i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];	
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
//
//
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=last_motion_x - path_old_x;
y=last_motion_y - path_old_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx+(grp_ww/2);
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy;
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
//
z_count=0; 
while( getline(stream, strvalue1, ' ') )
{
  if(strvalue1=="z" || strvalue1=="Z")
  {
	z_count++;
	first_vector_for_eraser.push_back("z");
  }
  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
  {
	if(i==0)
	{
	  strvalue2=strvalue1;
	  i++;
	}
	else
	{
	  strvalue2=strvalue2+","+strvalue1;
	  first_vector_for_eraser.push_back(strvalue2);
	  i=0;
	}
  }
}

if(z_count<2)
{
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(i==0)
		my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
		else if(i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]";
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
else if(z_count>=2)
{
	int z_cnt=1, j=0;
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(j==0)
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
			j++;
		}
		else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], [";
			j=0; z_cnt++;
		}
		else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]]";
		else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], ";
			j=0; z_cnt++;
		}
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
string first_value = erase_value.substr(0,1);
if(first_value=="M")
{
boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
boost::replace_all(erase_value, "((", "(");
boost::replace_all(erase_value, "))", ")");
}

string token, mystring(erase_value), mystring1;
int loop_cnt=1;
while(token != mystring)
{
  token = mystring.substr(0,mystring.find_first_of(")"));
  mystring = mystring.substr(mystring.find_first_of(")") + 1);
  if(mystring.size()==0)
  break;
  if(loop_cnt==1)
  mystring1 = token.substr(10,token.size()-10);
  else
  mystring1 = token.substr(3,token.size()-3);

  second_vector_for_eraser.push_back(mystring1);

  loop_cnt++;

}
open_global_data="";
for(int i=0; i<second_vector_for_eraser.size(); i++)
{ 
  open_global_data=open_global_data+"M ";
  string old_data = second_vector_for_eraser[i];
  string tok, mystr(old_data);
  int loop_count=1;
  while(tok != mystr)
  {
    tok = mystr.substr(0,mystr.find_first_of(","));
    mystr = mystr.substr(mystr.find_first_of(",") + 1);
    if(loop_count==1)
    {
  	  open_global_data=open_global_data+tok;
    }
    else
    {
      open_global_data=open_global_data+" L"+tok;
    }
    loop_count++;
  }
  open_global_data=open_global_data+" z ";
}
}
edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;
//
	open_node_name_line_string="2";
    line_check=0;
	open_global_python_data="";
	open_node_name_line = "";
//
}
}
                }
              }
              else if(control_item_num==child_num-1) // Control Point Number 7
              { 
                if(global_group_status==-1 && text_status!=1)
                {
int resize_path=0;
find_child_item=root->find_child(changed_item);	
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

double path_diff_x = path_old_x - last_motion_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition+open_global_width;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition+(open_global_height/2);
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
//
//
for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value = i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];	
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=path_old_x - last_motion_x;
y=last_motion_y - path_old_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(-xx+grp_xx))+x;
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww-((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);

double path_diff_x = path_old_x - last_motion_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx+grp_ww;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy+(grp_hh/2);
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;


int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
//
z_count=0; 
while( getline(stream, strvalue1, ' ') )
{
  if(strvalue1=="z" || strvalue1=="Z")
  {
	z_count++;
	first_vector_for_eraser.push_back("z");
  }
  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
  {
	if(i==0)
	{
	  strvalue2=strvalue1;
	  i++;
	}
	else
	{
	  strvalue2=strvalue2+","+strvalue1;
	  first_vector_for_eraser.push_back(strvalue2);
	  i=0;
	}
  }
}

if(z_count<2)
{
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(i==0)
		my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
		else if(i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]";
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
else if(z_count>=2)
{
	int z_cnt=1, j=0;
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(j==0)
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
			j++;
		}
		else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], [";
			j=0; z_cnt++;
		}
		else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]]";
		else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], ";
			j=0; z_cnt++;
		}
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
}
Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
string first_value = erase_value.substr(0,1);
if(first_value=="M")
{
boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
boost::replace_all(erase_value, "((", "(");
boost::replace_all(erase_value, "))", ")");
}

string token, mystring(erase_value), mystring1;
int loop_cnt=1;
while(token != mystring)
{
  token = mystring.substr(0,mystring.find_first_of(")"));
  mystring = mystring.substr(mystring.find_first_of(")") + 1);
  if(mystring.size()==0)
  break;
  if(loop_cnt==1)
  mystring1 = token.substr(10,token.size()-10);
  else
  mystring1 = token.substr(3,token.size()-3);

  second_vector_for_eraser.push_back(mystring1);

  loop_cnt++;

}
open_global_data="";
for(int i=0; i<second_vector_for_eraser.size(); i++)
{ 
  open_global_data=open_global_data+"M ";
  string old_data = second_vector_for_eraser[i];
  string tok, mystr(old_data);
  int loop_count=1;
  while(tok != mystr)
  {
    tok = mystr.substr(0,mystr.find_first_of(","));
    mystr = mystr.substr(mystr.find_first_of(",") + 1);
    if(loop_count==1)
    {
  	  open_global_data=open_global_data+tok;
    }
    else
    {
      open_global_data=open_global_data+" L"+tok;
    }
    loop_count++;
  }
  open_global_data=open_global_data+" z ";
}
}
edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(-xx+grp_xx))+x;
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww-((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;
//
	open_node_name_line_string="2";
    line_check=0;
	open_global_python_data="";
	open_node_name_line = "";
//
}
}
                }
              }
              else if(control_item_num==child_num)  // Control Point Number 8
              {
                if(global_group_status==-1 && text_status!=1)
                {
int resize_path=0;
find_child_item=root->find_child(changed_item);
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
if(resize_path==1) 
{
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}

std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = (path_diff_x+open_global_width)/open_global_width;
double y_fact = (path_diff_y+open_global_height)/open_global_height;
std::ostringstream os;
os << open_global_xposition;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << open_global_yposition+(open_global_height/2);
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}
}
edit_flag=1;
action_status=1;
if(group_select==1)
{
changed_item->set_property("line_width", open_global_new_linewidth);
open_global_linewidth=open_global_new_linewidth;
create_xml_for_path(erased_value);
}
action_status=0;
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;

open_node_name_line_string="2";
line_check=0;
open_global_python_data="";
open_node_name_line = "";

if(group_select==1)
{
undo_redo_tag_vector.push_back(str_val1);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
standing_position=undo_redo_tag_vector.size()-1;
group_select=0;
}
                }
                else
                {
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
std::string str_val="GroupPropertyStarts";
std::string str_val1="GroupPropertyEnds";
int status=5;
int position=-1;
group_select=1;
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
//
//
for(int i=0; i<eraser_grouped_child_no.size(); i++)
{
int loop_count_value = i;
int resize_path=0;
find_child_item=eraser_grouped_child_no[i];	
if(find_child_item<=xml_scene_overall_tag.size()+1)
{
  std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[find_child_item-1]+" </Scene> </Kalanjiyam>";
  const std::string input_xml = test;
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc; 
  int before_paste_total_child_num=child_num;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          if (strcmp(node_name, "Path") == 0)
			resize_path=1;
		  if (strcmp(attribute_name, "data") == 0)
			open_global_data = attribute_value;
		  if (strcmp(attribute_name, "py_data") == 0)
			open_global_python_data = attribute_value;
		  if (strcmp(attribute_name, "strokecolor") == 0)
			open_global_strokecolor_hex = attribute_value;
		  if (strcmp(attribute_name, "fillcolor") == 0)
			open_global_fillcolor_hex = attribute_value;
		  if (strcmp(attribute_name, "linewidth") == 0)
			open_global_linewidth = atof(attribute_value);
		  if (strcmp(attribute_name, "xposition") == 0)
			open_global_xposition = atof(attribute_value);
		  if (strcmp(attribute_name, "yposition") == 0)
			open_global_yposition = atof(attribute_value);
		  if (strcmp(attribute_name, "width") == 0)
			open_global_width = atof(attribute_value);
		  if (strcmp(attribute_name, "height") == 0)
			open_global_height = atof(attribute_value);
      }
    }
    Scene = Scene->next_sibling("Scene");	
  } 
}
//
//
if(resize_path==1) 
{
changed_item=root->get_child(find_child_item);
x=last_motion_x - path_old_x;
y=last_motion_y - path_old_y;

open_global_xposition = grp_xx;	 
open_global_yposition = grp_yy;

xx=changed_item->property_x();	 
yy=changed_item->property_y();
ww=changed_item->property_width();	 
hh=changed_item->property_height();

open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);

double path_diff_x = last_motion_x - path_old_x;
double path_diff_y = last_motion_y - path_old_y;
double x_fact = grp_ww/(grp_ww-path_diff_x);
double y_fact = grp_hh/(grp_hh-path_diff_y);

std::ostringstream os;
os << grp_xx;
std::string str1 = os.str();
Glib::locale_from_utf8(str1);
const char *x_val1 = str1.c_str();
std::ostringstream os1;
os1 << grp_yy+(grp_hh/2);
std::string str2 = os1.str();
Glib::locale_from_utf8(str2);
const char *y_val1 = str2.c_str();
std::ostringstream os2;
os2 << x_fact;
std::string str3 = os2.str();
Glib::locale_from_utf8(str3);
const char *x_fact1 = str3.c_str();
std::ostringstream os3;
os3 << y_fact;
std::string str4 = os3.str();
Glib::locale_from_utf8(str4);
const char *y_fact1 = str4.c_str();

eraser_status = 1;
find_child_item=root->find_child(changed_item);
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_linewidth);
get_property(changed_item , find_child_item);
action_status=0;	//Get Property starts
eraser_status=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
stringstream stream(my_str1_tag);
int i=0;

int line_check=0;
//
if(open_node_name_line=="Line")
{
	open_node_name_line_string="1";
	open_node_name_line="open1";
	line_check=1;
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="m" || strvalue1=="M")
	  {
		m_count++;
		first_vector_for_eraser.push_back("M");
	  }
	  else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}
	if(m_count==1)
	{
		for(int i=0; i<first_vector_for_eraser.size();i++)
		{
			if(i==0)
			{
			my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
			i = i+1;
			}
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
    else if(m_count>=1)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			{
				my_str1_tag_modified3="[(";
			}
			else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"), (";
			}
			else if(i==first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
			else if(first_vector_for_eraser[i+1]=="M")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
			}
			else if (i!=first_vector_for_eraser.size()-1) 
			my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
		}
	}
}
else
{
//
z_count=0; 
while( getline(stream, strvalue1, ' ') )
{
  if(strvalue1=="z" || strvalue1=="Z")
  {
	z_count++;
	first_vector_for_eraser.push_back("z");
  }
  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
  {
	if(i==0)
	{
	  strvalue2=strvalue1;
	  i++;
	}
	else
	{
	  strvalue2=strvalue2+","+strvalue1;
	  first_vector_for_eraser.push_back(strvalue2);
	  i=0;
	}
  }
}

if(z_count<2)
{
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(i==0)
		my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
		else if(i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]";
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
else if(z_count>=2)
{
	int z_cnt=1, j=0;
	for(int i=0; i<first_vector_for_eraser.size(); i++)
	{
		if(j==0)
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
			j++;
		}
		else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], [";
			j=0; z_cnt++;
		}
		else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
		my_str1_tag_modified3=my_str1_tag_modified3+"]]";
		else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
		{
			my_str1_tag_modified3=my_str1_tag_modified3+"], ";
			j=0; z_cnt++;
		}
		else
		my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
	}
}
}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);

if(open_node_name_line_string=="1")
{
	PyRun_SimpleString("import ast\n"
"from shapely.geometry import LineString, MultiLineString\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"a= ast.literal_eval(n)\n"
"A = MultiLineString(a)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}
else
{
			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");
}

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;

if(line_check==1)
{
	string erase_value_mod1=erase_value;
	string erase_value_for_line_check=erase_value_mod1.substr(0,10);
	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(18,token.size()-18);
	  else
	  mystring1 = token.substr(3,token.size()-3);
	  second_vector_for_eraser.push_back(mystring1);
	  loop_cnt++;
	}
	open_global_data="";
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  if(i==0)
	  open_global_data=open_global_data+"M ";	
	  else
	  open_global_data=open_global_data+" M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	}
}
else
{
string first_value = erase_value.substr(0,1);
if(first_value=="M")
{
boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
boost::replace_all(erase_value, "((", "(");
boost::replace_all(erase_value, "))", ")");
}

string token, mystring(erase_value), mystring1;
int loop_cnt=1;
while(token != mystring)
{
  token = mystring.substr(0,mystring.find_first_of(")"));
  mystring = mystring.substr(mystring.find_first_of(")") + 1);
  if(mystring.size()==0)
  break;
  if(loop_cnt==1)
  mystring1 = token.substr(10,token.size()-10);
  else
  mystring1 = token.substr(3,token.size()-3);

  second_vector_for_eraser.push_back(mystring1);

  loop_cnt++;

}
open_global_data="";
for(int i=0; i<second_vector_for_eraser.size(); i++)
{ 
  open_global_data=open_global_data+"M ";
  string old_data = second_vector_for_eraser[i];
  string tok, mystr(old_data);
  int loop_count=1;
  while(tok != mystr)
  {
    tok = mystr.substr(0,mystr.find_first_of(","));
    mystr = mystr.substr(mystr.find_first_of(",") + 1);
    if(loop_count==1)
    {
  	  open_global_data=open_global_data+tok;
    }
    else
    {
      open_global_data=open_global_data+" L"+tok;
    }
    loop_count++;
  }
  open_global_data=open_global_data+" z ";
}
}
edit_flag=1;
open_global_xposition=xx+((x/grp_ww)*(xx-grp_xx));
open_global_yposition=yy+((y/grp_hh)*(yy-grp_yy));
open_global_width = ww+((x/grp_ww)*ww);
open_global_height = hh+((y/grp_hh)*hh);
if(group_select==1)
{
action_status=1;	//Get Property starts
changed_item->set_property("line_width", open_global_new_linewidth_vector[loop_count_value]);
open_global_linewidth=open_global_new_linewidth_vector[loop_count_value];
create_xml_for_path(erased_value);
action_status=0;	//Get Property ends
}
edit_flag=0;
first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
resize_path=0;
//
	open_node_name_line_string="2";
    line_check=0;
	open_global_python_data="";
	open_node_name_line = "";
//
}
}
                }
              }
            }
          }
        }
        if(grouping_flag==1)
        {
          if(move_var==0)
          {
            grp_xx=grp_xx+x;
            grp_yy=grp_yy+y;
            Glib::RefPtr<Goocanvas::Rect> rect1 ;
            rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
            #ifdef GLIBMM_PROPERTIES_ENABLED
            rect1->property_stroke_color() = "red" ;
            rect1->property_line_width() = 0.5 ;
            #endif
            root->add_child(rect1);
            child_num=child_num+1;
            first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
            second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
            third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
            fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
            fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
            sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
            seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
            eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);
            for(int i=0; i<grouped_child_no.size(); i++)
            {
              int n=grouped_child_no[i];
              changed_item=root->get_child(n);
              xx=changed_item->property_x();	 
              yy=changed_item->property_y();
              xx=xx+x;
              yy=yy+y;
              changed_item->set_property("x",xx);
              changed_item->set_property("y",yy);

            }
            xx1=grp_xx;      yy1=grp_yy;
            ww1=grp_ww;      hh1=grp_hh;
            move_var=move_var+1;
            changed_item_num=root->find_child(item);
            last_child_num=n;
          }
          else
          {
            control_item_num=root->find_child(item);
            if(control_item_num!=child_num-7 && control_item_num!=child_num-6 && control_item_num!=child_num-5 && control_item_num!=child_num-4 && control_item_num!=child_num-3 && control_item_num!=child_num-2 && control_item_num!=child_num-1 && control_item_num!=child_num)
            {
              grp_xx=grp_xx+x;
              grp_yy=grp_yy+y;
              if(move_var>0)
              {
              control_points_remove();
              }
              Glib::RefPtr<Goocanvas::Rect> rect1 ;
              rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
              #ifdef GLIBMM_PROPERTIES_ENABLED
              rect1->property_stroke_color() = "red" ;
              rect1->property_line_width() = 0.5 ;
              #endif
              root->add_child(rect1);
              child_num=child_num+1;
              first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
              second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
              third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
              fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
              fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
              sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
              seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
              eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);
              for(int i=0; i<grouped_child_no.size(); i++)
              {
                int n=grouped_child_no[i];
                changed_item=root->get_child(n);
                xx=changed_item->property_x();	 
                yy=changed_item->property_y();
                xx=xx+x;
                yy=yy+y;

	  global_x_diff = x;
	  global_y_diff = y;

                changed_item->set_property("x",xx);
                changed_item->set_property("y",yy);

// RELEASE 				

/*CHECK IMAGE IN THE GROUP*/

	 			  			for(int g1=0;g1<for_group_image_move.size();g1++)	
							{
								  std::string store_value = for_group_image_move[g1];
								  std::string item_check= for_group_image_move[g1];
								 tokenizer<> tok(item_check);
								 int count=1;
								 Glib::ustring item_no;
								 std::string delimiter = "@";
								 size_t pos = 0;
								 std::string token;
								 while ((pos =store_value.find(delimiter)) != std::string::npos) 
								 {
									token =  store_value .substr(0, pos);
									store_value.erase(0, pos + delimiter.length());
								 }

								 int  item_no_int = boost::lexical_cast<int>(token);
								open_global_data=store_value;


//								open_python=store_value;
								if(item_no_int==grouped_child_no[i])
								{
								

								  for_image_group_move1(item_no_int);
								  for_group_image_move.at(g1) = token + "@" + open_global_data;

								}
							}
						 

				//	}
				/*GET IMAGE DATAT */
	
				//}
			/*CHECK IMAGE IN THE GROUP   GROUP MOVE */

              }
              xx1=grp_xx;      
              yy1=grp_yy;
              ww1=grp_ww;      
              hh1=grp_hh;
              changed_item_num=root->find_child(item);
              current_clicked_item = changed_item_num;
              last_child_num=n;
            }
          }
        }
      }
      _dragging.clear();

      //If the child is in group, should pop all values at each release event //code starts here
	  eraser_grouped_child_no.clear();
	  eraser_grouped_child_no=grouped_child_no;
      int child_no_size=grouped_child_no.size();
      for(int i=0; i<child_no_size; i++)
      {
      grouped_child_no.pop_back();
      group_xx.pop_back();
      group_yy.pop_back();
      group_end_xx.pop_back();
      group_end_yy.pop_back();
      }

      if(group_var=="")
      {
        control_points_remove();
        move_var=0;
        to_png();
        if(global_group_status!=-1)
        {
          grp_xx=grp_xx;
          grp_yy=grp_yy;
          Glib::RefPtr<Goocanvas::Rect> rect1 ;
          rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
          #ifdef GLIBMM_PROPERTIES_ENABLED
          rect1->property_stroke_color() = "red" ;
          rect1->property_line_width() = 0.5 ;
          #endif
          root->add_child(rect1);
          child_num=child_num+1;
          first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
          second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
          third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
          fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
          fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
          sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
          seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
          eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);
          move_var=1;
        }
        else if(global_group_status==-1)
        {
Glib::RefPtr<Goocanvas::Item> itm_name = root->get_child(changed_item_num);
xx=itm_name->property_x();	 
yy=itm_name->property_y();
ww=itm_name->property_width();	 
hh=itm_name->property_height();
          xx=xx+x;
          yy=yy+y;
if(text_status==1)
{
Goocanvas::Bounds bo;
Glib::RefPtr<Goocanvas::Item> c_item = root->get_child(changed_item_num);
bo=c_item->get_bounds();
double s1=bo.get_x1();
double s2=bo.get_x2();
double s3=bo.get_y1();
double s4=bo.get_y2();
xx=s1; yy=s3;
ww=s2-s1;
hh=s4-s3;
}
          Glib::RefPtr<Goocanvas::Rect> rect1 ;
          rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
          #ifdef GLIBMM_PROPERTIES_ENABLED
          rect1->property_stroke_color() = "red" ;
          rect1->property_line_width() = 0.5 ;
          #endif
          root->add_child(rect1);
          child_num=child_num+1;
          first(xx-16,yy-16,xx,yy);
          second(xx+ww+16,yy-16,xx+ww,yy);
          third(xx-16,yy+hh+16,xx,yy+hh);
          fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
          fifth(xx+ww/2,yy-22,xx+ww/2,yy);
          sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
          seventh(xx-22,yy+hh/2,xx,yy+hh/2);
          eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);
		  xx1=xx; yy1=yy; ww1=ww; hh1=hh;
          move_var=1;
        }
      }
    }
    item_pos = root->find_child(item);
    if(item_pos>=2)
    {
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==item_pos)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no==-1)
      {
      get_property(item,item_pos);
      }
      else
      {
	    std::string str_val="GroupPropertyStarts";
	    std::string str_val1="GroupPropertyEnds";
	    int status=5;
	    int position=-1;
		group_select=1;
		int new_standing_position=standing_position+1;
		int new_standing_position1=undo_redo_tag_vector.size();
		undo_redo_tag_vector.push_back(str_val);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;

            for(int i=0; i<group_child_total_list.size(); i++)
            {
              if(i==child_in_total_list)
              {
                tokenizer<> tok(group_child_total_list[i]);
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
                  Glib::RefPtr<Goocanvas::Item> get_item = root->get_child(child_in_total_list1);
				  action_status=1;	//Get Property starts
				  my_item = get_item;
				  item_pos = child_in_total_list1;
				  current_clicked_item= child_in_total_list1;

				/*CODE UPDATE*/
				  image_status=0;
				  for(int g1=0;g1<for_group_image_move.size();g1++)	
				  {
					  std::string store_value = for_group_image_move[g1];
					  std::string item_check= for_group_image_move[g1];
					 tokenizer<> tok(item_check);
					 int count=1;
					 Glib::ustring item_no;
					 std::string delimiter = "@";
					 size_t pos = 0;
					 std::string token;
					 while ((pos =store_value.find(delimiter)) != std::string::npos) 
					 {
						token =  store_value .substr(0, pos);
						store_value.erase(0, pos + delimiter.length());
					 }

					 int  item_no_int = boost::lexical_cast<int>(token);
					if(item_no_int==current_clicked_item)
					{
					image_status=1;
					open_global_data=store_value;
					}

				  }

                  get_property(get_item,current_clicked_item);	//Get Property performs
				  image_status=0;

				  action_status=0;	//Get Property ends
                  }
                  l++;
                }
              }
            }
          }
          k++;
        }
		if(group_select==1)
		{
		if(undo_count>0)
		{
		  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+new_standing_position,undo_redo_tag_vector.begin()+new_standing_position1);
		  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+new_standing_position,undo_redo_child_number_vector.begin()+new_standing_position1);
		  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+new_standing_position,undo_redo_delete_status_vector.begin()+new_standing_position1);
		  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+new_standing_position,undo_redo_position_vector.begin()+new_standing_position1);
		  undo_count=0;
		}
		undo_redo_tag_vector.push_back(str_val1);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
		standing_position=undo_redo_tag_vector.size()-1;
		}
		group_select=0;
      }
    }
    else if((ctr_pt_press==1))
    {
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==changed_item_num)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no==-1)
      {
		item_pos = root->find_child(changed_item);
		find_child_item = root->find_child(changed_item);
		changed_item->get_property(Glib::ustring("width"),button_release_width =0);
		changed_item->get_property(Glib::ustring("height"),button_release_height =0);
		different_move_width = button_release_width - button_press_width;
		different_move_height = button_release_height - button_press_height;
		Glib::ustring different_move_width_str = boost::lexical_cast<std::string>(different_move_width);
		Glib::ustring different_move_height_str = boost::lexical_cast<std::string>(different_move_height);
		Glib::ustring item_no_str = boost::lexical_cast<std::string>(find_child_item);
		Glib::ustring joined_width_height_item = item_no_str + "," + different_move_width_str+ ","+ different_move_height_str;
		press_width_height.push_back(joined_width_height_item);
		get_property(changed_item,item_pos);
      }
      else
      {
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              if(i==child_in_total_list)
              {
                tokenizer<> tok(group_child_total_list[i]);
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
                  Glib::RefPtr<Goocanvas::Item> get_item = root->get_child(child_in_total_list1);
				  action_status=1;	//Get Property starts
				  my_item = get_item;
				  item_pos = child_in_total_list1;
				  current_clicked_item= child_in_total_list1;
				  
	Glib::ustring item_no_str = boost::lexical_cast<std::string>(n);
	Glib::ustring joined_x_y_item = "0,0";
	//press_x_y.push_back(joined_x_y_item);
	press_x_y=joined_x_y_item;

/*CODE RESIZE UPDATE*/
				  image_status=0;
				  for(int g1=0;g1<for_group_image_resize.size();g1++)	
				  {
					  std::string store_value = for_group_image_resize[g1];
					  std::string item_check= for_group_image_resize[g1];
					 tokenizer<> tok(item_check);
					 int count=1;
					 Glib::ustring item_no;
					 std::string delimiter = "@";
					 size_t pos = 0;
					 std::string token;
					 while ((pos =store_value.find(delimiter)) != std::string::npos) 
					 {
						token =  store_value .substr(0, pos);
						store_value.erase(0, pos + delimiter.length());
					 }

					 int  item_no_int = boost::lexical_cast<int>(token);
					if(item_no_int==current_clicked_item)
					{
					image_status=1;

					open_global_data=store_value;
					}

				  }

                  get_property(get_item,child_in_total_list1);	//Get Property performs
				  image_status=0;
				  action_status=0;	//Get Property ends
                  }
                  l++;
                }
              }
            }
          }
          k++;
        }
		if(group_select==1)
		{
		std::string str_val1="GroupPropertyEnds";
		int status=5;
		int position=-1;
		undo_redo_tag_vector.push_back(str_val1);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
		standing_position=undo_redo_tag_vector.size()-1;
		}
		group_select=0;
      }
      ctr_pt_press=0;
    }
    else if((item_pos==1)||(my_x<330&&my_x>930))
    {
    col_flag=0;
    }
    if(event->button==1 && n!=0  && n!=1 && n!=-1 && n!=grid_number)
    {
    update_tag_values();
    }

	count_for_my_str1 = 0;
	grouped_item_num = 0;
	erase_dragging_status=0;
	for_group_image_move.clear();
	image_status=0;
	open_node_name_curve=0;
	text_status=0;
	control_point_number=0;
	for_group_image_resize.clear();
    return false ;
  }
/*HALF SPLIT*/
if(drawing_tool_number==1 && right_click_press_status==0)
  {
      view_grid_on_off();
	  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      if(grid_mode==0)
      	root->remove_child(child_num);
      else
      	root->remove_child(child_num-1);
      child_num=child_num-1;
      new_x = event->x;
      new_y = event->y; 


	  float old1_x,old1_y;
	  float new1_x,new1_y;
	  string value_of_m;
	  string value_of_m1;
	  string value_of_l;
	  string value_of_l1;

   	  old1_x=old_x;
	  old1_y=old_y;
	  new1_x=new_x;
	  new1_y=new_y;
	  value_of_m=boost::lexical_cast<std::string>(old1_x);
	  value_of_m1=boost::lexical_cast<std::string>(old1_y);
	  value_of_l=boost::lexical_cast<std::string>(new1_x);
	  value_of_l1=boost::lexical_cast<std::string>(new1_y);
	  string value_of_l_for_x;
	  string value_of_l_for_y;
	  string open_global_data1;
	  open_global_data1="M "+value_of_m+" "+value_of_m1;

	if(new1_x>=old1_x && new1_y>=old1_y)
	{
		  a=new1_x-old1_x;
		  b=new1_y-old1_y;
		  if(a>b)
		  {
			c=(b/a)/2;
			j=old1_y+c;
			for(i=old1_x+0.5; i<=new1_x;)
			{
		      value_of_l_for_x=boost::lexical_cast<std::string>(i);
			  value_of_l_for_y=boost::lexical_cast<std::string>(j);
		      open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
			  j=j+c;
			  i=i+0.5;
			}
		  }
		  else
		  {
			c=(a/b)/2;
			j=old1_x+c;
			for(i=old1_y+0.5; i<=new1_y;)
			{
			  value_of_l_for_x=boost::lexical_cast<std::string>(j);
			  value_of_l_for_y=boost::lexical_cast<std::string>(i);
			  open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
			  j=j+c;
			  i=i+0.5;
			}
		  }
    }
	else if(new1_x>=old1_x && new1_y<=old1_y)
	{
		  a=new1_x-old1_x;
		  b=old1_y-new1_y;
		  if(a>b)
		  {
			c=(b/a)/2;
			j=old1_y-c;
			for(i=old1_x+0.5; i<=new1_x;)
			{
			  value_of_l_for_x=boost::lexical_cast<std::string>(i);
			  value_of_l_for_y=boost::lexical_cast<std::string>(j);
			  open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
			  j=j-c;
			  i=i+0.5;
			}
		  }
		  else
		  {
			c=(a/b)/2;
			j=old1_x+c;
			for(i=old1_y-0.5; i>=new1_y;)
			{
			  value_of_l_for_x=boost::lexical_cast<std::string>(j);
			  value_of_l_for_y=boost::lexical_cast<std::string>(i);
			  open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
			  j=j+c;
			  i=i-0.5;
			}
		   }
    }
	else if(new1_x<=old1_x && new1_y>=old1_y)
	{
	  a=old1_x-new1_x;
	  b=new1_y-old1_y;
	  if(a>b)
	  {
		c=(b/a)/2;
		j=old1_y+c;
		for(i=old1_x-0.5; i>=new1_x;)
		{
		  value_of_l_for_x=boost::lexical_cast<std::string>(i);
		  value_of_l_for_y=boost::lexical_cast<std::string>(j);
		  open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
		  j=j+c;
		  i=i-0.5;
		}
	  }
	  else
	  {
		c=(a/b)/2;
		j=old1_x-c;
		for(i=old1_y+0.5; i<=new1_y;)
		{
		  value_of_l_for_x=boost::lexical_cast<std::string>(j);
		  value_of_l_for_y=boost::lexical_cast<std::string>(i);
		  open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
		  j=j-c;
		  i=i+0.5;
		}
	  }
	}
	else if(new1_x<=old1_x && new1_y<=old1_y)
	{

	  a=old1_x-new1_x;
	  b=old1_y-new1_y;
	  if(a>b)
	  {
		c=(b/a)/2;
		j=old1_y-c;
		for(i=old1_x-0.5; i>=new1_x;)
		{
		  value_of_l_for_x=boost::lexical_cast<std::string>(i);
		  value_of_l_for_y=boost::lexical_cast<std::string>(j);
		  open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
		  j=j-c;
		  i=i-0.5;
		}
	  }
	  else
	  {

		c=(a/b)/2;
		j=old1_x-c;
		for(i=old1_y-0.5; i>=new1_y;)
		{
		  value_of_l_for_x=boost::lexical_cast<std::string>(j);
		  value_of_l_for_y=boost::lexical_cast<std::string>(i);
		  open_global_data1=open_global_data1+" "+"L "+value_of_l_for_x+" "+value_of_l_for_y;
		  j=j-c;
		  i=i-0.5;
		}
	  }
    }

		Glib::RefPtr<Goocanvas::Path> path;
		path = Goocanvas::Path::create(open_global_data1); 	
		root->add_child(path);
		child_num=child_num+1;
		path->property_stroke_color() = open_global_strokecolor_hex ;
		path->property_line_width() = border_width ; 

		open_global_data = open_global_data1;
		open_global_linewidth = border_width;
		path->get_property("x",open_global_xposition =0);
		path->get_property("y",open_global_yposition =0);
		path->get_property("height",open_global_height =0);
		path->get_property("width",open_global_width =0);

		if(grid_mode==0)
		  changed_item_num=child_num;
		else
		  changed_item_num=child_num-1;
		  open_global_python_data="";
		  create_xml_for_path(" Line ");
		  view_grid_on_off();
		  if(event->button == 1)
		  {
		  _dragging.clear();
		  }
  		open_node_name_curve=0;
 }
  if(drawing_tool_number==15 && right_click_press_status==0) /*Rotate tool - motion notify event*/
  {
    if(event->button == 1)
    {
    _dragging.clear();
    }
  }

  if(drawing_tool_number==2 && right_click_press_status==0)
  {
    view_grid_on_off();
    new_x = event->x ;
    new_y = event->y ;
    if(new_x>old_x && new_y>old_y)
    {
      w = new_x - old_x;
      h = new_y - old_y;
      p1_x = old_x;
      p1_y = old_y+h*0.4;
      p2_x = old_x+w*0.8;
      p2_y = old_y+h*0.4;
      p3_x = old_x+w*0.8;
      p3_y = old_y+h*0.3;
      p4_x = new_x;
      p4_y = old_y+h*0.5;	
      p5_x = old_x+w*0.8;
      p5_y = new_y-h*0.3;
      p6_x = old_x+w*0.8;
      p6_y = new_y-h*0.4;
      p7_x = old_x;
      p7_y = new_y-h*0.4; 
    }
    else if(new_x<old_x && new_y>old_y)
    {
      w = old_x - new_x;
      h = new_y - old_y;
      p1_x = new_x;
      p1_y = old_y+h*0.4;
      p2_x = new_x+w*0.8;
      p2_y = old_y+h*0.4;
      p3_x = new_x+w*0.8;
      p3_y = old_y+h*0.3;
      p4_x = old_x;
      p4_y = old_y+h*0.5;	
      p5_x = new_x+w*0.8;
      p5_y = new_y-h*0.3;
      p6_x = new_x+w*0.8;
      p6_y = new_y-h*0.4;
      p7_x = new_x;
      p7_y = new_y-h*0.4;
    }
    else if(new_x>old_x && new_y<old_y)
    {
      w = new_x - old_x;
      h = old_y - new_y;
      p1_x = old_x;
      p1_y = new_y+h*0.4;
      p2_x = old_x+w*0.8;
      p2_y = new_y+h*0.4;
      p3_x = old_x+w*0.8;
      p3_y = new_y+h*0.3;
      p4_x = new_x;
      p4_y = new_y+h*0.5;	
      p5_x = old_x+w*0.8;
      p5_y = old_y-h*0.3;
      p6_x = old_x+w*0.8;
      p6_y = old_y-h*0.4;
      p7_x = old_x;
      p7_y = old_y-h*0.4;
    }
    else if(new_x<old_x && new_y<old_y)
    {
      w = old_x - new_x;
      h = old_y - new_y;
      p1_x = new_x;
      p1_y = new_y+h*0.4;
      p2_x = new_x+w*0.8;
      p2_y = new_y+h*0.4;
      p3_x = new_x+w*0.8;
      p3_y = new_y+h*0.3;
      p4_x = old_x;
      p4_y = new_y+h*0.5;	
      p5_x = new_x+w*0.8;
      p5_y = old_y-h*0.3;
      p6_x = new_x+w*0.8;
      p6_y = old_y-h*0.4;
      p7_x = new_x;
      p7_y = old_y-h*0.4;
    }
		else
		{
			w=0;
			h=0;
			p1_x=0; p1_y=0; p2_x=0; p2_y=0; p3_x=0; p3_y=0; p4_x=0; p4_y=0; p5_x=0; p5_y=0; p6_x=0; p6_y=0; p7_x=0; p7_y=0;
		}
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    if(grid_mode==0)
    root->remove_child(child_num);
    else
    root->remove_child(child_num-1);
    child_num=child_num-1;
    double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y, x4=p4_x, y4=p4_y, x5=p5_x, y5=p5_y, x6=p6_x, y6=p6_y, x7=p7_x, y7=p7_y;
    Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14;
    std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8, strstr9, strstr10, strstr11, strstr12, strstr13, strstr14;
    strstr1<<x1;
    strstr2<<y1;
    strstr3<<x2;
    strstr4<<y2;
    strstr5<<x3;
    strstr6<<y3;
    strstr7<<x4;
    strstr8<<y4;
    strstr9<<x5;
    strstr10<<y5;
    strstr11<<x6;
    strstr12<<y6;
    strstr13<<x7;
    strstr14<<y7;
    strstr1>>str1;
    strstr2>>str2;
    strstr3>>str3;
    strstr4>>str4;
    strstr5>>str5;
    strstr6>>str6;
    strstr7>>str7;
    strstr8>>str8;
    strstr9>>str9;
    strstr10>>str10;
    strstr11>>str11;
    strstr12>>str12;
    strstr13>>str13;
    strstr14>>str14;
    std::string i;
    i="M "+str1+" "+str2+" L "+str3+" "+str4+" L "+str5+" "+str6+" L "+str7+" "+str8+" L "+str9+" "+str10+" L "+str11+" "+str12+" L "+str13+" "+str14+" Z";
    Glib::RefPtr<Goocanvas::Path> path ;
    path = Goocanvas::Path::create(i); 	
    root->add_child(path);
    child_num=child_num+1;
    path->property_stroke_color() = open_global_strokecolor_hex ;	
    path->property_fill_color() = open_global_fillcolor_hex;
    path->property_line_width() = border_width ;	

    open_global_data = i;
    open_global_linewidth = border_width;
    path->get_property("x",open_global_xposition =0);
    path->get_property("y",open_global_yposition =0);
    path->get_property("height",open_global_height =0);
    path->get_property("width",open_global_width =0);

	if(grid_mode==0)
      changed_item_num=child_num;
    else
      changed_item_num=child_num-1;
	
	open_global_python_data="";
    create_xml_for_path(" Arrow ");
    view_grid_on_off();
    if(event->button == 1)
    {
    _dragging.clear();
    }
  open_node_name_curve=0;
  } 

  if(drawing_tool_number==3 && right_click_press_status==0)
  {
    view_grid_on_off();
    Glib::RefPtr<Goocanvas::Path> path ;	
    if(event->button == 1)
    { 
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      if(grid_mode==0)
      root->remove_child(child_num);
      else
      root->remove_child(child_num-1);
      child_num=child_num-1;
      new_x = event->x;
      new_y = event->y; 
      double x1=old_x, y1=old_y, x2=new_x, y2=new_y;
      Glib::ustring str1, str2, str3, str4;
      std::stringstream strstr1, strstr2, strstr3, strstr4;
      strstr1<<x1;
      strstr2<<y1;
      strstr3<<x2;
      strstr4<<y2;
      strstr1>>str1;
      strstr2>>str2;
      strstr3>>str3;
      strstr4>>str4;
      if (brush_var=="M ")
      {
      brush_var=brush_var+str1+" "+str2+" L "+str3+" "+str4;
      }
      else
      {
      brush_var=brush_var+" L "+str3+" "+str4;
      }
      path = Goocanvas::Path::create(brush_var); 	
      root->add_child(path);
      child_num=child_num+1;
      path->property_stroke_color() = open_global_strokecolor_hex ;
      path->property_line_width() = border_width ; 

      open_global_data = brush_var;
      open_global_linewidth = border_width;
      path->get_property("x",open_global_xposition =0);
      path->get_property("y",open_global_yposition =0);
      path->get_property("height",open_global_height =0);
      path->get_property("width",open_global_width =0);

	  if(grid_mode==0)
        changed_item_num=child_num;
      else
        changed_item_num=child_num-1;

	  open_global_python_data="";
      create_xml_for_path(" Brush ");
      view_grid_on_off();
 
      _dragging.clear();
 	 open_node_name_curve=0;
    }
  }

  if(drawing_tool_number==4 && for_grp_check==0 && right_click_press_status==0)
  {
	flag_set_for_find_child=0;
	count_for_my_str1=0;
	Glib::RefPtr<Goocanvas::Path> path ;	
	if(event->button == 1 && erase_dragging_status==1 && child_num>=2)		//Only if the item is neither gray rectangle nor canvas item, that will selected
	{

		Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();


		if(image_edit_status==1 && eraser_grouped_child_no.size()==0)	
		{
			/*Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
			root->remove_child(current_clicked_item_for_group_erase+1);
			child_num=child_num-1;*/
			edit_flag = 1;      
			create_xml_for_image();				
		}
	else
	{
		if(eraser_grouped_child_no.size()==0)
		{
			edit_flag = 1;      
			create_xml_for_path(erased_value);
			edit_flag = 0;    
		}
		else
		{

			if(undo_count>0)
			{
			  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
			  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
			  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
			  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
			  undo_count=0;
			}

			std::string str_val="GroupPropertyStarts";
			std::string str_val1="GroupPropertyEnds";
			int status=5;
			int position=-1;
			group_select=1;
			undo_redo_tag_vector.push_back(str_val);
			undo_redo_child_number_vector.push_back(position);
			undo_redo_delete_status_vector.push_back(status);
			undo_redo_position_vector.push_back(position);

					
	  			for(int g=0;g<undo_vector_for_group_erase.size();g++)
				{				
					int group_child_number = eraser_grouped_child_no[g];	
					path_tag_after_eraser = undo_vector_for_group_erase[g];
				    Glib::ustring group_child_number_str = boost::lexical_cast<std::string>(group_child_number);
					if(group_child_number_str != path_tag_after_eraser)
					{
						vec_pos = group_child_number-1;
						edit_flag = 1; 
						erase_flag = 1; 	
						create_xml_for_path(erased_value);	
						edit_flag = 0;   
					}
					else
					{
					}

					}

			if(group_select==1)
			{
			undo_redo_tag_vector.push_back(str_val1);
			undo_redo_child_number_vector.push_back(position);
			undo_redo_delete_status_vector.push_back(status);
			undo_redo_position_vector.push_back(position);
			standing_position=undo_redo_tag_vector.size()-1;
			}
			group_select=0;
			
			}//Else End
	   }

	}

    _dragging.clear();
	undo_vector_for_group_erase.clear();
	my_str1_tag_modified1.clear();
	my_str1_tag_modified.clear();
	flag_set_for_find_child=0;
	open_node_name_ellipse_string="2";
	open_node_name_line_string="2";
	open_global_python_data="";
	my_str1_last_tag_modified = "";
	my_str1_tag_modified.clear();
	my_str1_tag_modified1.clear();
	my_str1_tag = "";
	open_node_name_ellipse = "";
	open_node_name_line = "";
	global_y_diff=0;
	global_x_diff=0;
	image_edit_status = 0;	
	eraser_status = 0;
	for_image_set =0;
	erase_flag = 0;
	erase_dragging_status=0;
	count_for_my_str1=0;

 }

  if(drawing_tool_number==5 && right_click_press_status==0)
  {

/****************/


	  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
	
    new_x = event->x ;
    new_y = event->y ;
    double a = new_x + old_x;
    double b = new_y + old_y;
    double x;
    double y;
    if(new_x>old_x)
    x = (new_x - old_x)+1;

    else

    x = (old_x - new_x)+1;

    if(new_y>old_y)

    y = (new_y - old_y)+1;

    else
    y = (old_y - new_y)+1;
    root = m_canvas.get_root_item();
    changed_item=root->get_child(changed_item_num);

    changed_item->set_property("x",a/2);

    changed_item->set_property("y",b/2);

    changed_item->set_property("line_width", border_width);

    if(group_var=="Shift_L" || group_var=="Shift_R")
    {
      if(x>y)
      x=x;
      else
      x=y;
      changed_item->set_property("radius_x",x);
      changed_item->set_property("radius_y",x);
    }
    else
    {

      changed_item->set_property("radius_x",x);
      changed_item->set_property("radius_y",y);
    }


    if(event->button == 1)
    {
    _dragging.clear();
    }
    //open_global_centerx = a/2;
    //open_global_centery = b/2;
	changed_item->get_property("center_x",open_global_centerx =0);
    changed_item->get_property("center_y",open_global_centery =0);
    open_global_xradius = x;
    open_global_yradius = y;
    open_global_linewidth = border_width;	
    changed_item->get_property("x",open_global_xposition =0);
    changed_item->get_property("y",open_global_yposition =0);
    //create_xml_for_ellipse();
   

	string open_global_centerx1= boost::lexical_cast<std::string>(open_global_centerx);
	string open_global_centery1= boost::lexical_cast<std::string>(open_global_centery);
	string open_global_xposition1= boost::lexical_cast<std::string>(open_global_xradius);
	string open_global_yposition1= boost::lexical_cast<std::string>(open_global_yradius);
string my_str1_tag_modified3="[("+ open_global_centerx1 + ", "+ open_global_centery1 + ", " + open_global_xposition1 + ", " + open_global_yposition1 + ", " + "180)" + ", " + "(305, 153, 5, 1.5, -30)]";

	const char *c = my_str1_tag_modified3.c_str();



	PyObject *main = PyImport_AddModule("__main__"); // borrowed
	PyObject *globals = PyModule_GetDict(main); // borrowed


	PyObject *value = PyString_FromString(c);

	PyDict_SetItemString(globals, "n", value);
	   //error();

	Py_DECREF(value);

		PyRun_SimpleString("import ast\n"
	"import numpy as np\n"
	"from shapely.geometry.polygon import LinearRing , Polygon\n"
	"def ellipse_polyline(ellipses, n=100):\n"
	"	t = np.linspace(0, 2*np.pi, n, endpoint=False)\n"
	"	st = np.sin(t)\n"
	"	ct = np.cos(t)\n"
	"	result = []\n"
	"	for x0, y0, a, b, angle in ellipses:\n"
	"		angle = np.deg2rad(angle)\n"
	"		sa = np.sin(angle)\n"
	"		ca = np.cos(angle)\n"
	"		p = np.empty((n, 2))\n"
	"		p[:, 0] = x0 + a * ca * ct - b * sa * st\n"
	"		p[:, 1] = y0 + a * sa * ct + b * ca * st\n"
	"		result.append(p)\n"
	"	return result\n"
	"a1= ast.literal_eval(n)\n"
	"ellipses = a1\n"
	"a, b = ellipse_polyline(ellipses)\n"
	"a = Polygon(a)\n"
	"erase = a\n"
	"eraser=str(erase)\n"
	"f=open('file.txt','w')\n"
	"f.write(eraser)\n"
	"f=open('file.txt','r')\n"
	"text=f.read()\n");


	PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
	PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
	PyObject * eraser = PyDict_GetItemString(dictionary, "text");
	string erase_value = PyString_AsString(eraser);

	
		string first_value = erase_value;
		boost::replace_all(first_value, "POLYGON ((", "M ");
		boost::replace_all(first_value, ",", " L");
		boost::replace_all(first_value, "))", " Z");


		


   // erased_value = " Star1 ";;//rkrkrk

	open_global_data = first_value;
	open_global_python_data="";
	//open_node_value = erased_value.c_str();
	//current_clicked_item=root->find_child(changed_item);
	//open_create_path();


		Glib::RefPtr<Goocanvas::Path> path;
		path = Goocanvas::Path::create(open_global_data); 	
		root->remove_child(child_num-1);
		root->add_child(path,child_num-1);
		//child_num = child_num+1;

		path->property_stroke_color() = open_global_strokecolor_hex ;
		path->property_fill_color() = open_global_fillcolor_hex ;
		path->property_line_width() = border_width ; 

		open_global_linewidth = border_width;
		path->get_property("x",open_global_xposition =0);
		path->get_property("y",open_global_yposition =0);
		path->get_property("height",open_global_height =0);
		path->get_property("width",open_global_width =0);

   
		create_xml_for_path(" Star1 ");


 		 open_node_name_curve=0;

    /*xml ends*/
  } 

  if(drawing_tool_number==6 && right_click_press_status==0)
  {
    if(event->button == 1 && right_click_press_status==0)
    {
    new_x = event->x ;
    new_y = event->y ;
    double a;
    double b;
    double x;
    double y;
    if(new_x>old_x)
    {
    a = new_x - old_x;
    x = old_x;
    }
    else
    {
    a = old_x - new_x;
    x = new_x;
    }
    if(new_y>old_y)
    {
    b = new_y - old_y;
    y = old_y;	
    }
    else
    {
    b = old_y - new_y;
    y = new_y;
    }
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    changed_item=root->get_child(changed_item_num);
    changed_item->set_property("x",x);
    changed_item->set_property("y",y);
    if(group_var=="Shift_L" || group_var=="Shift_R")
    {
      if(a>b)
      a=a;
      else
      a=b;
      changed_item->set_property("width",a);
      changed_item->set_property("height",a);
    }
    else
    {
    changed_item->set_property("width",a);
    changed_item->set_property("height",b);
    }


    /*xml begins*/
    open_global_x = x;
    open_global_y = y;
    open_global_width = a;
    open_global_height = b;
    open_global_linewidth = border_width;
    open_global_xradius = border_x_radius;
    open_global_yradius = border_y_radius;
    changed_item->get_property("x",open_global_xposition =0);
    changed_item->get_property("y",open_global_yposition =0);

	/*THIS CODE FOR CONVERT RECTAGLE TO PATH*/

		 int m=open_global_xposition;
		 int m1=open_global_yposition;
		 int l=open_global_xposition + open_global_width;
		 int l1=open_global_yposition +open_global_height; 
		 string value_of_m,value_of_m1,value_of_l,value_of_l1;
		 value_of_m=boost::lexical_cast<std::string>(m);
		 value_of_m1=boost::lexical_cast<std::string>(m1);
		 value_of_l=boost::lexical_cast<std::string>(l);
		 value_of_l1=boost::lexical_cast<std::string>(l1);
		string open_global_data1;
		open_global_data1="M "+value_of_m+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_l1+" "+"L "+value_of_m+" "+value_of_l1+" "+"z";
		 my_str1_tag = open_global_data1;
		 erased_value = " Star1 ";
		 string strvalue3;
		current_clicked_item = root->find_child(changed_item);
		stringstream stream(open_global_data1);
		open_global_data = open_global_data1;
		edit_flag=1;
		open_node_value = erased_value.c_str();
		open_global_python_data="";
		open_create_path();
		edit_flag=0;
		create_xml_for_path(erased_value);
	/*THIS CODE FOR CONVERT RECTAGLE TO PATH*/

   // create_xml_for_rectangle();
	open_node_name_curve=0;
    _dragging.clear();
    }
    /*xml ends*/
  } 

  if(drawing_tool_number==7 && right_click_press_status==0)
  { 
    view_grid_on_off();
    new_x = event->x ;
    new_y = event->y ;
    if(new_x>old_x && new_y>old_y)
    {
      w = new_x - old_x;
      h = new_y - old_y;
      p1_x = old_x+w/2;
      p1_y = old_y;
      p2_x = old_x+w/6;
      p2_y = new_y;
      p3_x = new_x-w/6;
      p3_y = new_y;
      p4_x = old_x;
      p4_y = old_y+h/3;
      p5_x = new_x;
      p5_y = old_y+h/3;	
    }
    else if(new_x<old_x && new_y>old_y)
    {
      w = old_x - new_x;
      h = new_y - old_y;
      p1_x = new_x+w/2;
      p1_y = old_y;
      p2_x = new_x+w/6;
      p2_y = new_y;
      p3_x = old_x-w/6;
      p3_y = new_y;
      p4_x = new_x;
      p4_y = old_y+h/3;
      p5_x = old_x;
      p5_y = old_y+h/6;
    }
    else if(new_x>old_x && new_y<old_y)
    {
      w = new_x - old_x;
      h = old_y - new_y;
      p1_x = old_x+w/2;
      p1_y = new_y;
      p2_x = old_x+w/6;
      p2_y = old_y;
      p3_x = new_x-w/6;
      p3_y = old_y;
      p4_x = old_x;
      p4_y = new_y+h/3;
      p5_x = new_x;
      p5_y = new_y+h/3;
    }
    else if(new_x<old_x && new_y<old_y)
    {
      w = old_x - new_x;
      h = old_y - new_y;
      p1_x = new_x+w/2;
      p1_y = new_y;
      p2_x = new_x+w/6;
      p2_y = old_y;
      p3_x = old_x-w/6;
      p3_y = old_y;
      p4_x = new_x;
      p4_y = new_y+h/3;
      p5_x = old_x;
      p5_y = new_y+h/3;
    }
    else
    {
      w=0;
      h=0;
	  p1_x=0; p1_y=0; p2_x=0; p2_y=0; p3_x=0; p3_y=0; p4_x=0; p4_y=0; p5_x=0; p5_y=0;
    }
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    if(grid_mode==0)
    root->remove_child(child_num);
    else
    root->remove_child(child_num-1);
    child_num=child_num-1;
    double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y, x4=p4_x, y4=p4_y, x5=p5_x, y5=p5_y;
    Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8, str9, str10;
    std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8, strstr9, strstr10;
    strstr1<<x1;
    strstr2<<y1;
    strstr3<<x2;
    strstr4<<y2;
    strstr5<<x3;
    strstr6<<y3;
    strstr7<<x4;
    strstr8<<y4;
    strstr9<<x5;
    strstr10<<y5;
    strstr1>>str1;
    strstr2>>str2;
    strstr3>>str3;
    strstr4>>str4;
    strstr5>>str5;
    strstr6>>str6;
    strstr7>>str7;
    strstr8>>str8;
    strstr9>>str9;
    strstr10>>str10;
    std::string i;
    i="M "+str3+" "+str4+" L "+str1+" "+str2+" L "+str5+" "+str6+" L "+str7+" "+str8+" L "+str9+" "+str10+" Z";
    Glib::RefPtr<Goocanvas::Path> path ;
    path = Goocanvas::Path::create(i); 	
    root->add_child(path);
    path->property_stroke_color() = open_global_strokecolor_hex ;
    path->property_fill_color() = open_global_fillcolor_hex;
    path->property_line_width() = border_width ;
    child_num=child_num+1;

    open_global_data = i;
    open_global_linewidth = border_width;
    path->get_property("x",open_global_xposition =0);
    path->get_property("y",open_global_yposition =0);
    path->get_property("height",open_global_height =0);
    path->get_property("width",open_global_width =0);

	if(grid_mode==0)
      changed_item_num=child_num;
    else
      changed_item_num=child_num-1;

	open_global_python_data="";
    create_xml_for_path(" Star ");
    view_grid_on_off();
    if(event->button == 1)
    {
    _dragging.clear();
    }
  open_node_name_curve=0;
  }

  if(drawing_tool_number==8 && right_click_press_status==0)
  {
    view_grid_on_off();
    new_x = event->x ;
    new_y = event->y ;
    if(new_x>old_x && new_y>old_y)
    {
      w = new_x - old_x;
      h = new_y - old_y;
      p1_x = old_x+w/2;
      p1_y = old_y;
      p2_x = new_x-w/2.8;
      p2_y = old_y+h/3;
      p3_x = new_x;
      p3_y = old_y+h/3;
      p4_x = old_x+w*3/4;
      p4_y = old_y+h/1.6;
      p5_x = new_x-w/7;
      p5_y = new_y;
      p6_x = old_x+w/2;
      p6_y = old_y+h*3.2/4;
      p7_x = old_x+w/7;
      p7_y = new_y;
      p8_x = old_x+w*1/4;
      p8_y = old_y+h/1.6;
      p9_x = old_x;
      p9_y = old_y+h/3;
      p10_x = old_x+w/2.8;
      p10_y = old_y+h/3;
    }
    else if(new_x<old_x && new_y>old_y)
    {
      w = old_x - new_x;
      h = new_y - old_y;
      p1_x = new_x+w/2;
      p1_y = old_y;
      p2_x = old_x-w/2.8;
      p2_y = old_y+h/3;
      p3_x = old_x;
      p3_y = old_y+h/3;
      p4_x = new_x+w*3/4;
      p4_y = old_y+h/1.6;
      p5_x = old_x-w/7;
      p5_y = new_y;
      p6_x = new_x+w/2;
      p6_y = old_y+h*3.2/4;
      p7_x = new_x+w/7;
      p7_y = new_y;
      p8_x = new_x+w*1/4;
      p8_y = old_y+h/1.6;
      p9_x = new_x;
      p9_y = old_y+h/3;
      p10_x = new_x+w/2.8;
      p10_y = old_y+h/3;
    }
    else if(new_x>old_x && new_y<old_y)
    {
      w = new_x - old_x;
      h = old_y - new_y;
      p1_x = old_x+w/2;
      p1_y = new_y;
      p2_x = new_x-w/2.8;
      p2_y = new_y+h/3;
      p3_x = new_x;
      p3_y = new_y+h/3;
      p4_x = old_x+w*3/4;
      p4_y = new_y+h/1.6;
      p5_x = new_x-w/7;
      p5_y = old_y;
      p6_x = old_x+w/2;
      p6_y = new_y+h*3.2/4;
      p7_x = old_x+w/7;
      p7_y = old_y;
      p8_x = old_x+w*1/4;
      p8_y = new_y+h/1.6;
      p9_x = old_x;
      p9_y = new_y+h/3;
      p10_x = old_x+w/2.8;
      p10_y = new_y+h/3;
    }
    else if(new_x<old_x && new_y<old_y)
    {
      w = old_x - new_x;
      h = old_y - new_y;
      p1_x = new_x+w/2;
      p1_y = new_y;
      p2_x = old_x-w/2.8;
      p2_y = new_y+h/3;
      p3_x = old_x;
      p3_y = new_y+h/3;
      p4_x = new_x+w*3/4;
      p4_y = new_y+h/1.6;
      p5_x = old_x-w/7;
      p5_y = old_y;
      p6_x = new_x+w/2;
      p6_y = new_y+h*3.2/4;
      p7_x = new_x+w/7;
      p7_y = old_y;
      p8_x = new_x+w*1/4;
      p8_y = new_y+h/1.6;
      p9_x = new_x;
      p9_y = new_y+h/3;
      p10_x = new_x+w/2.8;
      p10_y = new_y+h/3;
    }
    else
    {
      w=0;
      h=0;
      p1_x=0; p1_y=0; p2_x=0; p2_y=0; p3_x=0; p3_y=0; p4_x=0; p4_y=0; p5_x=0; p5_y=0; p6_x=0; p6_y=0; p7_x=0; p7_y=0; p8_x=0; p8_y=0; p9_x=0; p9_y=0; p10_x=0; p10_y=0;
    }
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    if(grid_mode==0)
    root->remove_child(child_num);
    else
    root->remove_child(child_num-1);
    child_num=child_num-1;
    double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y, x4=p4_x, y4=p4_y, x5=p5_x, y5=p5_y, x6=p6_x, y6=p6_y, x7=p7_x, y7=p7_y, x8=p8_x, y8=p8_y, x9=p9_x, 	 y9=p9_y, x10=p10_x, y10=p10_y;
    Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14, str15, str16, str17, str18, str19, str20;
    std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8, strstr9, strstr10, strstr11, strstr12, strstr13, strstr14, strstr15, strstr16, strstr17, strstr18, strstr19, strstr20;
    strstr1<<x1;
    strstr2<<y1;
    strstr3<<x2;
    strstr4<<y2;
    strstr5<<x3;
    strstr6<<y3;
    strstr7<<x4;
    strstr8<<y4;
    strstr9<<x5;
    strstr10<<y5;
    strstr11<<x6;
    strstr12<<y6;
    strstr13<<x7;
    strstr14<<y7;
    strstr15<<x8;
    strstr16<<y8;
    strstr17<<x9;
    strstr18<<y9;
    strstr19<<x10;
    strstr20<<y10;
    strstr1>>str1;
    strstr2>>str2;
    strstr3>>str3;
    strstr4>>str4;
    strstr5>>str5;
    strstr6>>str6;
    strstr7>>str7;
    strstr8>>str8;
    strstr9>>str9;
    strstr10>>str10;
    strstr11>>str11;
    strstr12>>str12;
    strstr13>>str13;
    strstr14>>str14;
    strstr15>>str15;
    strstr16>>str16;
    strstr17>>str17;
    strstr18>>str18;
    strstr19>>str19;
    strstr20>>str20;
    std::string i;
    i="M "+str1+" "+str2+" L "+str3+" "+str4+" L "+str5+" "+str6+" L "+str7+" "+str8+" L "+str9+" "+str10+" L "+str11+" "+str12+" L "+str13+" "+str14+" L "+str15+" "+str16+" L "+str17+" "+str18+" L "+str19+" "+str20+" Z";
    Glib::RefPtr<Goocanvas::Path> path ;
    path = Goocanvas::Path::create(i); 	
    root->add_child(path);
    path->property_stroke_color() = open_global_strokecolor_hex ;
    path->property_fill_color() = open_global_fillcolor_hex;
    path->property_line_width() = border_width ;
    child_num=child_num+1;
    open_global_data = i;
    open_global_linewidth = border_width;
    path->get_property("x",open_global_xposition =0);
    path->get_property("y",open_global_yposition =0);
    path->get_property("height",open_global_height =0);
    path->get_property("width",open_global_width =0);
	
	if(grid_mode==0)
      changed_item_num=child_num;
    else
      changed_item_num=child_num-1;

	open_global_python_data="";
    create_xml_for_path(" Star1 ");
    view_grid_on_off();	
    if(event->button == 1)
    {
    _dragging.clear();
    }
  open_node_name_curve=0;
  }

  if(drawing_tool_number==9 && right_click_press_status==0)
  {
    view_grid_on_off();
    new_x = event->x ; 
    new_y = event->y ;
    if(new_x>old_x && new_y>old_y)
    {
      w = new_x - old_x;
      h = new_y - old_y;
      p1_x = old_x+w/2;
      p1_y = old_y;
      p2_x = old_x;
      p2_y = new_y;
      p3_x = new_x;
      p3_y = new_y;	
    }
    else if(new_x<old_x && new_y>old_y)
    {
      w = old_x - new_x;
      h = new_y - old_y;
      p1_x = new_x+w/2;
      p1_y = old_y;
      p2_x = new_x;
      p2_y = new_y;
      p3_x = old_x;
      p3_y = new_y;
    }
    else if(new_x>old_x && new_y<old_y)
    {
      w = new_x - old_x;
      h = old_y - new_y;
      p1_x = old_x+w/2;
      p1_y = new_y;
      p2_x = old_x;
      p2_y = old_y;
      p3_x = new_x;
      p3_y = old_y;
    }
    else if(new_x<old_x && new_y<old_y)
    {
      w = old_x - new_x;
      h = old_y - new_y;
      p1_x = new_x+w/2;
      p1_y = new_y;
      p2_x = new_x;
      p2_y = old_y;
      p3_x = old_x;
      p3_y = old_y;
    } 
    else
    {
      w=0;
      h=0;
	  p1_x=0; p1_y=0; p2_x=0; p2_y=0; p3_x=0; p3_y=0;
    }
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    if(grid_mode==0)
    root->remove_child(child_num);
    else
    root->remove_child(child_num-1);
    child_num=child_num-1;
    double x1=p1_x, y1=p1_y, x2=p2_x, y2=p2_y, x3=p3_x, y3=p3_y;
    Glib::ustring str1, str2, str3, str4, str5, str6;
    std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6;
    strstr1<<x1;
    strstr2<<y1;
    strstr3<<x2;
    strstr4<<y2;
    strstr5<<x3;
    strstr6<<y3;
    strstr1>>str1;
    strstr2>>str2;
    strstr3>>str3;
    strstr4>>str4;
    strstr5>>str5;
    strstr6>>str6;
    std::string i;
  //  i="M "+str1+" "+str2+" L "+str3+" "+str4+" L "+str5+" "+str6+" Z";
i="M "+str1+" "+str2+" L "+str5+" "+str6+" L "+str3+" "+str4+" Z";

    Glib::RefPtr<Goocanvas::Path> path ;
    path = Goocanvas::Path::create(i); 	
    root->add_child(path);
    path->property_stroke_color() = open_global_strokecolor_hex ;
    path->property_fill_color() = open_global_fillcolor_hex;
    path->property_line_width() = border_width ;
    child_num=child_num+1;

    open_global_data = i;
    open_global_linewidth = border_width;
    path->get_property("x",open_global_xposition =0);
    path->get_property("y",open_global_yposition =0);
    path->get_property("height",open_global_height =0);
    path->get_property("width",open_global_width =0);

	if(grid_mode==0)
      changed_item_num=child_num;
    else
      changed_item_num=child_num-1;

	open_global_python_data="";
    create_xml_for_path(" Triangle ");
    view_grid_on_off();
    if(event->button == 1)
    {
    _dragging.clear();
    }
  open_node_name_curve=0;
  } 
  
  if(drawing_tool_number==10 && right_click_press_status==0)
  {
    if(event->button == 1)
    {
    _dragging.clear();
    }
  open_node_name_curve=0;
  } 

  if(drawing_tool_number==14 && right_click_press_status==0)
  {
    if(event->button == 1)
    {
      _dragging.clear();
      int grid_status=0;
      if(grid_mode==1)
      {
        view_grid_on_off();
        grid_status=1;
      }
      if(curve_cnt>1)
      {
        new_x = event->x ;
        new_y = event->y ; 
        Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
        for(child_var=last_child_num+1; child_var<=child_num; child_var++)
        {
        root->remove_child(last_child_num+1);	
        }
        child_num=last_child_num;
        if(curve_cnt==dragging_var)
        {
          double x1=old_x, y1=old_y, x2=new_x, y2=new_y;
          Glib::ustring str1, str2, str3, str4;
          std::stringstream strstr1, strstr2, strstr3, strstr4;
          strstr1<<x1;
          strstr2<<y1;
          strstr3<<x2;
          strstr4<<y2;
          strstr1>>str1;
          strstr2>>str2;
          strstr3>>str3;
          strstr4>>str4;
          if (brush_var=="M ")
          brush_var=brush_var+str1+" "+str2+" L "+str3+" "+str4; 
          else
          brush_var=brush_var+" L "+str3+" "+str4; 
          last_child_num=child_num;
          Glib::RefPtr<Goocanvas::Path> path ;
          path = Goocanvas::Path::create(brush_var); 	
          root->add_child(path);
          child_num=child_num+1; 
          path->property_stroke_color() = open_global_strokecolor_hex ;
          path->property_line_width() = border_width;
        }
        else
        {
          a = new_x-new_a;
          b = new_y-new_b; 
          double x1=old_x, y1=old_y, x2=new_a, y2=new_b,	x3=old_x-a, y3=old_y-b, x4=new_a-a, y4=new_b-b;
          Glib::ustring str1, str2, str3, str4, str5, str6, str7, str8;
          std::stringstream strstr1, strstr2, strstr3, strstr4, strstr5, strstr6, strstr7, strstr8;
          strstr1<<x1;
          strstr2<<y1;
          strstr3<<x2;
          strstr4<<y2;
          strstr5<<x3;
          strstr6<<y3;
          strstr7<<x4;
          strstr8<<y4;
          strstr1>>str1;
          strstr2>>str2;
          strstr3>>str3;
          strstr4>>str4;
          strstr5>>str5;
          strstr6>>str6;
          strstr7>>str7;
          strstr8>>str8;
          if (brush_var=="M ")
          brush_var=brush_var+str1+" "+str2+" C "+str5+" "+str6+" "+str7+" "+str8+" "+str3+" "+str4;
          else
          brush_var=brush_var+" C "+str5+" "+str6+" "+str7+" "+str8+" "+str3+" "+str4;
          last_child_num=child_num;
          Glib::RefPtr<Goocanvas::Path> path ;
          path = Goocanvas::Path::create(brush_var); 	
          root->add_child(path);
          child_num=child_num+1; 
          path->property_stroke_color() = open_global_strokecolor_hex ;
          path->property_line_width() = border_width ;  

        }
        if(curve_cnt>2 && starting_x!=new_x)	//To Remove the bit of path which are previously created at each time
        {
        root->remove_child(child_num-1);
        child_num=child_num-1;
        }
        old_x = event->x ;
        old_y = event->y ;
        last_child_num=child_num;
        Glib::RefPtr< Goocanvas::Item > poly_curve ;
        poly_curve = root->get_child(child_num);
        poly_curve->get_property("x",open_global_xposition =0);
        poly_curve->get_property("y",open_global_yposition =0);
        poly_curve->get_property("width",open_global_width =0);
        poly_curve->get_property("height",open_global_height =0);
        open_global_data = brush_var;
        open_global_linewidth = border_width;

		open_global_python_data="";
        Glib::ustring path_open_tag = "<Path";
        Glib::ustring path_close_tag;
        Glib::ustring path_fill_color;
        path_close_tag = " Curve </Path>";	
        Glib::ustring path_i_tag = " data=\"";
        Glib::ustring path_stroke_color = " strokecolor=\"";
        Glib::ustring path_line_width = " linewidth=\"";

        Glib::ustring path_height_tag = " height=\"";
        Glib::ustring path_width_tag = " width=\"";

        Glib::ustring path_xposition = " xposition=\"";
        Glib::ustring path_yposition = " yposition=\"";

        Glib::ustring path_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
        Glib::ustring path_width_tag_value = boost::lexical_cast<std::string>(open_global_width);

        Glib::ustring path_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
        Glib::ustring path_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
        Glib::ustring path_width_value = boost::lexical_cast<std::string>(open_global_linewidth);
        Glib::ustring path_tag;
        path_tag = path_open_tag + path_i_tag + open_global_data + "\"" + path_stroke_color + open_global_strokecolor_hex + "\"" + path_line_width + path_width_value + "\""  + path_xposition + path_xposition_value + "\"" + path_yposition + path_yposition_value + "\"" + path_width_tag + path_width_tag_value + "\"" + path_height_tag + path_height_tag_value + "\">" + path_close_tag;

		  open_node_name_curve=1;

        if(curve_cnt==2)
		{
        xml_scene_overall_tag.push_back(path_tag);
//undo-redo-code-starts here
//undo-redo-code-starts here
if(undo_status==0)
{
  if(undo_count>0)
  {
	undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
	undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
	undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
	undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
	undo_count=0;
  }

  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.push_back(path_tag);
  undo_redo_child_number_vector.push_back(child_num);
  int status=0;
  int position=-1;
  undo_redo_delete_status_vector.push_back(status);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = path_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)
	{	
	  undo_redo_tag_vector.push_back(path_tag);
	  undo_redo_child_number_vector.push_back(child_num);
	  int status=0;
	  int position=-1;
	  undo_redo_delete_status_vector.push_back(status);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{	
	}
  }
}
//undo-redo-code-ends here
//undo-redo-code-ends here

		}
        else
		{
        xml_scene_overall_tag.at(xml_scene_overall_tag.size()-1) = path_tag;
//undo-redo-code-starts here
//undo-redo-code-starts here
if(undo_status==0)
{
  if(undo_count>0)
  {
	undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
	undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
	undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
	undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
	undo_count=0;
  }

  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.at(undo_redo_tag_vector.size()-1) = path_tag;
  undo_redo_child_number_vector.at(undo_redo_child_number_vector.size()-1) = child_num;
  undo_redo_delete_status_vector.at(undo_redo_delete_status_vector.size()-1) = 0;
  undo_redo_position_vector.at(undo_redo_position_vector.size()-1) = -1;
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = path_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)
	{	
	  undo_redo_tag_vector.at(undo_redo_tag_vector.size()-1) = path_tag;
	  undo_redo_child_number_vector.at(undo_redo_child_number_vector.size()-1) = child_num;
	  undo_redo_delete_status_vector.at(undo_redo_delete_status_vector.size()-1) = 0;
	  undo_redo_position_vector.at(undo_redo_position_vector.size()-1) = -1;
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{	
	}
  }
}
//undo-redo-code-ends here
//undo-redo-code-ends here

		}
      }
      if(grid_status==1)
      view_grid_on_off();
    }
  }
  right_click_press_status = 0;
  to_png();
  right_click_press_status = 0;
}

std::string KalanjiyamWindow::open_file_dialog_box()
{
  std::string filename;
  std::string file;
  Gtk::FileChooserDialog dialog("Please choose a file",
  Gtk::FILE_CHOOSER_ACTION_OPEN);
  dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
  dialog.add_button(Gtk::Stock::OPEN, Gtk::RESPONSE_OK);
  int result = dialog.run();
  switch(result)
  {
    case(Gtk::RESPONSE_OK):
    {
    filename = dialog.get_filename();
    break;
    }
    case(Gtk::RESPONSE_CANCEL):
    {
    break;
    }
    default:
    {
    break;
    }
  }
  return(std::string(filename));
}

bool KalanjiyamWindow::on_button_press_event(GdkEventButton* event)
{

  if( (event->type == GDK_BUTTON_PRESS) && (event->button == 3) )
  {
    Gtk::Menu *pMenu = new Gtk::Menu();
    Gtk::MenuItem *pItem = new Gtk::MenuItem("Import Image");
    pItem->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addImportImage) ); 
    Gtk::MenuItem *pItem2 = new Gtk::MenuItem("Scene Add");
    pItem2->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addScene) ); 
    Gtk::MenuItem *pItem3 = new Gtk::MenuItem("Shot Add");
    pItem3->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addShot) ); 
    Gtk::MenuItem *pItem4 = new Gtk::MenuItem("External Image Editor");
    pItem4->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::addExternalImageEditor) ); 

    Gtk::MenuItem *pItem5 = new Gtk::MenuItem("First Panel");
    pItem5->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_firstPanel) ); 
    Gtk::MenuItem *pItem6 = new Gtk::MenuItem("Previous Panel");
    pItem6->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_previousPanel) ); 
    Gtk::MenuItem *pItem7 = new Gtk::MenuItem("Last Panel");
    pItem7->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_lasttPanel) ); 
    Gtk::MenuItem *pItem8 = new Gtk::MenuItem("Next Panel");
    pItem8->signal_activate().connect( sigc::mem_fun(*this, &KalanjiyamWindow::nav_nextPanel) ); 

    pMenu->add(*pItem);
    pMenu->add(*pItem2);
    pMenu->add(*pItem3);
    pMenu->add(*pItem4);
    pMenu->add(*pItem5);
    pMenu->add(*pItem6);
    pMenu->add(*pItem7);
    pMenu->add(*pItem8);
    pMenu->show_all();
	right_click_press_status = 1;
    pMenu->popup(event->button, event->time);

    return true; //It has been handled.
  }
  else
  {
    return false;
  }
}

void KalanjiyamWindow::select_move()
{ 
  polyline_cnt_curve_cnt();
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=11;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number); 
  pSbar->push("Select/Move tool clicked...");
}

bool KalanjiyamWindow::on_rotate_motion_notify_event(const Glib::RefPtr<Goocanvas::Item>& item,  GdkEventMotion* event)
{
  if(drawing_tool_number==15) /*Rotate tool - motion notify event*/
  {
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    int n = root->find_child(item);
    if(n!=0)
    {
      if((item && _dragging) && item == _dragging)
      {
      _dragging = item;
      new_x=event->x;
      new_y=event->y;
      item->rotate(new_x,old_x,old_y);
      }
    }
    return false ;
  }
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
  {
  selected_items_remove();
  }
  polyline_cnt_curve_cnt();
}	

void KalanjiyamWindow::draw_line_shape()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->hide();
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=1;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Line tool clicked..."); 
}

void KalanjiyamWindow::draw_arrow_shape()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->show();
  pEraserWidth->hide();

  drawing_tool_number=2;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Shape tool clicked...");
 // open_global_fillcolor_hex = "#FFFFFF";		
  //darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
  }	 

void KalanjiyamWindow::show_img_collection()
{
  control_points_selected_items_remove();
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->hide();
  pFillColor->hide();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->show();
  pEraserWidth->hide();

  pNotebook->get_nth_page(2)->show();
  pNotebook->set_current_page(2);
  drawing_tool_number=15;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number); 
  pSbar->push("Image Collection tool clicked...");
}

void KalanjiyamWindow::draw_brush()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->hide();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=3;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Brush tool clicked..."); 

}	  

void KalanjiyamWindow::draw_eraser()
{
  control_points_selected_items_remove();
  pEraserWidth->show();
  pBorderWidth->hide();
  pFont->hide();
  pStrokeColor->hide();
  pFillColor->hide();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  drawing_tool_number=4;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  //edit_clear_selected_object();

}	 	 

void KalanjiyamWindow::draw_ellipse()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=5;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Ellipse tool clicked...");
 // open_global_fillcolor_hex = "#FFFFFF";		
 // darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
}

void KalanjiyamWindow::draw_rectangle()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->show();	
  pBorderYradius->show();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=6;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Rectangle tool clicked...");
 // open_global_fillcolor_hex = "#FFFFFF";		
 // darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
}

void KalanjiyamWindow::draw_star_shape()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->show();
  pEraserWidth->hide();

  drawing_tool_number=7;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Shape tool clicked...");
 // open_global_fillcolor_hex = "#FFFFFF";		
//  darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
}

void KalanjiyamWindow::draw_star1_shape()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->show();
  pEraserWidth->hide();

  drawing_tool_number=8;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Shape tool clicked...");
//  open_global_fillcolor_hex = "#FFFFFF";		
//  darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
}
void KalanjiyamWindow::draw_triangle_shape()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->show();
  pEraserWidth->hide();

  drawing_tool_number=9;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Shape tool clicked...");
 // open_global_fillcolor_hex = "#FFFFFF";		
 // darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
}

void KalanjiyamWindow::draw_polyline()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->hide();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=10;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Polyline tool clicked...");
}

void KalanjiyamWindow::draw_curve()
{
  control_points_selected_items_remove();
  edit_flag=0;
  col_flag=0;
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->hide();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=14;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Curve tool clicked...");

}

void KalanjiyamWindow::zoom_in()
{
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=12;
  int grid_status=0;
  if(grid_mode==1)
  {
  view_grid_on_off();
  grid_status=1;
  }
  if(zoom_step_count>=900)
  {
    pInfoLabel->set_text("Maximum ZoomIn level Occured. \nReset Zoom Level...");
    pInfoDialog->show();
    pSbar->push("Maximum ZoomIn level Occured. Reset Zoom Level...");
    zoom_step_count = 200;
  }
  else
  {
  m_canvas.set_scale(m_canvas.get_scale() + 0.003); 
  zoom_step_count = zoom_step_count + 1;
  }
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Zoom-in tool clicked...");
  if(grid_status==1)
  view_grid_on_off();  

}

void KalanjiyamWindow::zoom_out()
{
  pBorderWidth->show();
  pFont->hide();
  pStrokeColor->show();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=13;
  int grid_status=0;
  if(grid_mode==1)
  {
  view_grid_on_off();
  grid_status=1;
  }
  if(zoom_step_count<=0)
  {
    pInfoLabel->set_text("Minimum ZoomOut level Occured. \nReset Zoom Level...");
    pInfoDialog->show();
    pSbar->push("Minimum ZoomOut level Occured. Reset Zoom Level...");
    zoom_step_count = 0;
  }
  else
  {
  m_canvas.set_scale(m_canvas.get_scale() - 0.003); 
  zoom_step_count = zoom_step_count - 1;
  }
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number);
  pSbar->push("Zoom-out tool clicked..."); 
  if(grid_status==1)
  view_grid_on_off();

}

void KalanjiyamWindow::edit_undo()
{
eraser_grouped_child_no.clear();
//undo-redo-code-starts here
//undo-redo-code-starts here
if(undo_redo_tag_vector.size()>0)
{
  if(standing_position>=standing_position_value)
  {
	if(undo_redo_delete_status_vector[standing_position]==9)	//For Multi Delete
	{
	  group_child_buffer1_no.clear();
	  if(undo_redo_tag_vector[standing_position]=="MultiDeleteEnds")
	    standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="GroupVectorValues")
		{
		  if(group_child_total_list.size()==0)
			group_child_total_list.push_back("Group Vector");
	      Glib::ustring int_to_string_value;
	      std::string total_arr;
		  int current_child_no=-1;
          tokenizer<> tok(undo_redo_tag_vector[standing_position]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
	        int l=1;
	        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
	        {
	          if(l!=1)
	          {
			    std::stringstream str(*beg);
			    str>>current_child_no;
			  }
			  l++;
			}
		  }
		  if(current_child_no!=-1)	//This condition for the Group value (eg. G,1,2) do not comes to here
		  {
		    for(int j=0; j<group_child_total_list.size(); j++)
		    {
		      tokenizer<> tok(group_child_total_list[j]);
		      tokenizer<>::iterator beg=tok.begin();
		      if(*beg=="S")
		      {
		        int l=1;
		        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		        {
			      if(l!=1)
			      {
			        int child_in_total_list1;
			        std::stringstream str(*beg);
			        str>>child_in_total_list1;
			        if(child_in_total_list1>=current_child_no)
			        {
					  if(undo_redo_child_number_vector[standing_position]==0)
		  			  {
						int check_flag=-1;
						for(int i=0; i<group_child_buffer1_no.size(); i++)
						{
							if(group_child_buffer1_no[i]==j)
							{
							  check_flag=i;
							}
						}
						if(check_flag==-1)
						{
						  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1+1);
					  	  total_arr="S,"+int_to_string_value;
						  group_child_total_list[j]=total_arr;
					    }
					  }
					  else
					  {
						int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1+1);
					  	total_arr="S,"+int_to_string_value;
						group_child_total_list[j]=total_arr;
					  }
			        }
			      }
			      l++;
		        }
		      }
		    }
		  }
		  if(undo_redo_child_number_vector[standing_position]!=0)
		  {
            for(int j=0; j<group_child_total_list.size(); j++)
            {
              tokenizer<> tok(group_child_total_list[j]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="G")
              {
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;		
                  if(child_in_total_list>=undo_redo_child_number_vector[standing_position])
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list+1);
                  else
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
                  if(l==2)
                  total_arr="G,"+int_to_string_value;
                  else
                  total_arr=total_arr+","+int_to_string_value;
                  }
                  l++;
                }
                group_child_total_list[j]=total_arr;
              }
            }
		  }
		  if(undo_redo_child_number_vector[standing_position]!=0)
		  {
		  group_child_total_list.insert(group_child_total_list.begin()+undo_redo_child_number_vector[standing_position],undo_redo_tag_vector[standing_position]);
		  group_child_buffer1_no.push_back(undo_redo_child_number_vector[standing_position]);
		  standing_position--;
		  }
		}
		else
		  break;
	  }
	  standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="MultiDeleteStarts")
		{
		  int to_push_child_num=undo_redo_child_number_vector[standing_position];
		  int buffer=to_push_child_num-1;
		  if(buffer>=xml_scene_overall_tag.size())
			xml_scene_overall_tag.push_back(undo_redo_tag_vector[standing_position]);
		  else
	  		xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+to_push_child_num-1,undo_redo_tag_vector[standing_position]);
		  standing_position--;
		}
		else
		  break;
	  }
	  group_child_buffer1_no.clear();
	}
	else if(undo_redo_delete_status_vector[standing_position]==8)	//For Copy Paste
	{
	  if(undo_redo_tag_vector[standing_position]=="CopyPasteEnds")
	    standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="GroupValues")
		{
		  group_child_total_list.erase(group_child_total_list.begin()+undo_redo_child_number_vector[standing_position]);
		  standing_position--;
		}
		else
		  break;
	  }
	  standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="CopyPasteStarts")
		{
          xml_scene_overall_tag.pop_back();
		  standing_position--;
		}
		else
		  break;
	  }
	}
	else if(undo_redo_delete_status_vector[standing_position]==7)	//For Clear Window
	{
	  if(undo_redo_tag_vector[standing_position]=="ClearWindowEnds")
	    standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="GroupValues")
		{
		  group_child_total_list.push_back(undo_redo_tag_vector[standing_position]);
		  standing_position--;
		}
		else
		  break;
	  }
	  standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="ClearWindowStarts")
		{
          xml_scene_overall_tag.push_back(undo_redo_tag_vector[standing_position]);
		  standing_position--;
		}
		else
		  break;
	  }
	}
	else if(undo_redo_delete_status_vector[standing_position]==6)	//For group Delete
	{
	  if(undo_redo_tag_vector[standing_position]=="GroupDeleteEnds")
	    standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="TagValues")
		{
		  int to_push_child_num=undo_redo_child_number_vector[standing_position];
		  int buffer=to_push_child_num-1;
		  if(buffer>=xml_scene_overall_tag.size())
			xml_scene_overall_tag.push_back(undo_redo_tag_vector[standing_position]);
		  else
	  		xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+to_push_child_num-1,undo_redo_tag_vector[standing_position]);
		  standing_position--;
		}
		else
		  break;
	  }
	  standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="GroupDeleteStarts")
		{
		  if(group_child_total_list.size()==0)
			group_child_total_list.push_back("Group Vector");

	      Glib::ustring int_to_string_value;
	      std::string total_arr;
          tokenizer<> tok(undo_redo_tag_vector[standing_position]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
	        int child_in_total_list;
	        int l=1;
	        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
	        {
	          if(l!=1)
	          {
			    std::stringstream str(*beg);
			    str>>child_in_total_list;
			  }
			  l++;
			}
			for(int j=0; j<group_child_total_list.size(); j++)
			{
			  tokenizer<> tok(group_child_total_list[j]);
			  tokenizer<>::iterator beg=tok.begin();
			  if(*beg=="S")
			  {
			    int l=1;
			    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			    {
				  if(l!=1)
				  {
				    int child_in_total_list1;
				    std::stringstream str(*beg);
				    str>>child_in_total_list1;
				    if(child_in_total_list1>=child_in_total_list)
				    {
					  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1+1);
					  total_arr="S,"+int_to_string_value;
					  group_child_total_list[j]=total_arr;			
				    }
				  }
				  l++;
			    }
			  }
			}
		  }
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="G")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;		
                  if(child_in_total_list>=undo_redo_child_number_vector[standing_position])
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list+1);
                  else
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
                  if(l==2)
                  total_arr="G,"+int_to_string_value;
                  else
                  total_arr=total_arr+","+int_to_string_value;
                }
                l++;
              }
              group_child_total_list[j]=total_arr;
            }
          }
		  group_child_total_list.insert(group_child_total_list.begin()+undo_redo_child_number_vector[standing_position],undo_redo_tag_vector[standing_position]);
		  standing_position--;
		}
		else
		  break;
	  }
	}
	else if(undo_redo_delete_status_vector[standing_position]==5)	//For group properties change
	{
	  if(undo_redo_tag_vector[standing_position]=="GroupPropertyEnds")
	    standing_position--;
	  for(int i=standing_position; i>=0; i--)
	  {
		if(undo_redo_tag_vector[i]!="GroupPropertyStarts")
		{
		  int changed_child_number = undo_redo_child_number_vector[standing_position];
	  	  int position_number = undo_redo_position_vector[standing_position];
		  if(changed_child_number!=-1)
		  {		  
		  xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_child_number-1);
		  xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+changed_child_number-1,undo_redo_tag_vector[position_number]);
		  standing_position--;
		  }
		  else
		  standing_position--;
		}
		else
		  break;
	  }
	}
	else if(undo_redo_delete_status_vector[standing_position]==4)	//For Ungroup
	{
	  group_child_total_list.insert(group_child_total_list.begin()+undo_redo_child_number_vector[standing_position],undo_redo_tag_vector[standing_position]);
	}
	else if(undo_redo_delete_status_vector[standing_position]==3)	//For group
	{
	  group_child_total_list.erase(group_child_total_list.begin()+undo_redo_child_number_vector[standing_position]);
	}
	else if(undo_redo_delete_status_vector[standing_position]==2)	//For Single Delete
	{
	  int to_push_child_num=undo_redo_child_number_vector[standing_position];
	  int buffer=to_push_child_num-1;
	  if(buffer>=xml_scene_overall_tag.size())
	    xml_scene_overall_tag.push_back(undo_redo_tag_vector[standing_position]);
      else
  		xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+to_push_child_num-1,undo_redo_tag_vector[standing_position]);
	}
	else if(undo_redo_delete_status_vector[standing_position]==1)	//For Single properties
	{
	  int changed_child_number = undo_redo_child_number_vector[standing_position];
	  int position_number = undo_redo_position_vector[standing_position];
	  if(changed_child_number==xml_scene_overall_tag.size())
	  {
		xml_scene_overall_tag.pop_back();
		xml_scene_overall_tag.push_back(undo_redo_tag_vector[position_number]);
	  }
	  else
	  {
		xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_child_number-1);
		xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+changed_child_number-1,undo_redo_tag_vector[position_number]);
	  }
	}
	else if(undo_redo_delete_status_vector[standing_position]==0)	//For Drawings
	{
	  xml_scene_overall_tag.pop_back();
	}

	undo_status=1;
    undo_redo_buffer_for_group.clear();
	undo_redo_buffer_for_group = group_child_total_list;

	if(undo_redo_delete_status_vector[standing_position]!=3)
	{
	image_eraser_undo_status = 1;
	update_tag_values();
	show_selected_thumbnail_contents_in_window();
	}

	group_child_total_list.clear();
	group_child_total_list = undo_redo_buffer_for_group;
	undo_redo_buffer_for_group.clear();	  
	undo_status=0;

	standing_position=standing_position-1;
	undo_count++;

  }
  else
  {
	undo_status=0;
  }
}
//undo-redo-code-ends here
//undo-redo-code-ends here

}

void KalanjiyamWindow::edit_redo()
{
//undo-redo-code-starts here
//undo-redo-code-starts here
  if(undo_redo_tag_vector.size()>0)
  {
	if(undo_count>0)
	{
	  standing_position=standing_position+1;
	  int changed_child_number = undo_redo_child_number_vector[standing_position];

	  if(undo_redo_delete_status_vector[standing_position]==9)	//For Multi Delete
	  {
	    if(undo_redo_tag_vector[standing_position]=="MultiDeleteStarts")
			standing_position++;
		for(int i=standing_position; i<undo_redo_tag_vector.size(); i++)
		{
		  if(undo_redo_tag_vector[i]!="GroupVectorValues")
		  {
			 xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+undo_redo_child_number_vector[i]-1);
			 standing_position++;
		  }
		  else
			 break;
		}
		standing_position++;
		Glib::ustring int_to_string_value;
		std::string total_arr;
		for(int i=standing_position; i<undo_redo_tag_vector.size(); i++)
		{
		  if(undo_redo_tag_vector[i]!="MultiDeleteEnds")
		  {
		    int removing_child;
		    tokenizer<> tok(undo_redo_tag_vector[i]);
		    tokenizer<>::iterator beg=tok.begin();
		    if(*beg=="S")// && undo_redo_child_number_vector[standing_position]!=0)
		    {	
			  int l=1;
			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
			    if(l!=1)
			    {
			    std::stringstream str(*beg);
			    str>>removing_child;
			    }
			    l++;	
			  }
			  for(int j=0; j<group_child_total_list.size(); j++)
			  {
			    tokenizer<> tok(group_child_total_list[j]);
			    tokenizer<>::iterator beg=tok.begin();
			    if(*beg=="S")
			    {
				  int l=1;
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
				    if(l!=1)
				    {
					  int child_in_total_list1;
					  std::stringstream str(*beg);
					  str>>child_in_total_list1;
					  if(child_in_total_list1>=removing_child)
					  {
					    int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1-1);
					    total_arr="S,"+int_to_string_value;
					    group_child_total_list[j]=total_arr;			
					  }
				    }
				    l++;
				  }
			    }
			  }
		    }
			if(undo_redo_child_number_vector[standing_position]!=0)
	        group_child_total_list[undo_redo_child_number_vector[i]]="Empty";
		    standing_position++;
		  }
		  else
		    break;
		}
		for(int i=group_child_total_list.size()-1; i>=0; i--)
		{
		  if(group_child_total_list[i]=="Empty")
		  {
		    for(int j=0; j<group_child_total_list.size(); j++)
		    {
		      tokenizer<> tok(group_child_total_list[j]);
		      tokenizer<>::iterator beg=tok.begin();
		      if(*beg=="G")
		      {
		        int l=1;
		        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		        {
		          if(l!=1)
		          {
		            int child_in_total_list;
		            std::stringstream str(*beg);
		            str>>child_in_total_list;		
		            if(child_in_total_list>=i)
		            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
		            else
		            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
		            if(l==2)
		            total_arr="G,"+int_to_string_value;
		            else
		            total_arr=total_arr+","+int_to_string_value;
		          }
		          l++;
		        }
		        group_child_total_list[j]=total_arr;
		      }
		    }
		  }
		}
		group_child_total_list_buffer.clear();
		group_child_total_list_buffer = group_child_total_list;
		group_child_total_list.clear();
		for(int i=0; i<group_child_total_list_buffer.size(); i++)
		{	
		  if(group_child_total_list_buffer[i]!="Empty")
		  {
		  group_child_total_list.push_back(group_child_total_list_buffer[i]);
		  }
		}
		group_child_total_list_buffer.clear();
	  }
	  else  if(undo_redo_delete_status_vector[standing_position]==8)	//For Copy Paste
	  {
		if(undo_redo_tag_vector[standing_position]=="CopyPasteStarts")
		  standing_position++;
		for(int i=standing_position; i<undo_redo_delete_status_vector.size(); i++)
		{
		  if(undo_redo_tag_vector[i]!="GroupValues")
		  {
			xml_scene_overall_tag.push_back(undo_redo_tag_vector[standing_position]);
			standing_position++; 
		  }
		  else
		    break;
		}
	    standing_position++;
	    for(int i=standing_position; i<undo_redo_tag_vector.size(); i++)
	    {
		  if(undo_redo_tag_vector[i]!="CopyPasteEnds")
		  {
            group_child_total_list.push_back(undo_redo_tag_vector[standing_position]);
		    standing_position++;
		  }
		  else
		    break;
	    }
	  }
	  else if(undo_redo_delete_status_vector[standing_position]==7)	//For Clear Window	
	  {
		if(undo_redo_tag_vector[standing_position]=="ClearWindowStarts")
		  standing_position++;
		for(int i=standing_position; i<undo_redo_delete_status_vector.size(); i++)
		{
		  if(undo_redo_tag_vector[i]!="GroupValues")
		  {
			int redo_val=undo_redo_child_number_vector[i]-1;
			xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+redo_val);
			standing_position++; 
		  }
		  else
		    break;
		}
	    standing_position++;
	    for(int i=standing_position; i<undo_redo_tag_vector.size(); i++)
	    {
		  if(undo_redo_tag_vector[i]!="ClearWindowEnds")
		  {
            group_child_total_list.pop_back();
		    standing_position++;
		  }
		  else
		    break;
	    }
	  }
	  else if(undo_redo_delete_status_vector[standing_position]==6)	//For group Delete
	  {
		if(undo_redo_tag_vector[standing_position]=="GroupDeleteStarts")
		  standing_position++;
		Glib::ustring int_to_string_value;
		std::string total_arr;
		for(int i=standing_position; i<undo_redo_tag_vector.size(); i++)
		{
		  if(undo_redo_tag_vector[i]!="TagValues")
		  {
		    int removing_child;
		    tokenizer<> tok(group_child_total_list[undo_redo_child_number_vector[i]]);
		    tokenizer<>::iterator beg=tok.begin();
		    if(*beg=="S")
		    {	
			  int l=1;
			  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			  {
			    if(l!=1)
			    {
			    std::stringstream str(*beg);
			    str>>removing_child;
			    }
			    l++;	
			  }
			  for(int j=0; j<group_child_total_list.size(); j++)
			  {
			    tokenizer<> tok(group_child_total_list[j]);
			    tokenizer<>::iterator beg=tok.begin();
			    if(*beg=="S")
			    {
				  int l=1;
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
				    if(l!=1)
				    {
					  int child_in_total_list1;
					  std::stringstream str(*beg);
					  str>>child_in_total_list1;
					  if(child_in_total_list1>=removing_child)
					  {
					    int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1-1);
					    total_arr="S,"+int_to_string_value;
					    group_child_total_list[j]=total_arr;			
					  }
				    }
				    l++;
				  }
			    }
			  }
		    }
		    group_child_total_list[undo_redo_child_number_vector[i]]="Empty";
		    standing_position++;
		  }
		  else
		    break;
		}
		for(int i=group_child_total_list.size()-1; i>=0; i--)
		{
		  if(group_child_total_list[i]=="Empty")
		  {
		    for(int j=0; j<group_child_total_list.size(); j++)
		    {
		      tokenizer<> tok(group_child_total_list[j]);
		      tokenizer<>::iterator beg=tok.begin();
		      if(*beg=="G")
		      {
		        int l=1;
		        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		        {
		          if(l!=1)
		          {
		            int child_in_total_list;
		            std::stringstream str(*beg);
		            str>>child_in_total_list;		
		            if(child_in_total_list>=i)
		            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
		            else
		            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
		            if(l==2)
		            total_arr="G,"+int_to_string_value;
		            else
		            total_arr=total_arr+","+int_to_string_value;
		          }
		          l++;
		        }
		        group_child_total_list[j]=total_arr;
		      }
		    }
		  }
		}
		group_child_total_list_buffer.clear();
		group_child_total_list_buffer = group_child_total_list;
		group_child_total_list.clear();
		for(int i=0; i<group_child_total_list_buffer.size(); i++)
		{	
		  if(group_child_total_list_buffer[i]!="Empty")
		  {
		  group_child_total_list.push_back(group_child_total_list_buffer[i]);
		  }
		}
		group_child_total_list_buffer.clear();
		standing_position++;
		for(int i=standing_position; i<undo_redo_tag_vector.size(); i++)
		{
		  if(undo_redo_tag_vector[i]!="GroupDeleteEnds")
		  {
			xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+undo_redo_child_number_vector[i]-1);
			standing_position++;
		  }
		  else
			break;
		}
	  }
	  else if(undo_redo_delete_status_vector[standing_position]==5)	//For group properties change
	  {
		if(undo_redo_tag_vector[standing_position]=="GroupPropertyStarts")
		  standing_position++;
		for(int i=standing_position; i<undo_redo_delete_status_vector.size(); i++)
		{
		  if(undo_redo_tag_vector[i]!="GroupPropertyEnds")
		  {
			int changed_child_number = undo_redo_child_number_vector[standing_position];
		 	if(changed_child_number!=-1)
		 	{		  
			xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_child_number-1);
			xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+changed_child_number-1,undo_redo_tag_vector[standing_position]);
			standing_position++;
			}
			else
			standing_position++;
		  }
		  else
			break;
		}
	  }
	  else if(undo_redo_delete_status_vector[standing_position]==4)	//For Ungroup
	  {
		group_child_total_list.erase(group_child_total_list.begin()+undo_redo_child_number_vector[standing_position]);
	  }
	  else if(undo_redo_delete_status_vector[standing_position]==3)		//For Group
	  { 
		group_child_total_list.insert(group_child_total_list.begin()+undo_redo_child_number_vector[standing_position],undo_redo_tag_vector[standing_position]);
	  }
	  else if(undo_redo_delete_status_vector[standing_position]==2)	//For Single Delete
	  {
		xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_child_number-1);
	  }
	  else	//For drawings and single properties
	  {
		if(changed_child_number==xml_scene_overall_tag.size()+1)
		{
		  xml_scene_overall_tag.push_back(undo_redo_tag_vector[standing_position]);
		}
		else
		{
		  xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_child_number-1);
		  xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+changed_child_number-1,undo_redo_tag_vector[standing_position]);
		}
	  }


	  if(undo_redo_delete_status_vector[standing_position]!=3 && undo_redo_delete_status_vector[standing_position]!=4)
	  {
		undo_status=1;
		undo_redo_buffer_for_group.clear();
		undo_redo_buffer_for_group = group_child_total_list;

		update_tag_values();
		show_selected_thumbnail_contents_in_window();

		group_child_total_list.clear();
		group_child_total_list = undo_redo_buffer_for_group;
		undo_redo_buffer_for_group.clear();	  
		undo_status=0;
	  }
	  undo_count--;
	}
	else
	{
	  undo_status=0;
	}
  }
//undo-redo-code-ends here
//undo-redo-code-ends here
}

void KalanjiyamWindow::full_screen()
{
  pSbar->push("Screen mode switch-over tool clicked...");
  if(full_screen_mode==0)
  {
    phan->hide();
    if(mcanvas_show_flag==1)
      show_cursor(drawing_tool_number); 
    full_screen_mode = 1;
    kalanjiyaInfo_mode = 0;
    tKalanjiyaminfo->set_active(false);
  }
  else
  {
    phan->show();
    if(mcanvas_show_flag==1)
      show_cursor(drawing_tool_number); 
    full_screen_mode = 0;
    kalanjiyaInfo_mode = 1;
    tKalanjiyaminfo->set_active(true);
  }
}

void KalanjiyamWindow::show_thumbnail()
{
  pSbar->push("Show Thumbnail tool clicked...");
  phan->show();
  full_screen_mode==1;
  if(show_thumbnail_mode==0)
  {
    show_thumbnail_mode=1;	
    pNotebook->get_nth_page(1)->show();
    pNotebook->set_current_page(1);
  }
  else
  {
    show_thumbnail_mode=0;
    pNotebook->get_nth_page(1)->hide();
  }
}

void KalanjiyamWindow::file_open()
{
  if(file_open_confirm_flag==0 && mcanvas_show_flag==1)
  {
	  ConfirmStatus = 9;
	  Glib::ustring msg;
	  if (strcmp(active_file_name.c_str(), "" ) == 0)
	  {
	  msg = "                 File Not Yet Saved. \nDo You Want To Close the Current File... ?  ";
	  }
	  else
	  {
	  msg = "Do You Want To Close the Current File ?  ";
	  }
	  pConfirmLabel->set_text(msg.c_str());
	  pConfirmDialog->show();
  }
  else
  {
  file_open_confirm_flag=0;
  if(mcanvas_show_flag==0)
  {
  }
  group_var="";

  /*if (strcmp(active_file_name.c_str(), "" ) == 0)
  {*/
    Gtk::FileChooserDialog dialog("Please choose a file",
    Gtk::FILE_CHOOSER_ACTION_OPEN);
    dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
    dialog.add_button(Gtk::Stock::OPEN, Gtk::RESPONSE_OK);
    Gtk::FileFilter pngFilter;
    pngFilter.add_pattern ("*.kljm");
    pngFilter.add_pattern ("*.KLJM");
    pngFilter.set_name("Kalanjiyam files");
    dialog.add_filter(pngFilter);

    int result = dialog.run();
    int file_status = 1;
    pSbar->push("File Is Loading... Please Wait...");
    switch(result)
    {
      case(Gtk::RESPONSE_OK):
      {
		event1->set_visible(true);
		v_port8->set_visible(false);  
		//m_canvas.show();
		mcanvas_show_flag=1;
		pDialog->set_title("[New Document]   Kalanjiyam - 0.2");

		reset_window();
		on_description_save=1;
        xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin(),xml_kalanjiyam_overall_tag.end());
        std::string filename = dialog.get_filename();
        /*Xml Parsing Starts*/
        size_t found;	
        found=filename.find_last_of("/\\");
        active_folder_name = filename.substr(0,found);
        const char* open_file_name = filename.c_str();

		string currentfilenameis = filename.substr(found+1,filename.size());
		currentfilenameis = currentfilenameis+"   Kalanjiyam - 0.2";
		pDialog->set_title(currentfilenameis);

        string input_xml;
        string line;
        ifstream in(open_file_name);
        global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin(),global_scene_shot_number_list_vector.end());	

        std::string scene_total_value;	
        while(getline(in,line))
          input_xml += line;
        if(input_xml.length()==0)
        {
          file_status = 0;  
        }  
				//input_xml = Decrypt(input_xml);
				/**/
				
				/**/
        vector<char> xml_copy(input_xml.begin(), input_xml.end());
        xml_copy.push_back('\0');
        xml_document<> doc;
        try
        {
          doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
        }
        catch(rapidxml::parse_error &e)
        {
        file_status = 0;
        }
        if(file_status!=0)
        {
          xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
          xml_node<>* Scene = Kalanjiyam->first_node("Scene");
          xml_node<> * abc;
          while (Scene != NULL )
          {
            xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+1,xml_scene_overall_tag.end());
			group_child_total_list.clear();
            scene_total_value = "";
            for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
            {
              const char * test1 = abc->name();	
              if (strcmp(test1, "SceneNumber" ) == 0)
              {
              SceneNumber = abc->value();
              global_current_scene_number = atoi(SceneNumber.c_str());
              }	
              if (strcmp(test1, "ShotNumber" ) == 0)
              {
              ShotNumber = abc->value();
              global_current_shot_number = atoi(ShotNumber.c_str());
              }
              if (strcmp(test1, "ShotType" ) == 0)
              {
              ShotType=abc->value();
              scene_total_value=scene_total_value+"\n"+"<ShotType>"+ShotType+"</ShotType>";
              }
              if (strcmp(test1, "TotalFrames" ) == 0)
              {
              TotalFrames=abc->value();
              scene_total_value=scene_total_value+"\n"+"<TotalFrames>"+TotalFrames+"</TotalFrames>";
              }
              if (strcmp(test1, "SceneTitle" ) == 0)
              {
              SceneTitle=abc->value();
              scene_total_value=scene_total_value+"\n"+"<SceneTitle>"+SceneTitle+"</SceneTitle>";
              }
              if (strcmp(test1, "Dialogue" ) == 0)
              {
              Dialogue=abc->value();
              scene_total_value=scene_total_value+"\n"+"<Dialogue>"+Dialogue+"</Dialogue>";
              }
              if (strcmp(test1, "ActionNotes" ) == 0)
              {
              ActionNotes=abc->value();
              scene_total_value=scene_total_value+"\n"+"<ActionNotes>"+ActionNotes+"</ActionNotes>";
              }
              if (strcmp(test1, "AudioNotes" ) == 0)
              {
              AudioNotes=abc->value();
              scene_total_value=scene_total_value+"\n"+"<AudioNotes>"+AudioNotes+"</AudioNotes>";
              }
              if(global_current_scene_number==1 && global_current_shot_number==1)
              {
                if (strcmp(test1, "ProjectName" ) == 0)
                {  
                pProjectName->set_text(abc->value());
                }
                if (strcmp(test1, "ProjectClient" ) == 0)
                {  
                pProjectClient->set_text(abc->value());
                }
                if (strcmp(test1, "ScreenType" ) == 0)
                {  
                preference_m_Combo.set_active_text(abc->value());
                }       
                if (strcmp(test1, "CopyRights" ) == 0)
                {  
                pProjectCopy->set_text(abc->value());            
                }                             
              }
              open_node_name="";
              for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
              {
                const char * node_name = abc->name();
                const char * node_value = abc->value();		
                open_node_name = node_name;
                open_node_value = node_value;
                const char * attribute_name = attribute->name();	
                const char * attribute_value = attribute->value();	
                open_attr_name = attribute_name;
                open_attr_value = attribute_value;
                find_current_node_to_get_attribute_value(open_node_name);
              }
              call_function_according_to_node_name(open_node_name); 
            }
            for(int i=1; i<xml_scene_overall_tag.size(); i++)
            {
            scene_total_value=scene_total_value+"\n"+xml_scene_overall_tag[i];
            }
            Glib::ustring group_tag = create_xml_for_group();
            scene_total_value=scene_total_value+"\n"+ group_tag +"</Scene>";
            xml_kalanjiyam_overall_tag.push_back(scene_total_value);
            Glib::ustring combine_cur_scene_shot_number = boost::lexical_cast<std::string>(global_current_scene_number) + "," + boost::lexical_cast<std::string>(global_current_shot_number);
            global_scene_shot_number_list_vector.push_back(combine_cur_scene_shot_number);
            show_selected_thumbnail_contents_in_window();
            to_png();
            Scene = Scene->next_sibling("Scene");	
            global_total_panels_in_thumbnail= global_total_panels_in_thumbnail+1;
          }
          global_total_panels_in_thumbnail= global_total_panels_in_thumbnail-1;	
          global_current_scene_number = 1;
          global_current_shot_number = 1;
          create_thumbnail_window();

          active_file_name = filename;
          std::string status = "File Opened From : " + filename;
          pSbar->push(status);
          break;
        }
        else
        {
        pInfoLabel->set_text("File Is Invalid or Corrupted...");
        pInfoDialog->show();
        xml_scene_overall_tag.push_back("0");
        global_scene_shot_number_list_vector.push_back("1,1");
        global_temp_scene_xml = create_temp_scene_xml();
        xml_kalanjiyam_overall_tag.push_back(global_temp_scene_xml);	 //For save. That is, by default for (1,1) xml should be created. add scene/add shot creates xml also.
        my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
        my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
        }
      }  
      case(Gtk::RESPONSE_CANCEL):
      {
      pSbar->push("File Open Canceled...");
      break;
      }
      default:
      {
      break;
      }
    }
    open_global_fillcolor_hex = "#FFFFFF";		
    open_global_strokecolor_hex = "#000000";	
    if(file_status!=0)
    {  
    on_selection_changed();	
    }
  on_description_save=0;
  }
}



std::string KalanjiyamWindow:: Decrypt(std::string strTarget)
{
	int len = strTarget.length();
	char a;
	std::string strFinal(strTarget);

	for (int i = 0; i <= (len-1); i++)
	{
		a = strTarget.at(i);
		int b = (int)a;
		b -= 2;

		a = (char)b;
		strFinal.insert(i, 1, a);
	}
	std::string strDecrypted(strFinal, 0, len);
	/**/
	std::string modified_data = strDecrypted;
	boost::replace_all(modified_data, "♦30", "> Text </Text>");
	boost::replace_all(modified_data, "♦29", "font=");
	boost::replace_all(modified_data, "♦28", "<Text data=");
	boost::replace_all(modified_data, "♦27", "> Image </Image>");
	boost::replace_all(modified_data, "♦26", "data=");
	boost::replace_all(modified_data, "♦25", "<Image xposition=");
	boost::replace_all(modified_data, "♦24", "> Arrow </Path>");
	boost::replace_all(modified_data, "♦23", "> Triangle </Path>");
	boost::replace_all(modified_data, "♦22", "> Star </Path>");
	boost::replace_all(modified_data, "♦21", "> Brush </Path>");
	boost::replace_all(modified_data, "♦20", "> Curve </Path>");
	boost::replace_all(modified_data, "♦19", "> Polyline </Path>");
	boost::replace_all(modified_data, "♦18", "> Star1 </Path>");
	boost::replace_all(modified_data, "♦17", "<Path data=");
	boost::replace_all(modified_data, "♦16", "> Line </Line>");
	boost::replace_all(modified_data, "♦15", "<Line x1=");
	boost::replace_all(modified_data, "♦14", "> Ellipse </Ellipse>");
	boost::replace_all(modified_data, "♦13", "centery=");
	boost::replace_all(modified_data, "♦12", "<Ellipse centerx=");
	boost::replace_all(modified_data, "♦11", "> Rectangle </Rectangle>");
	boost::replace_all(modified_data, "♦10", "yposition=");
	boost::replace_all(modified_data, "♦9", "xposition=");
	boost::replace_all(modified_data, "♦8", "inewidth=");
	boost::replace_all(modified_data, "♦7", "fillcolor=");
	boost::replace_all(modified_data, "♦6", "strokecolor=");
	boost::replace_all(modified_data, "♦5", "yradius=");
	boost::replace_all(modified_data, "♦4", "xradius=");
	boost::replace_all(modified_data, "♦3", "height=");
	boost::replace_all(modified_data, "♦2", "width=");
	boost::replace_all(modified_data, "♦1", "<Rectangle x=");

	boost::replace_all(modified_data, "♣8", "</CopyRights>");
	boost::replace_all(modified_data, "♣7", "<CopyRights>");
	boost::replace_all(modified_data, "♣6", "</ScreenType>");
	boost::replace_all(modified_data, "♣5", "<ScreenType>");
	boost::replace_all(modified_data, "♣4", "</ProjectClient>");
	boost::replace_all(modified_data, "♣3", "<ProjectClient>");
	boost::replace_all(modified_data, "♣2", "</ProjectName>");
	boost::replace_all(modified_data, "♣1", "<ProjectName>");

	boost::replace_all(modified_data, "♠20", "</Kalanjiyam>");
	boost::replace_all(modified_data, "♠19", "</Scene>");
	boost::replace_all(modified_data, "♠18", "</AudioNotes>");
	boost::replace_all(modified_data, "♠17", "<AudioNotes>");
	boost::replace_all(modified_data, "♠16", "</ActionNotes>");
	boost::replace_all(modified_data, "♠15", "<ActionNotes>");
	boost::replace_all(modified_data, "♠14", "</Dialogue>");
	boost::replace_all(modified_data, "♠13", "<Dialogue>");
	boost::replace_all(modified_data, "♠12", "</SceneTitle>");
	boost::replace_all(modified_data, "♠11", "<SceneTitle>");
	boost::replace_all(modified_data, "♠10", "</TotalFrames>");
	boost::replace_all(modified_data, "♠9", "<TotalFrames>");
	boost::replace_all(modified_data, "♠8", "</ShotType>");
	boost::replace_all(modified_data, "♠7", "<ShotType>");
	boost::replace_all(modified_data, "♠6", "</ShotNumber>");
	boost::replace_all(modified_data, "♠5", "<ShotNumber>");
	boost::replace_all(modified_data, "♠4", "</SceneNumber>");
	boost::replace_all(modified_data, "♠3", "<SceneNumber>");
	boost::replace_all(modified_data, "♠2", "<Scene>");
	boost::replace_all(modified_data, "♠1", "<Kalanjiyam>"); 
	strDecrypted = modified_data;
	/**/
	return strDecrypted;
}

void KalanjiyamWindow::file_save()
{

  group_var="";
  std::string filepath;	
  Glib::ustring filename;
  const char* temp_var;
  if (strcmp(active_file_name.c_str(), "" ) == 0)
  {
    Gtk::FileChooserDialog dialog("Save Kalanjiyam",
    Gtk::FILE_CHOOSER_ACTION_SAVE);
    dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
    dialog.add_button(Gtk::Stock::SAVE, Gtk::RESPONSE_OK);
    dialog.set_current_name("Kalanjiyam.kljm");
    Gtk::FileFilter pngFilter;
    pngFilter.add_pattern ("*.kljm");
    pngFilter.add_pattern ("*.KLJM");
    pngFilter.set_name("Kalanjiyam files");
    dialog.add_filter(pngFilter);

    int result = dialog.run();
    if(result==Gtk::RESPONSE_OK)
    {
      filepath = dialog.get_filename();
      
      string fileName = filepath;
      size_t position = fileName.find(".");
      string extractName = (string::npos == position)? fileName : fileName.substr(0, position);
      active_file_name = extractName + ".kljm";  
	  Glib::locale_from_utf8(active_file_name);
	  temp_var = active_file_name.c_str();
	  chmod(temp_var, 0777);

      /*File Existance Check Begins*/
      std::string Kalanjiyam_file_folder_check = active_file_name;
      if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
      {
        Glib::ustring msg = "File already exists. Do you want to replace it ?  ";
        pConfirmLabel->set_text(msg.c_str());
        ConfirmStatus = 3;

        pConfirmDialog->show();
	    flag_for_replace=1;
      }
        if(cancel_flag==1 && flag_for_replace==1)
	    cancel_flag=0;
		else if((flag_for_replace==0) || (ok_flag==1))
		{
		 	size_t found;	
		 	found=filepath.find_last_of("/\\");
		  	active_folder_name = filepath.substr(0,found);

			string currentfilenameis = filepath.substr(found+1,filepath.size());
		    currentfilenameis = currentfilenameis+"   Kalanjiyam - 0.2";
		    pDialog->set_title(currentfilenameis);

		  	to_png();
		  	file_existance_check_for_save();
			ok_flag=0;
			flag_for_replace=0;
		}
      /*File Existance Ends*/
    }
    else
    {
    pSbar->push("File Save Cancelled...");
    active_file_name = "";
    active_folder_name = "";
    }
  }
  else
  {
  filename = active_file_name;
  Glib::locale_from_utf8(filename);
  temp_var = filename.c_str();
  chmod(temp_var, 0777);
  to_png();
  file_existance_check_for_save();
  }

}

void KalanjiyamWindow::file_existance_check_for_save()
{
  if (strcmp(active_file_name.c_str(), "" ) != 0)
  {
    std::string status = "File Saved into : " + active_file_name;
    pSbar->push(status);
    Glib::ustring filename = active_file_name;
    filename = active_file_name;
    save_file_name = filename.c_str();
    Glib::ustring total_xml = combine_kljm_file_contents();
    std::string strTarget = total_xml;
    //total_xml = Encrypt(strTarget);
    std::ofstream myfile (save_file_name);

    if (myfile.is_open())
    {
    myfile <<total_xml;
    myfile.close();
    }
  }
 string filename = active_file_name;
 Glib::locale_from_utf8(filename);
 const char *temp_var = filename.c_str();
 chmod(temp_var, 0444);
}


std::string KalanjiyamWindow::combine_kljm_file_contents()
{
  /*Getting Scene Values begins*/
    Glib::ustring XmlVersion = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
    Glib::ustring OpenTag_Kalanjiyam = "\n<Kalanjiyam>";
    Glib::ustring CloseTag_Kalanjiyam = "\n</Kalanjiyam>";
    Glib::ustring OpenTag_Scene = "\n\t<Scene>";
    Glib::ustring CloseTag_Scene = "\n\t</Scene>";
    
    Glib::ustring total_xml = "";
    global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin();
    for (xml_kalanjiyam_overall_tag_it = xml_kalanjiyam_overall_tag.begin(); xml_kalanjiyam_overall_tag_it != xml_kalanjiyam_overall_tag.end(); ++xml_kalanjiyam_overall_tag_it)
    {
      std::string scene_and_shot_number=*global_scene_shot_number_list_vector_it;
      tokenizer<> tok(scene_and_shot_number);
      int count=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(count==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        count++;
      }
      total_xml = total_xml + OpenTag_Scene + "\n\t\t<SceneNumber>" + SceneNo + "</SceneNumber>" + "\n\t\t<ShotNumber>" + ShotNo + "</ShotNumber>" + (*xml_kalanjiyam_overall_tag_it);
      ++global_scene_shot_number_list_vector_it;
    }
    total_xml = XmlVersion + OpenTag_Kalanjiyam + total_xml + CloseTag_Kalanjiyam;
    return total_xml;
}

std::string KalanjiyamWindow::Encrypt(std::string &strTarget)
{
/**/
	std::string modified_data = strTarget;
  boost::replace_all(modified_data, "<Kalanjiyam>", "♠1"); 
  boost::replace_all(modified_data, "<Scene>", "♠2");
  boost::replace_all(modified_data, "<SceneNumber>", "♠3");
  boost::replace_all(modified_data, "</SceneNumber>", "♠4");
  boost::replace_all(modified_data, "<ShotNumber>", "♠5");
  boost::replace_all(modified_data, "</ShotNumber>", "♠6");
  boost::replace_all(modified_data, "<ShotType>", "♠7");
  boost::replace_all(modified_data, "</ShotType>", "♠8");
  boost::replace_all(modified_data, "<TotalFrames>", "♠9");
  boost::replace_all(modified_data, "</TotalFrames>", "♠10");
  boost::replace_all(modified_data, "<SceneTitle>", "♠11");
  boost::replace_all(modified_data, "</SceneTitle>", "♠12");
  boost::replace_all(modified_data, "<Dialogue>", "♠13");
  boost::replace_all(modified_data, "</Dialogue>", "♠14");
  boost::replace_all(modified_data, "<ActionNotes>", "♠15");  
  boost::replace_all(modified_data, "</ActionNotes>", "♠16");
  boost::replace_all(modified_data, "<AudioNotes>", "♠17");
  boost::replace_all(modified_data, "</AudioNotes>", "♠18");
  boost::replace_all(modified_data, "</Scene>", "♠19");
  boost::replace_all(modified_data, "</Kalanjiyam>", "♠20");

  boost::replace_all(modified_data, "<ProjectName>", "♣1");
  boost::replace_all(modified_data, "</ProjectName>", "♣2"); 
  boost::replace_all(modified_data, "<ProjectClient>", "♣3");
  boost::replace_all(modified_data, "</ProjectClient>", "♣4");
  boost::replace_all(modified_data, "<ScreenType>", "♣5");
  boost::replace_all(modified_data, "</ScreenType>", "♣6");
  boost::replace_all(modified_data, "<CopyRights>", "♣7"); 
  boost::replace_all(modified_data, "</CopyRights>", "♣8");

  boost::replace_all(modified_data, "<Rectangle x=", "♦1");
  boost::replace_all(modified_data, "width=", "♦2");
  boost::replace_all(modified_data, "height=", "♦3");
  boost::replace_all(modified_data, "xradius=", "♦4");
  boost::replace_all(modified_data, "yradius=", "♦5");
  boost::replace_all(modified_data, "strokecolor=", "♦6");
  boost::replace_all(modified_data, "fillcolor=", "♦7");
  boost::replace_all(modified_data, "inewidth=", "♦8");
  boost::replace_all(modified_data, "xposition=", "♦9");
  boost::replace_all(modified_data, "yposition=", "♦10");
  boost::replace_all(modified_data, "> Rectangle </Rectangle>", "♦11");
  boost::replace_all(modified_data, "<Ellipse centerx=", "♦12");
  boost::replace_all(modified_data, "centery=", "♦13");
  boost::replace_all(modified_data, "> Ellipse </Ellipse>", "♦14");
  boost::replace_all(modified_data, "<Line x1=", "♦15");
  boost::replace_all(modified_data, "> Line </Line>", "♦16");
  boost::replace_all(modified_data, "<Path data=", "♦17");
  boost::replace_all(modified_data, "> Star1 </Path>", "♦18");
  boost::replace_all(modified_data, "> Polyline </Path>", "♦19");
  boost::replace_all(modified_data, "> Curve </Path>", "♦20");
  boost::replace_all(modified_data, "> Brush </Path>", "♦21");
  boost::replace_all(modified_data, "> Star </Path>", "♦22");
  boost::replace_all(modified_data, "> Triangle </Path>", "♦23");
  boost::replace_all(modified_data, "> Arrow </Path>", "♦24");
  boost::replace_all(modified_data, "<Image xposition=", "♦25");
  boost::replace_all(modified_data, "data=", "♦26");
  boost::replace_all(modified_data, "> Image </Image>", "♦27");
  boost::replace_all(modified_data, "<Text data=", "♦28");
  boost::replace_all(modified_data, "font=", "♦29");
  boost::replace_all(modified_data, "> Text </Text>", "♦30");    
  strTarget = modified_data;
	/**/
	int len = strTarget.length();
	char a;
	std::string strFinal(strTarget);

	for (int i = 0; i <= (len-1); i++)
	{
		a = strTarget.at(i); 
		int b = (int)a;
		b += 2;
		if (b > 254) { b = 254; }
		a = (char)b; 
		strFinal.insert(i , 1, a);
	}
	std::string strEncrypted(strFinal, 0, len);
	return strEncrypted;
}

void KalanjiyamWindow::file_saveAs()
{ 
  group_var="";
  std::string filepath;	
  Glib::ustring filename;
  const char* temp_var;
  try
  {
    if (strcmp(active_file_name.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
      Gtk::FileChooserDialog dialog("Save As Kalanjiyam",
      Gtk::FILE_CHOOSER_ACTION_SAVE);
      dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
      dialog.add_button(Gtk::Stock::SAVE_AS, Gtk::RESPONSE_OK);
      dialog.set_current_name("KalanjiyamBackUp.kljm");
      Gtk::FileFilter pngFilter;
      pngFilter.add_pattern ("*.kljm");
      pngFilter.add_pattern ("*.KLJM");
      pngFilter.set_name("Kalanjiyam files");
      dialog.add_filter(pngFilter);
      int result = dialog.run();
	  if(result==Gtk::RESPONSE_OK)
      {

		  filepath = dialog.get_filename();
		  string fileName = filepath;
		  size_t position = fileName.find(".");
		  string extractName = (string::npos == position)? fileName : fileName.substr(0, position);
		  SaveAs_file_name = extractName + ".kljm";  
		  Glib::locale_from_utf8(SaveAs_file_name);
		  temp_var = SaveAs_file_name.c_str();
		  chmod(temp_var, 0777);
		  /*File Existance Check Begins*/
		  std::string Kalanjiyam_file_folder_check = SaveAs_file_name;
		  flag_for_replace = 0;
		  if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
		  {
			Glib::ustring msg = "File already exists. Do you want to replace it ?  ";
			pConfirmLabel->set_text(msg.c_str());
			ConfirmStatus = 4;

			pConfirmDialog->show();
			flag_for_replace=1;
			ok_flag=0;
		  }

		  if(cancel_flag==1 && flag_for_replace==1)
		  {
			cancel_flag=0;
			flag_for_replace=0;
		  }
		  else if((flag_for_replace==0) || (ok_flag==1))
		  {
		 	size_t found;	
		 	found=filepath.find_last_of("/\\");
		  	active_folder_name = filepath.substr(0,found);
		  	to_png();
		  	file_existance_check_for_saveAs();
			ok_flag=0;
			flag_for_replace=0;
		  }
      /*File Existance Ends*/
         }
        //}
		else
		{
       	pSbar->push("File Save As Cancelled...");
        SaveAs_file_name = "";
        }
  
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
}

void KalanjiyamWindow::file_existance_check_for_saveAs()
{
if (strcmp(SaveAs_file_name.c_str(), "" ) != 0)
  {
    std::string status = "File Saved into : " + SaveAs_file_name;
    pSbar->push(status);
    Glib::ustring filename = SaveAs_file_name;
    filename = SaveAs_file_name;
    save_file_name = filename.c_str();
    Glib::ustring total_xml = combine_kljm_file_contents();
    std::string strTarget = total_xml;
    //total_xml = Encrypt(strTarget);
    std::ofstream myfile (save_file_name);

    if (myfile.is_open())
    {
    myfile <<total_xml;
    myfile.close();
    }
  }
 /*string filename = SaveAs_file_name;
 Glib::locale_from_utf8(filename);
 const char *temp_var = filename.c_str();
 chmod(temp_var, 0444);*/
}

void KalanjiyamWindow::file_properties()
{
  group_var="";
  pPreferenceDialog->set_position(Gtk::WIN_POS_CENTER);
  pPreferenceDialog->show();
  pSbar->push("Property Window Clicked...");
}

void KalanjiyamWindow::file_properties_okay()
{
pPreferenceDialog->hide();
}


void KalanjiyamWindow::file_export_full()
{
try
  {
    if (strcmp(active_file_name.c_str(), "" ) != 0)
    {
      std::string filepath;	
      Glib::ustring filename;

 	  Gtk::FileChooserDialog dialog("Export PDF files",
      Gtk::FILE_CHOOSER_ACTION_SAVE);
      dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
      dialog.add_button(Gtk::Stock::SAVE, Gtk::RESPONSE_OK);
      dialog.set_current_name("file.pdf");
      Gtk::FileFilter pngFilter;
      pngFilter.add_pattern ("*.pdf");
      //pngFilter.add_pattern ("*.KLJM");
      pngFilter.set_name("Kalanjiyam PDF files");
      dialog.add_filter(pngFilter);

      int result = dialog.run();

	  if(result==Gtk::RESPONSE_OK)
      {
      filepath = dialog.get_filename();
      
      string fileName = filepath;
      size_t position = fileName.find(".");
      string extractName = (string::npos == position)? fileName : fileName.substr(0, position);
     // active_file_name = extractName + ".pdf";  
	  active_file_name1=extractName + ".pdf";  
	  active_file_name2=extractName + "1" +".pdf";  
	  active_file_name3=extractName + "2" +".pdf";  

	  Glib::locale_from_utf8(active_file_name1);
	  int pdf_file_existace_status = 0;
  	  int pdf_file_existace_status1 = 0;
  	  int pdf_file_existace_status2 = 0;

      /*File Existance Check Begins*/
      std::string Kalanjiyam_file_folder_check = active_file_name1;
      if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
      {
      pdf_file_existace_status = 1;
      }

      Kalanjiyam_file_folder_check = active_file_name2;
	  active_file_name2=Kalanjiyam_file_folder_check;
      if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
      {
      pdf_file_existace_status1 = 1;
      }
      
      Kalanjiyam_file_folder_check = active_file_name3;
	  active_file_name3=Kalanjiyam_file_folder_check;
      if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
      {
      pdf_file_existace_status2 = 1;
      }

	  flag_for_replace=0;
      if (pdf_file_existace_status==1 && pdf_file_existace_status1==1 && pdf_file_existace_status2==1)
      {
        Glib::ustring msg = "File already exists. Do you want to replace it ?  ";
        pConfirmLabel->set_text(msg.c_str());
        ConfirmStatus = 5;
        pConfirmDialog->show();
		flag_for_replace=1;
      }
        if(cancel_flag==1 && flag_for_replace==1)
		{
	    cancel_flag=0;
		flag_for_replace=0;
		}
		else if((flag_for_replace==0) || (ok_flag==1))
		{
       		file_export_to_pdf_full();
			ok_flag=0;
			flag_for_replace=0;
		}

      }
      else
      {
      //filename = active_file_name1;
      //file_export_to_pdf_full();
        pSbar->push("File Export Cancelled...");
        active_file_name1 = "";
        active_file_name2 = "";
        active_file_name3 = "";
      }
    }
    else
    {
    throw 1;
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
}

void KalanjiyamWindow::file_export_to_pdf_full()
{
  int scene_no = global_current_scene_number;
  int shot_no = global_current_shot_number;

for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
  {	
    tokenizer<> tok(global_scene_shot_number_list_vector[g]);
    int count=1;
    Glib::ustring first_value;
    Glib::ustring second_value;

    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(count==1)
      first_value=*beg;
      else
      second_value=*beg;
      count++;
    }
    global_current_scene_number=boost::lexical_cast<int>(first_value);
    global_current_shot_number=boost::lexical_cast<int>(second_value);
    show_selected_thumbnail_contents_in_window();
  }
  try
  {
    if (strcmp(active_file_name1.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    to_pdf1();
 	to_pdf2();
 	to_pdf3();
    std::string status = "File Has Been Exported";
    pSbar->push(status);
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
  global_current_scene_number = scene_no;
  global_current_shot_number= shot_no;

  Glib::ustring a1= boost::lexical_cast<std::string>(global_current_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(global_current_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf1[10];
  sprintf(buf1,"%s",char_a3);

  show_selected_thumbnail_contents_in_window();
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));

}

void KalanjiyamWindow::file_export()
{
 
  try
  {
    if (strcmp(active_file_name.c_str(), "" ) != 0)
    {
      std::string filepath;	
      Glib::ustring filename;

 	  Gtk::FileChooserDialog dialog("Export PDF files",
      Gtk::FILE_CHOOSER_ACTION_SAVE);
      dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
      dialog.add_button(Gtk::Stock::SAVE, Gtk::RESPONSE_OK);
      dialog.set_current_name("Kalanjiyam.pdf");
      Gtk::FileFilter pngFilter;
      pngFilter.add_pattern ("*.pdf");
      //pngFilter.add_pattern ("*.KLJM");
      pngFilter.set_name("Kalanjiyam PDF files");
      dialog.add_filter(pngFilter);

      int result = dialog.run();

	  if(result==Gtk::RESPONSE_OK)
      {
      filepath = dialog.get_filename();
      
      string fileName = filepath;
      size_t position = fileName.find(".");
      string extractName = (string::npos == position)? fileName : fileName.substr(0, position);
     // active_file_name = extractName + ".pdf";  
	  active_file_name1= extractName + ".pdf"; 
	  Glib::locale_from_utf8(active_file_name1);
	  int pdf_file_existace_status = 0;

      /*File Existance Check Begins*/
      std::string Kalanjiyam_file_folder_check = active_file_name1;
      if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
      {
      pdf_file_existace_status = 1;
 	 
      }
	  flag_for_replace=0;
      if (pdf_file_existace_status==1)
      {
        Glib::ustring msg = "File already exists. Do you want to replace it ?  ";
        pConfirmLabel->set_text(msg.c_str());
        ConfirmStatus = 6;
        pConfirmDialog->show();
        flag_for_replace=1;
      }
      
        if(cancel_flag==1 && flag_for_replace==1)
	    {
	    cancel_flag=0;
		flag_for_replace=0;
		}
		else if((flag_for_replace==0) || (ok_flag==1))
		{
       		file_export_to_pdf();
			ok_flag=0;
			flag_for_replace=0;
		}
      }
      else
      {
        pSbar->push("File Export Cancelled...");
        active_file_name1 = "";
      }
    }
    else
    {
    throw 1;
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
}

void KalanjiyamWindow::file_export1()
{
  try
  {

    if (strcmp(active_file_name.c_str(), "" ) != 0)
    {
      std::string filepath;	
      Glib::ustring filename;

 	  Gtk::FileChooserDialog dialog("Export PDF files",
      Gtk::FILE_CHOOSER_ACTION_SAVE);
      dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
      dialog.add_button(Gtk::Stock::SAVE, Gtk::RESPONSE_OK);
      dialog.set_current_name("Kalanjiyam.pdf");
      Gtk::FileFilter pngFilter;
      pngFilter.add_pattern ("*.pdf");
      //pngFilter.add_pattern ("*.KLJM");
      pngFilter.set_name("Kalanjiyam PDF files");
      dialog.add_filter(pngFilter);

      int result = dialog.run();

	  if(result==Gtk::RESPONSE_OK)
      {
      filepath = dialog.get_filename();
      
      string fileName = filepath;
      size_t position = fileName.find(".");
      string extractName = (string::npos == position)? fileName : fileName.substr(0, position);
     // active_file_name = extractName + ".pdf";  
  	  active_file_name2= extractName + ".pdf";
	  Glib::locale_from_utf8(active_file_name2);
	  int pdf_file_existace_status = 0;

      /*File Existance Check Begins*/
      std::string Kalanjiyam_file_folder_check = active_file_name2;
      if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
      {
      pdf_file_existace_status = 1;
      }

	  flag_for_replace=0;
      if (pdf_file_existace_status==1)
      {
        Glib::ustring msg = "File already exists. Do you want to replace it ?  ";
        pConfirmLabel->set_text(msg.c_str());
        ConfirmStatus = 7;
        pConfirmDialog->show();
        flag_for_replace=1;
      }
   
        if(cancel_flag==1 && flag_for_replace==1)
	    {
	    cancel_flag=0;
		flag_for_replace=0;
		}
		else if((flag_for_replace==0) || (ok_flag==1))
		{
       file_export_to_pdf1();
			ok_flag=0;
			flag_for_replace=0;
		}
      }
      else
      {
      pSbar->push("File Export Cancelled...");
      active_file_name2 = "";
      }
    }
    else
    {
    throw 1;
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
}


void KalanjiyamWindow::file_export2()
{

  try
  {
    if (strcmp(active_file_name.c_str(), "" ) != 0)
    {
      std::string filepath;	
      Glib::ustring filename;

 	  Gtk::FileChooserDialog dialog("Export PDF files",
      Gtk::FILE_CHOOSER_ACTION_SAVE);
      dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
      dialog.add_button(Gtk::Stock::SAVE, Gtk::RESPONSE_OK);
      dialog.set_current_name("Kalanjiyam.pdf");
      Gtk::FileFilter pngFilter;
      pngFilter.add_pattern ("*.pdf");
      //pngFilter.add_pattern ("*.KLJM");
      pngFilter.set_name("Kalanjiyam PDF files");
      dialog.add_filter(pngFilter);

      int result = dialog.run();

	  if(result==Gtk::RESPONSE_OK)
      {
      filepath = dialog.get_filename();
      
      string fileName = filepath;
      size_t position = fileName.find(".");
      string extractName = (string::npos == position)? fileName : fileName.substr(0, position);
      //active_file_name = extractName + ".pdf";  
	  active_file_name3=extractName + ".pdf";
	  Glib::locale_from_utf8(active_file_name3);
	  int pdf_file_existace_status = 0;

      /*File Existance Check Begins*/
      std::string Kalanjiyam_file_folder_check = active_file_name3;
      if ( access( Kalanjiyam_file_folder_check.c_str(), 0 ) == 0 )
      {
      pdf_file_existace_status = 1;
      }

	  flag_for_replace=0;
      if (pdf_file_existace_status==1)
      {
        Glib::ustring msg = "File already exists. Do you want to replace it ?  ";
        pConfirmLabel->set_text(msg.c_str());
        ConfirmStatus = 8;
        pConfirmDialog->show();
		flag_for_replace=1;
      }
   
        if(cancel_flag==1 && flag_for_replace==1)
	    {
	    cancel_flag=0;
		flag_for_replace=0;
		}
		else if((flag_for_replace==0) || (ok_flag==1))
		{
       		file_export_to_pdf2();
			ok_flag=0;
			flag_for_replace=0;
		}
      }
      else
      {
      	pSbar->push("File Export Cancelled...");
        active_file_name3 = "";
      }
    }
    else
    {
    throw 1;
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
}

void KalanjiyamWindow::file_export_to_pdf()
{

  int scene_no = global_current_scene_number;
  int shot_no = global_current_shot_number;

  for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
  {	
    tokenizer<> tok(global_scene_shot_number_list_vector[g]);
    int count=1;
    Glib::ustring first_value;
    Glib::ustring second_value;

    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(count==1)
      first_value=*beg;
      else
      second_value=*beg;
      count++;
    }
    global_current_scene_number=boost::lexical_cast<int>(first_value);
    global_current_shot_number=boost::lexical_cast<int>(second_value);
    show_selected_thumbnail_contents_in_window();
  }
  try
  {
    if (strcmp(active_file_name1.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    to_pdf1();
    std::string status = "File Exported as Pdf and Saved in : " + active_file_name1;
    pSbar->push(status);
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
  global_current_scene_number = scene_no;
  global_current_shot_number= shot_no;


  Glib::ustring a1= boost::lexical_cast<std::string>(global_current_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(global_current_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf1[10];
  sprintf(buf1,"%s",char_a3);

  show_selected_thumbnail_contents_in_window();
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));
}

void KalanjiyamWindow::file_export_to_pdf1()
{
  int scene_no = global_current_scene_number;
  int shot_no = global_current_shot_number;

  for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
  {	
    tokenizer<> tok(global_scene_shot_number_list_vector[g]);
    int count=1;
    Glib::ustring first_value;
    Glib::ustring second_value;

    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(count==1)
      first_value=*beg;
      else
      second_value=*beg;
      count++;
    }
    global_current_scene_number=boost::lexical_cast<int>(first_value);
    global_current_shot_number=boost::lexical_cast<int>(second_value);
    show_selected_thumbnail_contents_in_window();
  }
  try
  {
    if (strcmp(active_file_name2.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    to_pdf2();
    std::string status = "File Exported as Pdf and Saved in : " + active_file_name2;
    pSbar->push(status);
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
  global_current_scene_number = scene_no;
  global_current_shot_number= shot_no;


  Glib::ustring a1= boost::lexical_cast<std::string>(global_current_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(global_current_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf1[10];
  sprintf(buf1,"%s",char_a3);

  show_selected_thumbnail_contents_in_window();
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));
}


void KalanjiyamWindow::file_export_to_pdf2()
{
  int scene_no = global_current_scene_number;
  int shot_no = global_current_shot_number;
  for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
  {	
    tokenizer<> tok(global_scene_shot_number_list_vector[g]);
    int count=1;
    Glib::ustring first_value;
    Glib::ustring second_value;

    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(count==1)
      first_value=*beg;
      else
      second_value=*beg;
      count++;
    }
    global_current_scene_number=boost::lexical_cast<int>(first_value);
    global_current_shot_number=boost::lexical_cast<int>(second_value);
    show_selected_thumbnail_contents_in_window();
  }
  try
  {
    if (strcmp(active_file_name3.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    to_pdf3();
    std::string status = "File Exported as Pdf and Saved in : " + active_file_name3;
    pSbar->push(status);
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }	
  global_current_scene_number = scene_no;
  global_current_shot_number= shot_no;


  Glib::ustring a1= boost::lexical_cast<std::string>(global_current_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(global_current_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf1[10];
  sprintf(buf1,"%s",char_a3);

  show_selected_thumbnail_contents_in_window();
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));
}

void KalanjiyamWindow::font_choose_dialogBox()
{
  Glib::ustring font_name = pFontButton->get_font_name();
  open_global_font = font_name;
  pSbar->push("Font Selection Dialog Box Clicked...");
  if(col_flag==1)
  {
    Glib::ustring storke_col = boost::lexical_cast<std::string>(open_global_strokecolor_hex);
    my_item->set_property(Glib::ustring("font"), font_name);
    get_property(my_item,item_pos);
  }
  Pango::FontDescription font;
  Pango::FontDescription font1;
  font1 = Pango::FontDescription(font_name);  
  Glib::ustring family_name = font1.get_family(); 
  font.set_family(family_name);
  pTextTool->modify_font(font);
}

void KalanjiyamWindow::file_pPreview1()
{
  try
  {
    if (strcmp(active_file_name1.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    std::string file_path = active_file_name1;
    show_pdf_file(file_path.c_str());
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No Pdf File Exported Yet...");
    pInfoDialog->show();
    pSbar->push("No Pdf File Exported Yet...");
  }	
}

void KalanjiyamWindow::file_pPreview2()
{
  try
  {
    if (strcmp(active_file_name2.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    std::string file_path = active_file_name2;
    show_pdf_file(file_path.c_str());
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No Pdf File Exported Yet...");
    pInfoDialog->show();
    pSbar->push("No Pdf File Exported Yet...");
  }	
}

void KalanjiyamWindow::file_pPreview3()
{
  try
  {
    if (strcmp(active_file_name3.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    std::string file_path = active_file_name3;
    show_pdf_file(file_path.c_str());
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No Pdf File Exported Yet...");
    pInfoDialog->show();
    pSbar->push("No Pdf File Exported Yet...");
  }	
}

void KalanjiyamWindow::show_pdf_file(Glib::ustring a)
{
  std::string result = a;
  boost::replace_all(result, " ", "\\ ");
  std::string show_file = "gnome-open " + result;
  try
  {
    if(system(show_file.c_str())==0)
    {
    std::string status = "File Opended : " + a;
    pSbar->push(status);
    }
    else
    {
    throw 1;	
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Open the File to Explore...");
    pInfoDialog->show();
  }
}

void KalanjiyamWindow::to_png()
{ 
  if(on_parse_value_status==0)
  {
  update_tag_values();
  }
  int grid_status=0;
  if(grid_mode==1)
  {
  view_grid_on_off();
  grid_status=1;
  }
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Cairo::RefPtr<Cairo::ImageSurface> surf= Cairo::ImageSurface::create(Cairo::FORMAT_ARGB32,1000, 650);
  Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surf);
  cr->rectangle(265, 120, 700, 500);
  cr->clip();
  m_canvas.render(cr,1800);
  correct_scene_shot_position_occured = find_correct_scene_shot_position();
  Glib::ustring img_file_name="Thumbnail";
  Glib::ustring img_panel_name="Panel";
  Glib::ustring int_to_string_value;
  Glib::ustring img_file_extension=".png";
  Glib::ustring img_full_name_with_extension;
  Glib::ustring img_full_name_with_extension1;
  ij=1;
  int_to_string_value = boost::lexical_cast<std::string>(correct_scene_shot_position_occured);
  img_full_name_with_extension = thumbnail_tmp_path + img_file_name + int_to_string_value + img_file_extension;
  img_full_name_with_extension1 = thumbnail_tmp_path + img_panel_name + int_to_string_value + img_file_extension;
  abc11 = img_full_name_with_extension.c_str();
  const char* abc12 = img_full_name_with_extension1.c_str();
  surf->write_to_png(abc11);
  surf->write_to_png(abc12);
  try 
  {
    open_global_fillcolor_hex = fillcolor;
    open_global_strokecolor_hex = strokecolor;
    image.read(abc11);
    image.resize("100x125");
    image.write(abc11);	
  }
  catch( Exception &error_ )
  {
  }
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection =my_Tree_View_Test_Tree_View.get_selection();
  Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();
  Gtk::TreeModel::Row my_row;
  my_row=*iter1;
  my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file(abc11);
  if(grid_status==1)
  view_grid_on_off();
}

void KalanjiyamWindow::update_tag_values()
{
  Glib::ustring XmlVersion = "<?xml version=\"1.0\" encoding=\"utf-8\"?>";
  Glib::ustring OpenTag_Kalanjiyam = "<Kalanjiyam>";
  Glib::ustring CloseTag_Kalanjiyam = "</Kalanjiyam>";
  Glib::ustring OpenTag_Scene = "<Scene>";
  Glib::ustring CloseTag_Scene = "</Scene>";
  int total_frames = pTotalFrames->get_value_as_int();
  if(total_frames==0)
  {
  total_frames = 0;
  }
  Glib::ustring scene_title = pSceneTitle->get_text();
  if(strcmp(scene_title.c_str(),"")==0)
  {
  scene_title = "None";
  }
  string dialogue = pDialogue->get_buffer()->get_text();
  boost::replace_all(dialogue, "<", "");
  boost::replace_all(dialogue, ">", "");
  if(strcmp(dialogue.c_str(),"")==0)
  {
  dialogue = "None";
  }
  string action_notes = pActionNotes->get_buffer()->get_text();
  boost::replace_all(action_notes, "<", "");
  boost::replace_all(action_notes, ">", "");
  if(strcmp(action_notes.c_str(),"")==0)
  {
  action_notes = "None";
  }
  string audio_notes = pAudioNotes->get_buffer()->get_text();
  boost::replace_all(audio_notes, "<", "");
  boost::replace_all(audio_notes, ">", "");
  if(strcmp(audio_notes.c_str(),"")==0)
  {
  audio_notes = "None";
  }
  Glib::ustring SceneNumber = "<SceneNumber>" + pSceneNumber->get_text() + "</SceneNumber>";
  Glib::ustring ShotNumber = "<ShotNumber>" + pShotNumber->get_text() + "</ShotNumber>";
  Glib::ustring ShotType = "\n\t\t<ShotType>" + m_Combo.get_active_text() + "</ShotType>";
  Glib::ustring string_conv_for_total_frames=boost::lexical_cast<std::string>(total_frames );
  Glib::ustring TotalFrames = "\n\t\t<TotalFrames>" + string_conv_for_total_frames  + "</TotalFrames>";
  Glib::ustring SceneTitle = "\n\t\t<SceneTitle>" + scene_title + "</SceneTitle>";
  Glib::ustring Dialogue = "\n\t\t<Dialogue>" + dialogue + "</Dialogue>";
  Glib::ustring ActionNotes = "\n\t\t<ActionNotes>" + action_notes + "</ActionNotes>";
  Glib::ustring AudioNotes = "\n\t\t<AudioNotes>" + audio_notes + "</AudioNotes>";
  /*Drawing*/
  Glib::ustring Drawing_tag = "";
  int skip_first_position=1;
  for (xml_scene_overall_tag_it = xml_scene_overall_tag.begin()+1; xml_scene_overall_tag_it != xml_scene_overall_tag.end(); ++xml_scene_overall_tag_it)
  {
  Drawing_tag = Drawing_tag + (*xml_scene_overall_tag_it);
  }
  /*Group*/
  Glib::ustring group_tag = create_xml_for_group();
  /*Group*/
  correct_scene_shot_position_occured = find_correct_scene_shot_position();
  Glib::ustring single_panel_xml;
  if(global_current_scene_number==1 && global_current_shot_number==1)
  {
  Glib::ustring ProjectName = "<ProjectName>" + pProjectName->get_text() + "</ProjectName>";
  Glib::ustring ProjectClient = "<ProjectClient>" + pProjectClient->get_text() + "</ProjectClient>";
  Glib::ustring ScreenType = "<ScreenType>" + preference_m_Combo.get_active_text() + "</ScreenType>";
  Glib::ustring CopyRights = "<CopyRights>" + pProjectCopy->get_text() + "</CopyRights>";
  single_panel_xml = ShotType + TotalFrames + SceneTitle + Dialogue + ActionNotes + AudioNotes + ProjectName + ProjectClient + ScreenType + CopyRights + Drawing_tag + group_tag + CloseTag_Scene;
  }
  else
  {
  single_panel_xml = ShotType + TotalFrames + SceneTitle + Dialogue + ActionNotes + AudioNotes + Drawing_tag + group_tag + CloseTag_Scene;
  }
  if((xml_kalanjiyam_overall_tag.size()>correct_scene_shot_position_occured-1))
  {
  xml_kalanjiyam_overall_tag[correct_scene_shot_position_occured-1] = single_panel_xml;
  }
}
void KalanjiyamWindow::to_pdf1()
{
  get_kalanjiyam_properties();
  int count_kljm=0;
  for(int ij=0;ij<global_scene_shot_number_list_vector.size();ij++)
  {
  count_kljm=count_kljm+1;
  }
  cairo_surface_t *surface;
  cairo_t *cr;
  Glib::ustring png_path = active_file_name1;
  surface = cairo_pdf_surface_create(png_path.c_str(), 841.89, 595.28);  
  cr = cairo_create(surface);

  cairo_rectangle(cr, 49.492, 53.229, 744.00, 506.34);     
  cairo_stroke(cr); 	

  cairo_surface_t *image; 

  cairo_move_to(cr, 66.624, 65);
  cairo_show_text(cr, "Project Name :");
  cairo_move_to(cr, 146.0, 65);
  cairo_show_text(cr, global_char_projectname);

  cairo_set_source_rgb(cr, 0, 0, 0); 
  cairo_move_to(cr, 440.0, 65);
  cairo_show_text(cr, "Project Client :");
  cairo_move_to(cr, 520.0, 65);
  cairo_show_text(cr, global_char_projectclient);

  int scene=82.550;
  int frames=468.492;
  int frames1=490.492;
  int frames2=512.492;
  int audnotes=383.563;
  int audnotes1=405.563;
  int audnotes2=427.563;
  int title=103;
  int dialogue=310;
  int action=340;
  int ima1=49;
  int img_number = 0;
  int rec1_x=66.624;
  int rec1=92.322;
  int rec2=109.453;
  int x_cor=75;
  int x_cor1=120;
  int x_cor2=127;
  int x_cor3=66.624;
  int x_cor4=154;
  int x_cor5=164;
  int x_cor6=145;
  int x_cor7=185;
  int x_cor8=195;
  int x_cor9=210;
  int x_cor10=265;
  int x_cor11=274;
  int x_cor12=76;
  int x_cor13=150;
  int x_cor14=160;

  int ima2=-62;

  string input_xml;
  Glib::ustring total_xml = combine_kljm_file_contents();
  input_xml = boost::lexical_cast<std::string>(total_xml);
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);

  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc;
  int page_number=0;
  const char *char_SceneNumber;
  const char *char_ShotNumber;
  const char *char_ShotType;
  const char *char_TotalFrames;
  const char *char_SceneTitle;
  const char *char_Dialogue;
  const char *char_ActionNotes;
  const char *char_AudioNotes;
  while (Scene != NULL )
  {	
    page_number=page_number+1;
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      const char * test1 = abc->name();	
      if (strcmp(test1, "SceneNumber" ) == 0)
      {
      SceneNumber = abc->value();
      }
      if (strcmp(test1, "ShotNumber" ) == 0)
      {
      ShotNumber = abc->value();
      }
      if (strcmp(test1, "ShotType" ) == 0)
      {
      ShotType = abc->value();
      }
      if (strcmp(test1, "TotalFrames" ) == 0)
      {
      TotalFrames = abc->value();
      }
      if (strcmp(test1, "SceneTitle" ) == 0)
      {
      SceneTitle = abc->value();
      }
      if (strcmp(test1, "Dialogue" ) == 0)
      {
      Dialogue = abc->value();
      }
      if (strcmp(test1, "ActionNotes" ) == 0)
      {
      ActionNotes = abc->value();
      }
      if (strcmp(test1, "AudioNotes" ) == 0)
      {
      AudioNotes = abc->value();
      }
    }

    std::string split_ActionNotes1;
    std::string split_ActionNotes2;
    std::string split_ActionNotes3;

    const char *char_ActionNotes1;
    const char *char_ActionNotes2;
    const char *char_ActionNotes3;

    std::string split_AudioNotes1;
    std::string split_AudioNotes2;
    std::string split_AudioNotes3;

    const char *char_AudioNotes1;
    const char *char_AudioNotes2;
    const char *char_AudioNotes3;

    int audio_size=AudioNotes.size();

    if(audio_size<= 38)
    {
    std::string result = AudioNotes;
    boost::replace_all(result, "\n", "");
    split_AudioNotes1=result.substr(0,audio_size);
    }
    else if(audio_size <= 92)
    {
    std::string result = AudioNotes;
    boost::replace_all(result, "\n", "");
    split_AudioNotes1=result.substr(0,38);
    split_AudioNotes2= result.substr(38,54);
    }
    else
    {
    std::string result = AudioNotes;
    boost::replace_all(result, "\n", "");
    split_AudioNotes1=result.substr(0,38);
    split_AudioNotes2= result.substr(38,54);
    split_AudioNotes3= result.substr(92,56); 
    } 

    int audio_size1=ActionNotes.size();

    if(audio_size1<= 38)
    {
    std::string result = ActionNotes;
    boost::replace_all(result, "\n", "");
    split_ActionNotes1=result.substr(0,audio_size1);
    }
    else if(audio_size1 <= 92)
    {
    std::string result = ActionNotes;
    boost::replace_all(result, "\n", "");
    split_ActionNotes1=result.substr(0,38);
    split_ActionNotes2= result.substr(38,54);
    }
    else
    {
    std::string result = ActionNotes;
    boost::replace_all(result, "\n", "");
    split_ActionNotes1=result.substr(0,38);
    split_ActionNotes2= result.substr(38,54);
    split_ActionNotes3= result.substr(92,56);  
    }	

    Glib::locale_from_utf8 ( split_AudioNotes1);	
    Glib::locale_from_utf8 ( split_AudioNotes2);	
    Glib::locale_from_utf8 ( split_AudioNotes3);	

    char_AudioNotes1= split_AudioNotes1.c_str();
    char_AudioNotes2= split_AudioNotes2.c_str();
    char_AudioNotes3= split_AudioNotes3.c_str();

    Glib::locale_from_utf8 ( split_ActionNotes1);	
    Glib::locale_from_utf8 ( split_ActionNotes2);	
    Glib::locale_from_utf8 ( split_ActionNotes3);	

    char_ActionNotes1= split_ActionNotes1.c_str();
    char_ActionNotes2= split_ActionNotes2.c_str();
    char_ActionNotes3= split_ActionNotes3.c_str();

    Glib::locale_from_utf8 (SceneNumber);
    Glib::locale_from_utf8 (ShotNumber);
    Glib::locale_from_utf8 (ShotType);
    Glib::locale_from_utf8 (TotalFrames);
    Glib::locale_from_utf8 (SceneTitle);
    Glib::locale_from_utf8 (Dialogue);
    Glib::locale_from_utf8 (ActionNotes);
    Glib::locale_from_utf8 (AudioNotes);	

    char_SceneNumber = SceneNumber.c_str();
    char_ShotNumber = ShotNumber.c_str();
    char_ShotType = ShotType.c_str();
    char_TotalFrames = TotalFrames.c_str();
    char_SceneTitle =  SceneTitle.c_str();
    char_Dialogue = Dialogue.c_str();
    char_ActionNotes= ActionNotes.c_str();
    char_AudioNotes= AudioNotes.c_str();

    std::string split_SceneTitle;
    split_SceneTitle = SceneTitle.substr(0,20);
    Glib::locale_from_utf8 ( split_SceneTitle);
    char_SceneTitle =  split_SceneTitle.c_str();

    Glib::ustring img_file_name="Panel";
    Glib::ustring int_to_string_value;
    Glib::ustring img_file_extension=".png";
    Glib::ustring img_full_name_with_extension;
    cairo_rectangle(cr, rec1_x, rec1, 340.157, 14.375);     
    cairo_stroke(cr); 

    cairo_rectangle(cr, rec1_x, rec2, 340.157, 255.118);     
    cairo_stroke(cr); 	

    img_number = img_number + 1;
    int_to_string_value = boost::lexical_cast<std::string>(img_number);
    img_full_name_with_extension = thumbnail_tmp_path + img_file_name + int_to_string_value + img_file_extension;
    const char * abc11 = img_full_name_with_extension.c_str();
    Glib::RefPtr<Gdk::Pixbuf> m_orig;
    m_orig = Gdk::Pixbuf::create_from_file (abc11);
    Gtk::Image m_image;
    Glib::RefPtr<Gdk::Pixbuf> buff = m_orig->scale_simple(485,330, Gdk::INTERP_BILINEAR);
    buff->save(abc11, "png"); 

    image = cairo_image_surface_create_from_png(abc11);
    cairo_set_source_surface(cr, image, ima2, ima1);
    cairo_paint(cr);

    cairo_set_source_rgb(cr, 0, 0, 0);
    cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
    cairo_set_font_size(cr, 9);

    cairo_set_source_rgb(cr, 0, 0, 0); 
    cairo_move_to(cr, x_cor, scene);
    cairo_show_text(cr, "Scene No");
    cairo_move_to(cr, x_cor1, scene);
    cairo_show_text(cr, ":");
    cairo_move_to(cr, x_cor2, scene);
    cairo_show_text(cr, char_SceneNumber);

    cairo_move_to(cr, x_cor6, scene);
    cairo_show_text(cr, "Shot No");
    cairo_move_to(cr, x_cor7, scene);
    cairo_show_text(cr, ":");
    cairo_move_to(cr, x_cor8, scene);
    cairo_show_text(cr, char_ShotNumber);

    cairo_move_to(cr, x_cor9,  scene);
    cairo_show_text(cr, "Shot Type");
    cairo_move_to(cr, x_cor10,  scene);
    cairo_show_text(cr, ":");
    cairo_move_to(cr, x_cor11,  scene);
    cairo_show_text(cr, char_ShotType);

    cairo_set_source_rgb(cr, 0, 0, 0);
    cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
    cairo_set_font_size(cr, 12);

    cairo_move_to(cr, x_cor12, title);
    cairo_show_text(cr, "Scene Title");
    cairo_move_to(cr, x_cor13, title);	
    cairo_show_text(cr, ":");
    cairo_move_to(cr, x_cor14, title);
    cairo_show_text(cr, char_SceneTitle);

    cairo_move_to(cr, x_cor3, audnotes);
    cairo_show_text(cr, "Script/Audio");
    cairo_move_to(cr, x_cor4, audnotes);
    cairo_show_text(cr, ":");

    cairo_move_to(cr, x_cor5, audnotes);
    cairo_show_text(cr, char_AudioNotes1);

    cairo_move_to(cr, x_cor3, audnotes1);
    cairo_show_text(cr, char_AudioNotes2);

    cairo_move_to(cr, x_cor3, audnotes2);
    cairo_show_text(cr, char_AudioNotes3);

    cairo_move_to(cr, x_cor3, frames);
    cairo_show_text(cr, "Decription");
    cairo_move_to(cr, x_cor4, frames);
    cairo_show_text(cr, ":");

    cairo_move_to(cr, x_cor5, frames);
    cairo_show_text(cr, char_ActionNotes1);

    cairo_move_to(cr, x_cor3, frames1);
    cairo_show_text(cr, char_ActionNotes2);

    cairo_move_to(cr, x_cor3, frames2);
    cairo_show_text(cr, char_ActionNotes3);

    rec1_x=rec1_x+372;
    x_cor=x_cor+372;
    x_cor1=x_cor1+372;
    x_cor2=x_cor2+372;
    x_cor3=x_cor3+372;
    x_cor4=x_cor4+372;
    x_cor5=x_cor5+372;
    x_cor6=x_cor6+372;
    x_cor7=x_cor7+372;
    x_cor8=x_cor8+372;
    x_cor9=x_cor9+372;
    x_cor10=x_cor10+372;
    x_cor11=x_cor11+372;
    x_cor12=x_cor12+372;
    x_cor13=x_cor13+372;
    x_cor14=x_cor14+372;
    ima2=ima2+372;

    if((page_number%2)==0)
      {
      rec1_x=rec1_x-744;
      x_cor=x_cor-744;
      x_cor1=x_cor1-744;
      x_cor2=x_cor2-744;
      x_cor3=x_cor3-744;
      x_cor4=x_cor4-744;
      x_cor5=x_cor5-744;
      x_cor6=x_cor6-744;
      x_cor7=x_cor7-744;
      x_cor8=x_cor8-744;
      x_cor9=x_cor9-744;
      x_cor10=x_cor10-744;
      x_cor11=x_cor11-744;
      x_cor12=x_cor12-744;
      x_cor13=x_cor13-744;
      x_cor14=x_cor14-744;
      ima2=ima2-744.28;
      if(page_number+1<=count_kljm)
      {
      cairo_show_page(cr);
      }
    }
    else
    {
    cairo_rectangle(cr, 49.492, 53.229, 744.00, 506.34);     
    cairo_stroke(cr); 	
    cairo_move_to(cr, 66.624, 543.550);
    cairo_show_text(cr, "Copyright to :");
    cairo_move_to(cr, 152, 543.550);
    cairo_show_text(cr, global_char_projectcopy );
    }
    Scene = Scene->next_sibling("Scene");	
  }//while loop ends here
  cairo_show_page(cr); 
  cairo_surface_destroy(surface);
  cairo_destroy(cr);
  //to_pdf2();
}

void KalanjiyamWindow::to_pdf2()
{
  get_kalanjiyam_properties(); 
  int count_kljm=0;
  for(int ij=0;ij<global_scene_shot_number_list_vector.size();ij++)
  {
  count_kljm=count_kljm+1;
  }
  cairo_surface_t *surface;
  cairo_t *cr;
  Glib::ustring png_path = active_file_name2;
  surface = cairo_pdf_surface_create(png_path.c_str(), 595, 842);
  cr = cairo_create(surface);
  cairo_rectangle(cr, 51.789, 46.191, 506.341, 744.649);     
  cairo_stroke(cr); 	

  cairo_surface_t *image; 

  cairo_move_to(cr, 66.624, 65);
  cairo_show_text(cr, "Project Name :");
  cairo_move_to(cr, 145.0, 65);
  cairo_show_text(cr, global_char_projectname);

  cairo_set_source_rgb(cr, 0, 0, 0); 
  cairo_move_to(cr, 315.0, 65);
  cairo_show_text(cr, "Project Client :");
  cairo_move_to(cr, 395.0, 65);
  cairo_show_text(cr, global_char_projectclient);

  int abs_rec=68;
  int rec1=114.777;
  int rec2=136;
  int scene=97;
  int frames=367;
  int frames1=383;
  int frames2=399;
  int audnotes=315;
  int audnotes1=331;
  int audnotes2=347;
  int title=124;
  int dialogue=310;
  int action=340;
  int ima1=96;
  int img_number = 0;
  int x_cor=70;
  int x_cor1=143;
  int x_cor2=153;
  int x_cor3=165;	
  int x_cor4=200	;
  int x_cor5=205;
  int x_cor6=70;
  int x_cor7=104;
  int x_cor8=107;
  int x_cor9=120;
  int x_cor10=150;
  int x_cor11=154;
  int ima2=-17.50;

  string input_xml;
  Glib::ustring total_xml = combine_kljm_file_contents();
  input_xml = boost::lexical_cast<std::string>(total_xml);
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc;
  int page_number=0;
  const char *char_SceneNumber;
  const char *char_ShotNumber;
  const char *char_ShotType;
  const char *char_TotalFrames;
  const char *char_SceneTitle;
  const char *char_Dialogue;
  const char *char_ActionNotes;
  const char *char_AudioNotes;

  cairo_move_to(cr, 66.624, 770.550);
  cairo_show_text(cr, "Copyright to :");
  cairo_move_to(cr, 140, 770.550);
  cairo_show_text(cr, global_char_projectcopy ); 

  while (Scene != NULL )
  {	
    page_number=page_number+1;
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      const char * test1 = abc->name();	
      if (strcmp(test1, "SceneNumber" ) == 0)
      {
      SceneNumber = abc->value();
      }
      if (strcmp(test1, "ShotNumber" ) == 0)
      {
      ShotNumber = abc->value();
      }
      if (strcmp(test1, "ShotType" ) == 0)
      {
      ShotType = abc->value();
      }
      if (strcmp(test1, "TotalFrames" ) == 0)
      {
      TotalFrames = abc->value();
      }
      if (strcmp(test1, "SceneTitle" ) == 0)
      {
      SceneTitle = abc->value();
      }
      if (strcmp(test1, "Dialogue" ) == 0)
      {
      Dialogue = abc->value();
      }
      if (strcmp(test1, "ActionNotes" ) == 0)
      {
      ActionNotes = abc->value();
      }
      if (strcmp(test1, "AudioNotes" ) == 0)
      {
      AudioNotes = abc->value();
      }
    }

    std::string split_ActionNotes1;
    std::string split_ActionNotes2;
    std::string split_ActionNotes3;

    const char *char_ActionNotes1;
    const char *char_ActionNotes2;
    const char *char_ActionNotes3;

    std::string split_AudioNotes1;
    std::string split_AudioNotes2;
    std::string split_AudioNotes3;

    const char *char_AudioNotes1;
    const char *char_AudioNotes2;
    const char *char_AudioNotes3;

    int audio_size=AudioNotes.size();

    if(audio_size<= 38)
    {
    std::string result = AudioNotes;
    boost::replace_all(result, "\n", "");
    split_AudioNotes1=result.substr(0,audio_size);
    }
    else if(audio_size <= 92)
    {
    std::string result = AudioNotes;
    boost::replace_all(result, "\n", "");
    split_AudioNotes1=result.substr(0,38);
    split_AudioNotes2= result.substr(38,54);
    }
    else
    {
    std::string result = AudioNotes;
    boost::replace_all(result, "\n", "");
    split_AudioNotes1=result.substr(0,38);
    split_AudioNotes2= result.substr(38,54);
    split_AudioNotes3= result.substr(92,56); 
    }  

    int audio_size1=ActionNotes.size();
    if(audio_size1<= 38)
    {
    std::string result = ActionNotes;
    boost::replace_all(result, "\n", "");
    split_ActionNotes1=result.substr(0,audio_size1);
    }
    else if(audio_size1 <= 92)
    {
    std::string result = ActionNotes;
    boost::replace_all(result, "\n", "");
    split_ActionNotes1=result.substr(0,38);
    split_ActionNotes2= result.substr(38,54);
    }
    else
    {
    std::string result = ActionNotes;
    boost::replace_all(result, "\n", "");
    split_ActionNotes1=result.substr(0,38);
    split_ActionNotes2= result.substr(38,54);
    split_ActionNotes3= result.substr(92,56);  
    }	

    Glib::locale_from_utf8 ( split_AudioNotes1);	
    Glib::locale_from_utf8 ( split_AudioNotes2);	
    Glib::locale_from_utf8 ( split_AudioNotes3);	

    char_AudioNotes1= split_AudioNotes1.c_str();
    char_AudioNotes2= split_AudioNotes2.c_str();
    char_AudioNotes3= split_AudioNotes3.c_str();

    Glib::locale_from_utf8 ( split_ActionNotes1);	
    Glib::locale_from_utf8 ( split_ActionNotes2);	
    Glib::locale_from_utf8 ( split_ActionNotes3);	

    char_ActionNotes1= split_ActionNotes1.c_str();
    char_ActionNotes2= split_ActionNotes2.c_str();
    char_ActionNotes3= split_ActionNotes3.c_str();

    Glib::locale_from_utf8 (SceneNumber);
    Glib::locale_from_utf8 (ShotNumber);
    Glib::locale_from_utf8 (ShotType);
    Glib::locale_from_utf8 (TotalFrames);
    Glib::locale_from_utf8 (SceneTitle);
    Glib::locale_from_utf8 (Dialogue);
    Glib::locale_from_utf8 (ActionNotes);
    Glib::locale_from_utf8 (AudioNotes);

    char_SceneNumber = SceneNumber.c_str();
    char_ShotNumber = ShotNumber.c_str();
    char_ShotType = ShotType.c_str();
    char_TotalFrames = TotalFrames.c_str();
    char_SceneTitle =  SceneTitle.c_str();
    char_Dialogue = Dialogue.c_str();
    char_ActionNotes= ActionNotes.c_str();
    char_AudioNotes= AudioNotes.c_str();
    
    std::string split_SceneTitle;
    split_SceneTitle = SceneTitle.substr(0,20);
    Glib::locale_from_utf8 ( split_SceneTitle);
    char_SceneTitle =  split_SceneTitle.c_str();

    Glib::ustring img_file_name="Panel";
    Glib::ustring int_to_string_value;
    Glib::ustring img_file_extension=".png";
    Glib::ustring img_full_name_with_extension;

    cairo_rectangle(cr, abs_rec, rec1, 225.411, 14.118);     
    cairo_stroke(cr); 		

    cairo_rectangle(cr, abs_rec, rec2, 225.411, 170.079);     
    cairo_stroke(cr); 

    img_number = img_number + 1;
    int_to_string_value = boost::lexical_cast<std::string>(img_number);
    img_full_name_with_extension = thumbnail_tmp_path + img_file_name + int_to_string_value + img_file_extension;
    const char * abc11 = img_full_name_with_extension.c_str();
    Glib::RefPtr<Gdk::Pixbuf> m_orig;
    m_orig = Gdk::Pixbuf::create_from_file (abc11);
    Gtk::Image m_image;
    Glib::RefPtr<Gdk::Pixbuf> buff = m_orig->scale_simple(321.50, 220, Gdk::INTERP_BILINEAR);
    buff->save(abc11, "png"); 

    image = cairo_image_surface_create_from_png(abc11);
    cairo_set_source_surface(cr, image, ima2, ima1);
    cairo_paint(cr);

    cairo_set_source_rgb(cr, 0, 0, 0);
    cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
    cairo_set_font_size(cr, 7.0);

    cairo_set_source_rgb(cr, 0, 0, 0); 
    cairo_move_to(cr, x_cor6, scene);
    cairo_show_text(cr, "Scene No");
    cairo_move_to(cr, x_cor7, scene);
    cairo_show_text(cr, ":");
    cairo_move_to(cr, x_cor8, scene);
    cairo_show_text(cr, char_SceneNumber);

    cairo_move_to(cr, x_cor9, scene);
    cairo_show_text(cr, "Shot No");
    cairo_move_to(cr,  x_cor10, scene);
    cairo_show_text(cr, ":");
    cairo_move_to(cr,  x_cor11, scene);
    cairo_show_text(cr, char_ShotNumber);

    cairo_move_to(cr, x_cor3,  scene);
    cairo_show_text(cr, "Shot Type");
    cairo_move_to(cr, x_cor4,  scene);
    cairo_show_text(cr, ":");
    cairo_move_to(cr, x_cor5,  scene);
    cairo_show_text(cr, char_ShotType);

    cairo_set_source_rgb(cr, 0, 0, 0);
    cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
    cairo_set_font_size(cr, 9.0);

    cairo_move_to(cr, x_cor, title);
    cairo_show_text(cr, "Scene Title");
    cairo_move_to(cr, x_cor1, title);	
    cairo_show_text(cr, ":");
    cairo_move_to(cr, x_cor2, title);
    cairo_show_text(cr, char_SceneTitle);

    cairo_move_to(cr, x_cor, audnotes);
    cairo_show_text(cr, "Script/Audio");
    cairo_move_to(cr, x_cor1, audnotes);
    cairo_show_text(cr, ":");

    cairo_move_to(cr, x_cor, frames);
    cairo_show_text(cr, "Decription");
    cairo_move_to(cr, x_cor1, frames);
    cairo_show_text(cr, ":");

    cairo_set_source_rgb(cr, 0, 0, 0);
    cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
    cairo_set_font_size(cr, 7);

    cairo_move_to(cr, x_cor2, audnotes);
    cairo_show_text(cr, char_AudioNotes1);

    cairo_move_to(cr, x_cor, audnotes1);
    cairo_show_text(cr, char_AudioNotes2);

    cairo_move_to(cr, x_cor, audnotes2);
    cairo_show_text(cr, char_AudioNotes3);


    cairo_move_to(cr, x_cor2, frames);
    cairo_show_text(cr, char_ActionNotes1);

    cairo_move_to(cr, x_cor, frames1);
    cairo_show_text(cr, char_ActionNotes2);

    cairo_move_to(cr, x_cor, frames2);
    cairo_show_text(cr, char_ActionNotes3);

    abs_rec=abs_rec+241;
    x_cor=x_cor+241;
    x_cor1=x_cor1+241;
    x_cor2=x_cor2+241;
    x_cor3=x_cor3+241;
    x_cor4=x_cor4+241;
    x_cor5=x_cor5+241;
    x_cor6=x_cor6+241;
    x_cor7=x_cor7+241;
    x_cor8=x_cor8+241;
    x_cor9=x_cor9+241;
    x_cor10=x_cor10+241;
    x_cor11=x_cor11+241;
    ima2=ima2+241;

    if((page_number%2==0) && (page_number%4!=0))
    {
      abs_rec=abs_rec-482;
      x_cor=x_cor-482;
      x_cor1=x_cor1-482;
      x_cor2=x_cor2-482;
      x_cor3=x_cor3-482;
      x_cor4=x_cor4-482;
      x_cor5=x_cor5-482;
      x_cor6=x_cor6-482;
      x_cor7=x_cor7-482;
      x_cor8=x_cor8-482;
      x_cor9=x_cor9-482;
      x_cor10=x_cor10-482;
      x_cor11=x_cor11-482;
      ima2=ima2-482;
      rec1=rec1+317;
      rec2=rec2+317;
      scene=scene+317;
      frames=frames+317;
      frames1=frames1+317;
      frames2=frames2+317;
      audnotes=audnotes+317;
      audnotes1=audnotes1+317;
      audnotes2=audnotes2+317;
      title=title+317;
      dialogue=dialogue+317;
      action=action+317;
      ima1=ima1+317;
    }
    else if(page_number%4==0)
      {
      abs_rec=abs_rec-482;
      x_cor=x_cor-482;
      x_cor1=x_cor1-482;
      x_cor2=x_cor2-482;
      x_cor3=x_cor3-482;
      x_cor4=x_cor4-482;
      x_cor5=x_cor5-482;
      x_cor6=x_cor6-482;
      x_cor7=x_cor7-482;
      x_cor8=x_cor8-482;
      x_cor9=x_cor9-482;
      x_cor10=x_cor10-482;
      x_cor11=x_cor11-482;
      ima2=ima2-482;
      rec1=rec1-317;
      rec2=rec2-317;
      scene=scene-317;
      frames=frames-317;
      frames1=frames1-317;
      frames2=frames2-317;
      audnotes=audnotes-317;
      audnotes1=audnotes1-317;

      audnotes2=audnotes2-317;
      title=title-317;
      dialogue=dialogue-317;
      action=action-317;
      ima1=ima1-317;
      if(page_number+1<=count_kljm)
      {
        cairo_show_page(cr);
        cairo_rectangle(cr, 51.789, 46.191, 506.341, 744.649);     
        cairo_stroke(cr); 
        cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
        cairo_set_font_size(cr, 9.0);
        cairo_move_to(cr, 66.624, 770.550);
        cairo_show_text(cr, "Copyright to :");
        cairo_move_to(cr, 140, 770.550);
        cairo_show_text(cr, global_char_projectcopy ); 
      }
    }

    Scene = Scene->next_sibling("Scene");	
  }//while loop ends here
  cairo_show_page(cr); 
  cairo_surface_destroy(surface);
  cairo_destroy(cr);
  //to_pdf3();
}

void KalanjiyamWindow::to_pdf3()
{
  get_kalanjiyam_properties();
  int count_kljm=0;
  for(int ij=0;ij<global_scene_shot_number_list_vector.size();ij++)
  {
  count_kljm=count_kljm+1;
  }

  cairo_surface_t *surface;
  cairo_t *cr;
  Glib::ustring png_path = active_file_name3;
  surface = cairo_pdf_surface_create(png_path.c_str(),  841.89, 595.28); 
  cr = cairo_create(surface);

  cairo_rectangle(cr, 49.492, 53.229, 744.00, 506.34);     
  cairo_stroke(cr); 

  cairo_surface_t *image;  

  cairo_move_to(cr, 86.624, 65);
  cairo_show_text(cr, "Project Name :");
  cairo_move_to(cr, 166.0, 65);
  cairo_show_text(cr, global_char_projectname);

  cairo_set_source_rgb(cr, 0, 0, 0); 
  cairo_move_to(cr, 460.0, 65);
  cairo_show_text(cr, "Project Client :");
  cairo_move_to(cr, 540.0, 65);
  cairo_show_text(cr, global_char_projectclient);

  int abs_rec=76.050;
  int rec1=88.836;
  int rec2=102.969;
  int scene=82.550;
  int frames=263;
  int frames1=273;
  int frames2=283;
  int audnotes1=229;
  int audnotes2=239;
  int audnotes=219;
  int title=97;
  int dialogue=310;
  int action=340;
  int ima1=76;
  int img_number = 0;
  int x_cor=80;
  int x_cor1=144;
  int x_cor2=156;
  int x_cor3=164;
  int x_cor4=195;
  int x_cor5=198;
  int x_cor6=80;
  int x_cor7=108;
  int x_cor8=114;
  int x_cor9=124;
  int x_cor10=150;
  int x_cor11=155;
  int ima2=12;

  string input_xml;
  Glib::ustring total_xml = combine_kljm_file_contents();
  input_xml = boost::lexical_cast<std::string>(total_xml);
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc;
  int page_number=0;
  const char *char_SceneNumber;
  const char *char_ShotNumber;
  const char *char_ShotType;
  const char *char_TotalFrames;
  const char *char_SceneTitle;
  const char *char_Dialogue;
  const char *char_ActionNotes;
  const char *char_AudioNotes;

  cairo_move_to(cr, 66.624, 543.550);
  cairo_show_text(cr, "Copyright to :");
  cairo_move_to(cr, 140, 543.550);
  cairo_show_text(cr, global_char_projectcopy );

  while (Scene != NULL )
  {	
  page_number=page_number+1;
  for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
  {
  const char * test1 = abc->name();	
  if (strcmp(test1, "SceneNumber" ) == 0)
  {
  SceneNumber = abc->value();
  }
  if (strcmp(test1, "ShotNumber" ) == 0)
  {
  ShotNumber = abc->value();
  }
  if (strcmp(test1, "ShotType" ) == 0)
  {
  ShotType = abc->value();
  }
  if (strcmp(test1, "TotalFrames" ) == 0)
  {
  TotalFrames = abc->value();
  }
  if (strcmp(test1, "SceneTitle" ) == 0)
  {
  SceneTitle = abc->value();
  }
  if (strcmp(test1, "Dialogue" ) == 0)
  {
  Dialogue = abc->value();
  }
  if (strcmp(test1, "ActionNotes" ) == 0)
  {
  ActionNotes = abc->value();
  }
  if (strcmp(test1, "AudioNotes" ) == 0)
  {
  AudioNotes = abc->value();
  }
  }

  std::string split_ActionNotes1;
  std::string split_ActionNotes2;
  std::string split_ActionNotes3;

  const char *char_ActionNotes1;
  const char *char_ActionNotes2;
  const char *char_ActionNotes3;

  std::string split_AudioNotes1;
  std::string split_AudioNotes2;
  std::string split_AudioNotes3;

  const char *char_AudioNotes1;
  const char *char_AudioNotes2;
  const char *char_AudioNotes3;

  int audio_size=AudioNotes.size();
  if(audio_size<= 30)
  {
  std::string result = AudioNotes;
  boost::replace_all(result, "\n", "");
  split_AudioNotes1=result.substr(0,audio_size);
  }
  else if(audio_size <= 90)
  {
  std::string result = AudioNotes;
  boost::replace_all(result, "\n", "");
  split_AudioNotes1=result.substr(0,30);
  split_AudioNotes2= result.substr(30,60);
  } 
  else
  {
  std::string result = AudioNotes;
  boost::replace_all(result, "\n", "");
  split_AudioNotes1=result.substr(0,30);
  split_AudioNotes2= result.substr(30,60);
  split_AudioNotes3= result.substr(90,58); 
  } 
  int audio_size1=ActionNotes.size();
  if(audio_size1<= 30)
  {
  std::string result = ActionNotes;
  boost::replace_all(result, "\n", "");
  split_ActionNotes1=result.substr(0,audio_size1); 
  }
  else if(audio_size1 <= 90)
  {
  std::string result = ActionNotes;
  boost::replace_all(result, "\n", "");
  split_ActionNotes1=result.substr(0,30);
  split_ActionNotes2= result.substr(30,60);
  }
  else
  {
  std::string result = ActionNotes;
  boost::replace_all(result, "\n", "");
  split_ActionNotes1= result.substr(0,30);
  split_ActionNotes2= result.substr(30,60);
  split_ActionNotes3= result.substr(90,58);  
  }

  Glib::locale_from_utf8 ( split_AudioNotes1);	
  Glib::locale_from_utf8 ( split_AudioNotes2);	
  Glib::locale_from_utf8 ( split_AudioNotes3);	

  char_AudioNotes1= split_AudioNotes1.c_str();
  char_AudioNotes2= split_AudioNotes2.c_str();
  char_AudioNotes3= split_AudioNotes3.c_str();

  Glib::locale_from_utf8 ( split_ActionNotes1);	
  Glib::locale_from_utf8 ( split_ActionNotes2);	
  Glib::locale_from_utf8 ( split_ActionNotes3);	

  char_ActionNotes1 = split_ActionNotes1.c_str();
  char_ActionNotes2 = split_ActionNotes2.c_str();
  char_ActionNotes3 = split_ActionNotes3.c_str();

  Glib::locale_from_utf8 (SceneNumber);
  Glib::locale_from_utf8 (ShotNumber);
  Glib::locale_from_utf8 (ShotType);
  Glib::locale_from_utf8 (TotalFrames);
  Glib::locale_from_utf8 (SceneTitle);
  Glib::locale_from_utf8 (Dialogue);
  Glib::locale_from_utf8 (ActionNotes);
  Glib::locale_from_utf8 (AudioNotes);

  char_SceneNumber = SceneNumber.c_str();
  char_ShotNumber = ShotNumber.c_str();
  char_ShotType = ShotType.c_str();
  char_TotalFrames = TotalFrames.c_str();
  char_SceneTitle =  SceneTitle.c_str();
  char_Dialogue = Dialogue.c_str();
  char_ActionNotes= ActionNotes.c_str();
  char_AudioNotes= AudioNotes.c_str();
  
  std::string split_SceneTitle;
  split_SceneTitle = SceneTitle.substr(0,20);
  Glib::locale_from_utf8 ( split_SceneTitle);
  char_SceneTitle =  split_SceneTitle.c_str();

  Glib::ustring img_file_name="Panel";
  Glib::ustring int_to_string_value;
  Glib::ustring img_file_extension=".png";
  Glib::ustring img_full_name_with_extension;

  cairo_rectangle(cr, abs_rec, rec1, 170.074, 10.577);     
  cairo_stroke(cr); 		
  cairo_rectangle(cr, abs_rec, rec2, 170.074, 106.401);     
  cairo_stroke(cr); 	

  img_number = img_number + 1;
  int_to_string_value = boost::lexical_cast<std::string>(img_number);
  img_full_name_with_extension = thumbnail_tmp_path + img_file_name + int_to_string_value + img_file_extension;
  const char * abc11 = img_full_name_with_extension.c_str();
  Glib::RefPtr<Gdk::Pixbuf> m_orig;
  m_orig = Gdk::Pixbuf::create_from_file (abc11);
  Gtk::Image m_image;
  Glib::RefPtr<Gdk::Pixbuf> buff = m_orig->scale_simple(242,138, Gdk::INTERP_BILINEAR);
  buff->save(abc11, "png"); 

  image = cairo_image_surface_create_from_png(abc11);
  cairo_set_source_surface(cr, image, ima2, ima1);
  cairo_paint(cr);

  cairo_set_source_rgb(cr, 0, 0, 0);
  cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
  cairo_set_font_size(cr, 6);

  cairo_set_source_rgb(cr, 0, 0, 0); 
  cairo_move_to(cr, x_cor6, scene);
  cairo_show_text(cr, "Scene No");
  cairo_move_to(cr, x_cor7, scene);
  cairo_show_text(cr, ":");
  cairo_move_to(cr, x_cor8, scene);
  cairo_show_text(cr, char_SceneNumber);

  cairo_move_to(cr, x_cor9, scene);
  cairo_show_text(cr, "Shot No");
  cairo_move_to(cr,  x_cor10, scene);
  cairo_show_text(cr, ":");
  cairo_move_to(cr,  x_cor11, scene);
  cairo_show_text(cr, char_ShotNumber);

  cairo_move_to(cr, x_cor3 ,  scene);
  cairo_show_text(cr, "Shot Type");
  cairo_move_to(cr, x_cor4 ,  scene);
  cairo_show_text(cr, ":");
  cairo_move_to(cr, x_cor5,  scene);
  cairo_show_text(cr, char_ShotType);
  cairo_set_source_rgb(cr, 0, 0, 0);

  cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
  cairo_set_font_size(cr, 9);
  cairo_move_to(cr, x_cor, title);

  cairo_show_text(cr, "Scene Title");
  cairo_move_to(cr, x_cor1, title);	
  cairo_show_text(cr, ":");
  cairo_move_to(cr, x_cor2, title);
  cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
  cairo_set_font_size(cr, 6.5);
  
  cairo_show_text(cr, char_SceneTitle);

  cairo_move_to(cr, x_cor, audnotes);
  cairo_show_text(cr, "Script/Audio");
  cairo_move_to(cr, x_cor1, audnotes);
  cairo_show_text(cr, ":");

  cairo_move_to(cr, x_cor, frames);
  cairo_show_text(cr, "Decription");
  cairo_move_to(cr, x_cor1, frames);
  cairo_show_text(cr, ":");

  cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
  cairo_set_font_size(cr, 5);
  cairo_move_to(cr, x_cor, title);

  cairo_move_to(cr, x_cor2, audnotes);
  cairo_show_text(cr, char_AudioNotes1);

  cairo_move_to(cr, x_cor, audnotes1);
  cairo_show_text(cr, char_AudioNotes2);

  cairo_move_to(cr, x_cor, audnotes2);
  cairo_show_text(cr, char_AudioNotes3);

  cairo_move_to(cr, x_cor2, frames);
  cairo_show_text(cr, char_ActionNotes1);

  cairo_move_to(cr, x_cor, frames1);
  cairo_show_text(cr, char_ActionNotes2);

  cairo_move_to(cr, x_cor	, frames2);
  cairo_show_text(cr, char_ActionNotes3);

  abs_rec=abs_rec+261.105;
  x_cor=x_cor+261.105;
  x_cor1=x_cor1+261.105;
  x_cor2=x_cor2+261.105;
  x_cor3=x_cor3+261.105;
  x_cor4=x_cor4+261.105;
  x_cor5=x_cor5+261.105;
  x_cor6=x_cor6+261.105;
  x_cor7=x_cor7+261.105;
  x_cor8=x_cor8+261.105;
  x_cor9=x_cor9+261.105;
  x_cor10=x_cor10+261.105;
  x_cor11=x_cor11+261.105;
  ima2=ima2+261.105;

  if((page_number%3==0) && (page_number%6!=0))
  {
    rec1=rec1+230.469;
    rec2=rec2+230.469;
    scene=scene+230.469;
    frames=frames+230.469;
    frames1=frames1+230.469;
    frames2=frames2+230.469;
    audnotes=audnotes+230.469;
    audnotes1=audnotes1+230.469;
    audnotes2=audnotes2+230.469;
    title=title+230.469;
    dialogue=dialogue+230.469;
    action=action+230.469;
    ima1=ima1+230.469;

    abs_rec=abs_rec-783.315;
    x_cor=x_cor-783.315;
    x_cor1=x_cor1-783.315;
    x_cor2=x_cor2-783.315;
    x_cor3=x_cor3-783.315;
    x_cor4=x_cor4-783.315;
    x_cor5=x_cor5-783.315;
    x_cor6=x_cor6-783.315;
    x_cor7=x_cor7-783.315;
    x_cor8=x_cor8-783.315;
    x_cor9=x_cor9-783.315;
    x_cor10=x_cor10-783.315;
    x_cor11=x_cor11-783.315;
    ima2=ima2-783.315;
  }

  else if(page_number%6==0)
  {
    rec1=rec1-230.469;
    rec2=rec2-230.469;
    scene=scene-230.469;
    frames=frames-230.469;
    frames1=frames1-230.469;
    frames2=frames2-230.469;
    audnotes=audnotes-230.469;
    audnotes1=audnotes1-230.469;
    audnotes2=audnotes2-230.469;
    title=title-230.469;
    dialogue=dialogue-230.469;
    action=action-230.469;
    ima1=ima1-230.469;

    abs_rec=abs_rec-783.315;
    x_cor=x_cor-783.315;
    x_cor1=x_cor1-783.315;
    x_cor2=x_cor2-783.315;
    x_cor3=x_cor3-783.315;
    x_cor4=x_cor4-783.315;
    x_cor5=x_cor5-783.315;
    x_cor6=x_cor6-783.315;
    x_cor7=x_cor7-783.315;
    x_cor8=x_cor8-783.315;
    x_cor9=x_cor9-783.315;
    x_cor10=x_cor10-783.315;
    x_cor11=x_cor11-783.315;
    ima2=ima2-783.315;
    if(page_number+1<=count_kljm)
    {
      cairo_show_page(cr); 
      cairo_rectangle(cr, 49.492, 53.229, 744.00, 506.34);     
      cairo_stroke(cr); 	
      cairo_select_font_face(cr, "Sans", CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_NORMAL);
      cairo_set_font_size(cr, 9.0);
      cairo_move_to(cr, 66.624, 543.550);
      cairo_show_text(cr, "Copyright to :");
      cairo_move_to(cr, 140, 543.550);
      cairo_show_text(cr, global_char_projectcopy );
      }
  }
  Scene = Scene->next_sibling("Scene");	
  }//while loop ends here
  cairo_show_page(cr); 
  cairo_surface_destroy(surface);
  cairo_destroy(cr);
}

void KalanjiyamWindow::get_kalanjiyam_properties()
{
  ProjectName=pProjectName->get_text();
  ProjectClient=pProjectClient->get_text();
  ProjectCopyright=pProjectCopy->get_text();

  std::string result = ProjectName ;
  boost::replace_all(result, "\n", "");
  ProjectName = result.substr(0,40);

  result = ProjectClient ;
  boost::replace_all(result, "\n", "");
  ProjectClient = result.substr(0,40);

  result = ProjectCopyright;
  boost::replace_all(result, "\n", "");
  ProjectCopyright = result.substr(0,100);

  Glib::locale_from_utf8 (ProjectName);
  Glib::locale_from_utf8 (ProjectClient);
  Glib::locale_from_utf8 (ProjectCopyright);

  global_char_projectname = ProjectName.c_str();
  global_char_projectclient = ProjectClient.c_str();
  global_char_projectcopy = ProjectCopyright.c_str();

  Projectsize= preference_m_Combo.get_active_text();
  Glib::locale_from_utf8 (Projectsize);
  global_char_projectsize = Projectsize.c_str();
}

void KalanjiyamWindow::file_print_all()
{
  std::string file_path = active_file_name1;
  file_print(file_path.c_str());
  file_path = active_file_name2;
  file_print(file_path.c_str());
  file_path = active_file_name3;
  file_print(file_path.c_str());
}

void KalanjiyamWindow::file_print_file1()
{
  try
  {
    if (strcmp(active_file_name1.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    std::string file_path = active_file_name1;
    file_print(file_path.c_str());
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No Pdf File Exported Yet...");
    pInfoDialog->show();
    pSbar->push("No Pdf File Exported Yet...");
  }	
}

void KalanjiyamWindow::file_print_file2()
{
  try
  {
    if (strcmp(active_file_name2.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    std::string file_path = active_file_name2;
    file_print(file_path.c_str());
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No Pdf File Exported Yet...");
    pInfoDialog->show();
    pSbar->push("No Pdf File Exported Yet...");
  }	}

void KalanjiyamWindow::file_print_file3()
{
  try
  {
    if (strcmp(active_file_name3.c_str(), "" ) == 0)
    {
    throw 1;
    }
    else
    {
    std::string file_path = active_file_name3;
    file_print(file_path.c_str());
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("No Pdf File Exported Yet...");
    pInfoDialog->show();
    pSbar->push("No Pdf File Exported Yet...");
  }	
}

void KalanjiyamWindow::file_print(Glib::ustring pdfFileName)
{
  std::string file_to_print = "lpr " + pdfFileName;
  try
  {
    if(system(file_to_print.c_str())==0)
    {
    std::string status = "File Printed : " + pdfFileName;
    pSbar->push(status);
    }
    else
    {
    throw 1;	
    }
  }
  catch(int e)
  {
    pSbar->push("Unable to Print File...");	
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Print the File...");
    pInfoDialog->show();
  }
}

void KalanjiyamWindow::file_quit_confirm()
{
if(mcanvas_show_flag==1)
{
  ConfirmStatus = 1;
  Glib::ustring msg;
  if (strcmp(active_file_name.c_str(), "" ) == 0)
  {
  msg = "File Not Yet Saved. Do You Want To Close... ?";
  }
  else
  {
  msg = "Do You Want To Exit From Kalanjiyam ?";
  }
  pConfirmLabel->set_text(msg.c_str());
  pConfirmDialog->show();
}
else
file_quit();
}

void KalanjiyamWindow::file_quit()
{
  group_var="";
  try
  {
    if(system("exec rm -r /tmp/Kalanjiyam")==0)
    {
    pSbar->push("Kalanjiyam Exited...");	
    }
    else
    {
    throw 1;	
    }
  }
  catch(int e)
  {
    pSbar->push("Unable to Exit From Kalanjiyam...");	
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Exit...");
    pInfoDialog->show();
  }
  pDialog->hide();
  Py_Finalize();
} 
/*file menu definition ends*/

void KalanjiyamWindow::edit_copy()
{
  if(group_child_no.size()>0)		//Multi select + Single + Group item
  {
    copy_tag_vector.erase(copy_tag_vector.begin(), copy_tag_vector.end());
    copy_group_temp_vector.erase(copy_group_temp_vector.begin(), copy_group_temp_vector.end());
    copy_single_temp_vector.erase(copy_single_temp_vector.begin(), copy_single_temp_vector.end());
    copy_status=0;

    pSbar->push("Copied...");	
    int group_length;
    copy_status=3;
    for(int z=0; z<group_child_no.size(); z++)
    {
      int chi_no=group_child_no[z];
      std::string obj = xml_scene_overall_tag[chi_no-1];
      copy_tag_vector.push_back(obj);
      copy_single_temp_vector.push_back(chi_no);
      //To find this child number is in a group or not?	//Code starts here
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==chi_no)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no!=-1)
      {
        group_length=0;
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {	
          group_length++;
          }
          k++;
        }
        for(int i=1; i<=group_length-1; i++)
        {
          int chi_no1=group_child_no[z+i]; 
          std::string obj1 = xml_scene_overall_tag[chi_no1-1];
          copy_tag_vector.push_back(obj1);
          copy_single_temp_vector.push_back(chi_no1);
        }
        tokenizer<> toki(group_child_total_list[group_child_same_no]);
        int l=1;
        for(tokenizer<>::iterator beg=toki.begin(); beg!=toki.end();++beg)
        {
          if(l!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              tokenizer<> toki(group_child_total_list[i]);
              tokenizer<>::iterator beg=toki.begin();
              if(*beg=="G")
              {
                for(tokenizer<>::iterator beg=toki.begin(); beg!=toki.end();++beg)
                {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
                  if(child_in_total_list1==child_in_total_list)
                  {
                    if(l==2)
                    {  
                    copy_single_index_temp_vector.push_back(i);
                    }
                    else
                    {
                      int same_index_check=0;
                      for(int j=0; j<copy_single_index_temp_vector.size(); j++)
                      {
                        if(copy_single_index_temp_vector[j]==i)
                        {
                        same_index_check=1;
                        }
                      }
                      if(same_index_check==0)
                      copy_single_index_temp_vector.push_back(i);
                    }
                  }
                }
              }
            }
          }
          l++;
        }
        std::sort (copy_single_index_temp_vector.begin(), copy_single_index_temp_vector.end());
        for(int i=0; i<copy_single_index_temp_vector.size(); i++)
        {
          std::string variable="";
          tokenizer<> tok(group_child_total_list[copy_single_index_temp_vector[i]]);
          int l=1;
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            if(l!=1)
            {
              int child_in_total_list1;
              std::stringstream str(*beg);
              str>>child_in_total_list1;
              tokenizer<> tok(group_child_total_list[child_in_total_list1]);
              int k=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(k!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(l==2)
                  {
                  Glib::ustring int_to_string_value1 = boost::lexical_cast<std::string>(child_in_total_list);
                  variable=int_to_string_value1;
                  }
                  else
                  {
                  Glib::ustring int_to_string_value1 = boost::lexical_cast<std::string>(child_in_total_list);
                  variable=variable+","+int_to_string_value1;
                  }
                }
                k++;
              }
            }
            l++;
          }
          copy_group_temp_vector.push_back(variable);
        }
        copy_single_index_temp_vector.erase(copy_single_index_temp_vector.begin(),copy_single_index_temp_vector.end());
        z=z+group_length-1;
      }
      //To find this child number is in a group or not?	//Code ends here
    }
    control_points_selected_items_remove();
  }
  else if(move_var>0)
  {
    copy_tag_vector.erase(copy_tag_vector.begin(), copy_tag_vector.end());
    copy_group_temp_vector.erase(copy_group_temp_vector.begin(), copy_group_temp_vector.end());
    copy_single_temp_vector.erase(copy_single_temp_vector.begin(), copy_single_temp_vector.end());
    copy_status=0;

    pSbar->push("Copied...");	
    int n = changed_item_num;
    find_group_or_not(n,"single_if","sort_false","edit_copy");
    if(copy_status==1)		//Single Child item	Only
    {
      std::string obj = xml_scene_overall_tag[n-1];
      copy_tag_vector.push_back(obj);
      control_points_selected_items_remove();
    }
    else if(copy_status==2)		//Group Child item Only
    {
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==n)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no!=-1)
      {
        tokenizer<> toki(group_child_total_list[group_child_same_no]);
        int l=1;
        for(tokenizer<>::iterator beg=toki.begin(); beg!=toki.end();++beg)
        {
          if(l!=1)
          {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          group_child_no.push_back(child_in_total_list);
          }
          l++;
        }
        for(int i=0; i<group_child_no.size(); i++)
        {
          tokenizer<> tok(group_child_total_list[group_child_no[i]]);
          int k=1;
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            if(k!=1)
            {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            copy_single_temp_vector.push_back(child_in_total_list);
            }
            k++;
          }
        }
        group_child_no.erase(group_child_no.begin(),group_child_no.end());
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              tokenizer<> tok(group_child_total_list[i]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="G")
              {
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
                  if(child_in_total_list1==child_in_total_list)
                  {
                    if(k==2)
                    {
                    group_child_no.push_back(i);
                    }
                    else
                    {
                      int same_index_check=0;
                      for(int j=0; j<group_child_no.size(); j++)
                      {
                        if(group_child_no[j]==i)
                        same_index_check=1;
                      }
                      if(same_index_check==0)
                      group_child_no.push_back(i);
                    }
                  }	
                }
              }
            }
          }
          k++;
        }
        std::sort (group_child_no.begin(), group_child_no.end());
        for(int i=0; i<group_child_no.size(); i++)
        {
          std::string variable="";
          tokenizer<> tok(group_child_total_list[group_child_no[i]]);
          int l=1;
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            if(l!=1)
            {
              int child_in_total_list1;
              std::stringstream str(*beg);
              str>>child_in_total_list1;
              tokenizer<> tok(group_child_total_list[child_in_total_list1]);
              int k=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(k!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(l==2)
                  {
                  Glib::ustring int_to_string_value1 = boost::lexical_cast<std::string>(child_in_total_list);
                  variable=int_to_string_value1;
                  }
                  else
                  {
                  Glib::ustring int_to_string_value1 = boost::lexical_cast<std::string>(child_in_total_list);
                  variable=variable+","+int_to_string_value1;
                  }
                }
                k++;
              }
            }
            l++;
          }
          copy_group_temp_vector.push_back(variable);
        }
        group_child_no.erase(group_child_no.begin(),group_child_no.end());
      }
      for(int i=0; i<grouped_child_no.size(); i++)	//This grouped vector is filled, while the find group or not checking function
      {
        int chi_no=grouped_child_no[i];
        std::string obj = xml_scene_overall_tag[chi_no-1];
        copy_tag_vector.push_back(obj);
      }
      control_points_selected_items_remove();
      grouped_child_no.erase(grouped_child_no.begin(), grouped_child_no.end());
    }
  }
} 

void KalanjiyamWindow::edit_paste()
{
  control_points_selected_items_remove();
  if(copy_tag_vector.size()!=0)
  {
    pSbar->push("Pasted...");	
    std::string paste_item_tags;
    for(int i=0; i<copy_tag_vector.size(); i++)
    {
    if(i==0)
    paste_item_tags=copy_tag_vector[i];
    else
    paste_item_tags=paste_item_tags+" "+copy_tag_vector[i];
    }
    std::string test = "<Kalanjiyam> <Scene> "+paste_item_tags+" </Scene> </Kalanjiyam>";
    const std::string input_xml = test;
    vector<char> xml_copy(input_xml.begin(), input_xml.end());
    xml_copy.push_back('\0');
    xml_document<> doc;
    doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
    xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
    xml_node<>* Scene = Kalanjiyam->first_node("Scene");
    xml_node<> * abc;

//undo-redo-code-starts here
//undo-redo-code-starts here
	if(undo_count>0)
	{
	  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
	  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
	  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
	  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
	  undo_count=0;
	}
	copy_paste_status=1;
	int status=8;
	int position=-1;
	std::string val1="CopyPasteStarts";
	std::string val2="GroupValues";
	std::string val3="CopyPasteEnds";
	undo_redo_tag_vector.push_back(val1);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(position);
	undo_redo_position_vector.push_back(position);
	if(group_child_total_list.size()==0)
      group_child_total_list.push_back("Group Vector");
//undo-redo-code-ends here
//undo-redo-code-ends here

    int before_paste_total_child_num;
	if(grid_mode==0)
      before_paste_total_child_num=child_num;
    else
      before_paste_total_child_num=child_num-1;

    while (Scene != NULL )
    {
      for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
      {
        for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
        {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          /*Create drawings in working area begins*/
          if (strcmp(node_name, "Rectangle") == 0)
          {
            if (strcmp(attribute_name, "x") == 0) 
            {
            open_global_x = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "y") == 0) 
            {
            open_global_y = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "width") == 0) 
            {
            open_global_width = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "height") == 0) 
            {
            open_global_height = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "xradius") == 0) 
            {
            open_global_xradius = atoi(attribute_value);
            }
            else if (strcmp(attribute_name, "yradius") == 0) 
            {
            open_global_yradius = atoi(attribute_value);
            }
            else if (strcmp(attribute_name, "strokecolor") == 0) 
            {
            open_global_strokecolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "fillcolor") == 0) 
            {
            open_global_fillcolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "linewidth") == 0) 
            {
            open_global_linewidth = atoi(attribute_value);
            }
            else if (strcmp(attribute_name, "xposition") == 0) 
            {
            open_global_xposition = atof(attribute_value)+10;
            }
            else if (strcmp(attribute_name, "yposition") == 0) 
            {
            open_global_yposition = atof(attribute_value)+10;
            }			
          }
          else if (strcmp(node_name, "Ellipse") == 0)
          {
            if (strcmp(attribute_name, "centerx") == 0) 
            {
            open_global_centerx = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "centery") == 0) 
            {
            open_global_centery = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "yradius") == 0) 
            {
            open_global_yradius = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "xradius") == 0) 
            {
            open_global_xradius = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "strokecolor") == 0) 
            {
            open_global_strokecolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "fillcolor") == 0) 
            {
            open_global_fillcolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "linewidth") == 0) 
            {
            open_global_linewidth = atoi(attribute_value);
            }
            else if (strcmp(attribute_name, "xposition") == 0) 
            {
            open_global_xposition = atof(attribute_value)+10;
            }
            else if (strcmp(attribute_name, "yposition") == 0) 
            {
            open_global_yposition = atof(attribute_value)+10;
            }					
          }
          else if (strcmp(node_name, "Line") == 0)
          {
            if (strcmp(attribute_name, "x1") == 0) 
            {
            open_global_x1 = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "y1") == 0) 
            {
            open_global_y1 = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "x2") == 0) 
            {
            open_global_x2 = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "y2") == 0) 
            {
            open_global_y2 = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "strokecolor") == 0) 
            {
            open_global_strokecolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "linewidth") == 0) 
            {
            open_global_linewidth = atoi(attribute_value);
            }
            else if (strcmp(attribute_name, "height") == 0) 
            {
            open_global_height = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "width") == 0) //If curve means no fill color. But star, arrow means fill color will come ->Do check here
            {
            open_global_width = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "xposition") == 0) 
            {
            open_global_xposition = atof(attribute_value)+10;
            }
            else if (strcmp(attribute_name, "yposition") == 0) 
            {
            open_global_yposition = atof(attribute_value)+10;
            }	
          }
          else if (strcmp(node_name, "Path") == 0)
          {
            if (strcmp(attribute_name, "data") == 0) 
            {
            open_global_data = attribute_value;
            }
			if (strcmp(attribute_name, "py_data") == 0) 
            {
            open_global_python_data = attribute_value;
            }
            else if (strcmp(attribute_name, "strokecolor") == 0) 
            {
            open_global_strokecolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "fillcolor") == 0) //If curve means no fill color. But star, arrow means fill color will come ->Do check here
            {
            open_global_fillcolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "linewidth") == 0) 
            {
            open_global_linewidth = atoi(attribute_value);
            }
            else if (strcmp(attribute_name, "height") == 0) 
            {
            open_global_height = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "width") == 0) 
            {
            open_global_width = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "xposition") == 0) 
            {
            open_global_xposition = atof(attribute_value)+10;
            }
            else if (strcmp(attribute_name, "yposition") == 0) 
            {
            open_global_yposition = atof(attribute_value)+10;
            }	
          }
          else if (strcmp(node_name, "Image") == 0)
          {
            if (strcmp(attribute_name, "data") == 0) 
            {
            open_global_data = attribute_value;
            }
			if (strcmp(attribute_name, "ImageData") == 0 ) 
			{
			open_global_image_data = attribute_value;		
			}
			if (strcmp(attribute_name, "py_data") == 0 ) 
			{
			open_global_python_data = attribute_value;
			}
            else if (strcmp(attribute_name, "height") == 0) 
            {
            open_global_height = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "width") == 0) //If curve means no fill color. But star, arrow means fill color will come ->Do check here
            {
            open_global_width = atof(attribute_value);
            }
            else if (strcmp(attribute_name, "xposition") == 0) 
            {
            open_global_xposition = atof(attribute_value)+10;
            }
            else if (strcmp(attribute_name, "yposition") == 0) 
            {
            open_global_yposition = atof(attribute_value)+10;
            }
          }
          else if (strcmp(node_name, "Text") == 0)
          {
            if (strcmp(attribute_name, "data") == 0) 
            {
            open_global_data = attribute_value;
            }
            else if (strcmp(attribute_name, "xposition") == 0) 
            {
            open_global_xposition = atof(attribute_value)+10;
            }
            else if (strcmp(attribute_name, "yposition") == 0) 
            {
            open_global_yposition = atof(attribute_value)+10;
            }
            else if (strcmp(attribute_name, "fillcolor") == 0)
            {
            open_global_fillcolor_hex = attribute_value;
            }
            else if (strcmp(attribute_name, "font") == 0)
            {
            open_global_font = attribute_value;
            }
          }
          else if (strcmp(node_name, "Group") == 0)
          { 
            if (strcmp(attribute_name, "data") == 0) 
            {
              Glib::ustring int_to_string_value;
              std::string vector_child_value;
              std::string vector_group_value;
              stringstream char_input;
              string string_output;

              char_input<<attribute_value;
              char_input>>string_output;

              tokenizer<> tok(string_output);
              int l=0;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                l++;
                int child_number;
                std::stringstream str(*beg);
                str>>child_number;
                int_to_string_value = boost::lexical_cast<std::string>(child_number);
                vector_child_value="S,"+int_to_string_value;

                group_child_no.push_back(child_number);		//To push the child_number value for temporary buffer
                if(group_child_total_list.size()==0)
                group_child_total_list.push_back("Group Vector");

                //To check whether the child_value is already in group_child_total_list_vector or not ?	//Code starts here
                int group_child_total_list_same_no=0;
                for(int i=0; i<group_child_total_list.size(); i++)	//Selected item childs compare with grouped child items
                {
                  tokenizer<> tok(group_child_total_list[i]);
                  tokenizer<>::iterator beg=tok.begin();
                  if(*beg=="S")
                  {
                    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                    {
                      int child_in_total_list;
                      std::stringstream str(*beg);
                      str>>child_in_total_list;
                      if(child_in_total_list==child_number)
                      {
                      group_child_total_list_same_no=1;
                      break;
                      }	
                    }
                  }
                }
                //To check whether the child_value is already in group_child_total_list_vector or not ?	//Code ends here

                if(group_child_total_list_same_no==0)
                group_child_total_list.push_back(vector_child_value);
              }
              //To store the group vector numbers	//Code starts here
              for(int i=0; i<group_child_no.size(); i++)	//Selected item childs in buffer
              {
                int group_child_total_list_same_no=-1;
                for(int j=0; j<group_child_total_list.size(); j++)	//Selected item childs compare with grouped child items
                {
                  tokenizer<> tok(group_child_total_list[j]);
                  tokenizer<>::iterator beg=tok.begin();
                  if(*beg=="S")
                  {
                    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                    {
                      int child_in_total_list;
                      std::stringstream str(*beg);
                      str>>child_in_total_list;
                      if(child_in_total_list==group_child_no[i])
                      {
                      group_child_total_list_same_no=j;
                      break;
                      }	
                    }
                  }
                }
                if(group_child_total_list_same_no!=-1)	//If same, it will be a total group
                {
                int_to_string_value = boost::lexical_cast<std::string>(group_child_total_list_same_no);
                if(i==0)
                vector_group_value="G,"+int_to_string_value;					
                else
                vector_group_value=vector_group_value+","+int_to_string_value;
                }
              }
              group_child_total_list.push_back(vector_group_value);
              //To store the group vector numbers //Code ends here
              group_child_no.erase(group_child_no.begin(),group_child_no.end());	//To empty the group_child_no vector
            }	
          }
          /*Create drawings in working area ends*/
        }
        if (strcmp(open_node_name, "Rectangle") == 0)
        {
          open_create_rectangle();
          create_xml_for_rectangle();
        }
        else if (strcmp(open_node_name, "Ellipse") == 0)
        {
          open_create_ellipse();
          create_xml_for_ellipse();
        }
        else if (strcmp(open_node_name, "Line") == 0)
        {
          open_create_line();
          create_xml_for_line();
        }
        else if (strcmp(open_node_name, "Path") == 0)
        {
          open_create_path();
          Glib::ustring node_value = open_node_value;
          Glib::ustring node_value1 = "" + node_value + "";
          create_xml_for_path(node_value1);
        }	
        else if (strcmp(open_node_name, "Image") == 0)
        {

		my_str1_tag = "";

		my_str1_tag = open_global_data;

		std::vector<std::string>split_x_y1;
		std::vector<std::string>combined_x_y1;   

		std::string delimiter = ",";
		std::string storestring="";

		 string strvalue1;
		 string strvalue2;
		 stringstream stream(my_str1_tag);


		 while( getline(stream, strvalue1, ' ') )
		 {
			 split_x_y1.push_back(strvalue1);

		 }


		string dis_x_str;
		string dis_y_str;

		float dis_x_int;
		float dis_y_int;
		int a_size=split_x_y1.size();



		for (int g=0; g<split_x_y1.size(); g++)
		{
			if(g==a_size-1)//|| split_x_y1[g]== "z") && (split_x_y1[g++]!="M"))
			{

			combined_x_y1.push_back("Z");
			break;
			//g = g++;
			}
			if((split_x_y1[g]=="Z" || split_x_y1[g]=="z") && (g!=a_size-1))
			{

			combined_x_y1.push_back(split_x_y1[g]);
			g=g++;
			}

			if(split_x_y1[g]=="M" || split_x_y1[g]== "L")
			{

				if(split_x_y1[g]=="M")
				{
				combined_x_y1.push_back(split_x_y1[g]);
				g = g++;
				}
				else	if(split_x_y1[g]=="L")
				{
				combined_x_y1.push_back(split_x_y1[g]);
				g = g++;
				}
				dis_x_str =split_x_y1[g];
			 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
				dis_x_int = dis_x_int + 10;
				dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
				combined_x_y1.push_back(dis_x_str);


				g = g++;
				dis_y_str =split_x_y1[g];
				dis_y_int =boost::lexical_cast<float>(dis_y_str);
				dis_y_int= dis_y_int + 10;
				dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
				combined_x_y1.push_back(dis_y_str);			
			}   

		}
		my_str1_tag="";
		for (int g=0; g<combined_x_y1.size(); g++)
		{
		 if(g==0)
			 my_str1_tag = combined_x_y1[g] ;
		 else
			 my_str1_tag = my_str1_tag+" "+combined_x_y1[g] ;
		}
		// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
		//come_from_line_change1 = 1;
		open_global_data =  my_str1_tag;
		open_create_image();
		create_xml_for_image();
        }
        else if (strcmp(open_node_name, "Text") == 0)
        {
          open_create_text();
          create_xml_for_text();
        }
        else if (strcmp(open_node_name, "Group") == 0)
        {
          open_create_group();
          create_xml_for_group();
        }
      }
      Scene = Scene->next_sibling("Scene");	
    }
//undo-redo-code-starts here
//undo-redo-code-starts here
	undo_redo_tag_vector.push_back(val2);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(position);
	undo_redo_position_vector.push_back(position);
//undo-redo-code-ends here
//undo-redo-code-ends here
    if(copy_status==2 || copy_status==3)
    {
      for(int j=0; j<copy_group_temp_vector.size(); j++)
      {
        std::string copy_group_variable1="G";
        tokenizer<> tok(copy_group_temp_vector[j]);
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;	
          for(int i=0; i<copy_single_temp_vector.size(); i++)
          {
            if(child_in_total_list==copy_single_temp_vector[i])	
            {
              int child_no_checking=before_paste_total_child_num+i+1;
			  std::string single_variable="S";
              Glib::ustring int_to_string_value1 = boost::lexical_cast<std::string>(child_no_checking);
              single_variable=single_variable+","+int_to_string_value1;
			  group_child_total_list.push_back(single_variable);

  			  //undo-redo-code-starts here
			  //undo-redo-code-starts here
			  undo_redo_tag_vector.push_back(single_variable);
			  undo_redo_delete_status_vector.push_back(status);
			  undo_redo_child_number_vector.push_back(group_child_total_list.size()-1);
			  undo_redo_position_vector.push_back(position);
			  //undo-redo-code-ends here
			  //undo-redo-code-ends here

              Glib::ustring int_to_string_value2 = boost::lexical_cast<std::string>(group_child_total_list.size()-1);
              copy_group_variable1=copy_group_variable1+","+int_to_string_value2;
            }
          }
        }
        group_child_total_list.push_back(copy_group_variable1);

	    //undo-redo-code-starts here
	    //undo-redo-code-starts here
	    undo_redo_tag_vector.push_back(copy_group_variable1);
	    undo_redo_delete_status_vector.push_back(status);
	    undo_redo_child_number_vector.push_back(group_child_total_list.size()-1);
	    undo_redo_position_vector.push_back(position);
		//undo-redo-code-ends here
		//undo-redo-code-ends here
      }
    }
//undo-redo-code-starts here
//undo-redo-code-starts here
	undo_redo_tag_vector.push_back(val3);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(position);
	undo_redo_position_vector.push_back(position);
	standing_position=undo_redo_tag_vector.size()-1;
	copy_paste_status=0;
//undo-redo-code-ends here
//undo-redo-code-ends here
  }
} 

void KalanjiyamWindow::edit_moveUp()
{
  navi_movement("up");
  pSbar->push("Move Up Clicked ...");	
}
void KalanjiyamWindow::edit_moveDown()
{
  navi_movement("down");
  pSbar->push("Move Down Clicked ...");	
}
void KalanjiyamWindow::edit_moveLeft()
{
  navi_movement("left");
  pSbar->push("Move Left Clicked ...");	
}
void KalanjiyamWindow::edit_moveRight()
{
  navi_movement("right");
  pSbar->push("Move Right Clicked ...");	
}

void KalanjiyamWindow::edit_group()
{
  pSbar->push("Grouped...");	
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(group_child_no.size()>0)		
  {
    int chi_del=child_num-group_item_no+1;
    for(child_var=chi_del; child_var<=child_num; child_var++)
    {
    root->remove_child(chi_del);
    group_child_region_no.pop_back();
    }
    child_num=child_num-group_item_no;
    std::sort (group_xx.begin(), group_xx.end());
    std::sort (group_yy.begin(), group_yy.end());
    std::sort (group_end_xx.begin(), group_end_xx.end(), std::greater<double>());
    std::sort (group_end_yy.begin(), group_end_yy.end(), std::greater<double>());
    grp_xx=group_xx[0];
    grp_yy=group_yy[0];
    grp_ww=group_end_xx[0]-grp_xx;
    grp_hh=group_end_yy[0]-grp_yy;
    Glib::RefPtr<Goocanvas::Rect> rect1 ;
    rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
    #ifdef GLIBMM_PROPERTIES_ENABLED
    rect1->property_stroke_color() = "red" ;
    rect1->property_line_width() = 0.5 ;
    #endif
    root->add_child(rect1);
    child_num=child_num+1;
    first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
    second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
    third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
    fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
    fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
    sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
    seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
    eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);
    Glib::ustring int_to_string_value;
    std::string total_arr;

    //The first value of the Total group vector	//Code starts here
    if(group_child_total_list.size()==0)
    {
    group_child_total_list.push_back("Group Vector");
    }
    //Code ends here

    //To store each and every as "S" child item	//Code starts here
    std::sort (group_child_no.begin(), group_child_no.end()); 
    for(int i=0; i<group_child_no.size(); i++)	//Selected item childs in buffer
    {
      int group_child_total_list_same_no=-1;
      for(int j=0; j<group_child_total_list.size(); j++)	//Selected item childs compare with grouped child items
      {
        tokenizer<> tok(group_child_total_list[j]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==group_child_no[i])
            {
            group_child_total_list_same_no=j;
            break;
            }	
          }
        }
      }
      if(group_child_total_list_same_no==-1)	//If not same, it will be a single group
      {
      int_to_string_value = boost::lexical_cast<std::string>(group_child_no[i]);
      total_arr="S,"+int_to_string_value;
      group_child_total_list.push_back(total_arr);			
      }
    }
    //Code ends here

    //To check whether the selected item is a group or not ? 	//Code starts here
    for(int i=0; i<group_child_no.size(); i++)	//Selected item childs in buffer
    {
      int group_child_total_list_same_no=-1;
      for(int j=0; j<group_child_total_list.size(); j++)	//Selected item childs compare with grouped child items
      {
        tokenizer<> tok(group_child_total_list[j]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==group_child_no[i])
            {
            group_child_total_list_same_no=j;
            break;
            }	
          }
        }
      }
      if(group_child_total_list_same_no!=-1)	//If same, it will be a total group
      {
      int_to_string_value = boost::lexical_cast<std::string>(group_child_total_list_same_no);
      if(i==0)
      total_arr="G,"+int_to_string_value;					
      else
      total_arr=total_arr+","+int_to_string_value;
      }
    }
    group_child_total_list.push_back(total_arr);

//undo-redo-code-starts here
//undo-redo-code-starts here
	if(undo_status==0)
	{
	  if(undo_count>0)
	  {
		undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		undo_count=0;
	  }
	  undo_redo_tag_vector.push_back(total_arr);
	  undo_redo_child_number_vector.push_back(group_child_total_list.size()-1);	//For position find purpose
	  int grp_sts=3;
	  int position=-1;
	  undo_redo_delete_status_vector.push_back(grp_sts);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	//undo-redo-code-ends here
	//undo-redo-code-ends here

		//Code ends here
		eraser_grouped_child_no.clear();
		eraser_grouped_child_no=group_child_no;
		int child_no_size=group_child_no.size();
		for(int i=0; i<child_no_size; i++)
		{
		group_child_no.pop_back();
		group_xx.pop_back();
		group_yy.pop_back();
		group_end_xx.pop_back();
		group_end_yy.pop_back();
		}
		group_item_no=0;
	  }
	  update_tag_values();
}

void KalanjiyamWindow::edit_ungroup()
{
if(grouping_flag==1 && move_var>0)
{
  pSbar->push("UnGrouped...");	
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::ustring int_to_string_value;
  std::string total_arr;

  int single_child_same_no=-1;
  for(int i=0; i<group_child_total_list.size(); i++)
  {
    tokenizer<> tok(group_child_total_list[i]);
    tokenizer<>::iterator beg=tok.begin();
    if(*beg=="S")
    {
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
        if(child_in_total_list==last_child_num)
        {
        single_child_same_no=i;
        break;
        }	
      }
    }
  }
  int group_child_same_no=-1;
  for(int i=0; i<group_child_total_list.size(); i++)
  {
    tokenizer<> tok(group_child_total_list[i]);
    tokenizer<>::iterator beg=tok.begin();
    if(*beg=="G")
    {
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
        if(child_in_total_list==single_child_same_no)
        {
        group_child_same_no=i;
        }	
      }
    }
  }
//undo-redo-code-starts here
//undo-redo-code-starts here
if(undo_status==0)
{
  if(undo_count>0)
  {
	undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
	undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
	undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
	undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
	undo_count=0;
  }
  undo_redo_tag_vector.push_back(group_child_total_list[group_child_same_no]);
  undo_redo_child_number_vector.push_back(group_child_same_no);	//For position find purpose
  int grp_sts=4;
  int position=-1;
  undo_redo_delete_status_vector.push_back(grp_sts);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
}
//undo-redo-code-ends here
//undo-redo-code-ends here
  if(group_child_same_no!=-1)
  {
    for(int i=group_child_same_no; i<group_child_total_list.size()-1; i++)
    {
    group_child_total_list[i]=group_child_total_list[i+1];
    }
    for(int i=0; i<group_child_total_list.size()-1; i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="G")
      {
        int l=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(l!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list>=group_child_same_no)
            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
            else
            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
            if(l==2)
            total_arr="G,"+int_to_string_value;
            else
            total_arr=total_arr+","+int_to_string_value;
            //group_child_total_list[i]=total_arr;			
          }
          l++;
        }
        group_child_total_list[i]=total_arr;			
      }
    }
    group_child_total_list.pop_back();
  }
//undo-redo-code-starts here
//undo-redo-code-starts here
undo_redo_buffer_for_ungroup.clear();
undo_redo_buffer_for_ungroup=group_child_total_list;
//undo-redo-code-ends here
//undo-redo-code-ends here
}
}

void KalanjiyamWindow::edit_raise_to_front()
{
  current_clicked_item=changed_item_num;
  std::vector<int>store_image_vector_index;
  std::vector<std::string>changed_image_vector_values;
  int image_vector_position;
  int current_clicked_item_new;
  int current_clicked_next_item;
  std::string image_vector_position_str;
  std::string image_vector_position_value;
  std::string new_image_vector_position_value;
  std::vector<int>move_image_vector_value;

  int child_number1;
  if(grid_mode==1)
  child_number1=child_num-10;
  else if(grid_mode==0)
  child_number1=child_num-9;
  if(move_var>0 && current_clicked_item<child_number1)
  {
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    Glib::RefPtr< Goocanvas::Item > select_item ;
    Glib::RefPtr< Goocanvas::Item > next_item ;
    int next_item_num;
    select_item=root->get_child(changed_item_num);
    int s_xx, s_yy, s_ww, s_hh;		//Stored Values
    pSbar->push("Raised to Front...");	
    if(move_var>0)
    {
      int chi_del=child_num-8;
      for(child_var=chi_del; child_var<=child_num; child_var++)
      {
      root->remove_child(chi_del);
      }
      child_num=child_num-9;
    }

    find_group_or_not(changed_item_num,"single_if","sort_true","raise_current_child");	

    if(raise_current_child_temp_vector.size()>0)
    {
      std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end(), std::greater<double>());
      int b=raise_current_child_temp_vector[0];
      changed_item_num=b;
      next_item_num=changed_item_num+1;
      xx=grp_xx;
      yy=grp_yy;
      ww=grp_ww;
      hh=grp_hh;
    }
    else
    {
      next_item_num=changed_item_num+1;
    }
    s_xx=xx;
    s_yy=yy;
    s_ww=ww;
    s_hh=hh;

    int chi_number;
    if(grid_mode==1)
    chi_number=child_num;
    else if(grid_mode==0)
    chi_number=child_num+1;

    if(next_item_num<chi_number)
    {
      next_item=root->get_child(next_item_num);
      find_group_or_not(next_item_num,"single_if","sort_true","raise_next_child");
      if(raise_current_child_temp_vector.size()==0 && raise_next_child_temp_vector.size()==0)
      {
        select_item->raise(next_item);
        Glib::ustring int_to_string_value;
        std::string total_arr;
        int index_value;
        int next_to_current_clicked_item=changed_item_num+1;
        for(int i=0; i<group_child_total_list.size(); i++)
        {
          tokenizer<> tok(group_child_total_list[i]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
                int child_in_total_list;
                std::stringstream str(*beg);
                str>>child_in_total_list;
                if(child_in_total_list==next_to_current_clicked_item)
                {
                index_value=i;
                }
                else if(child_in_total_list==current_clicked_item)
                {
                int_to_string_value = boost::lexical_cast<std::string>(next_to_current_clicked_item);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[i]=total_arr;	

                }
              }
              l++;
            }
          }
        }

		/*SARU*/

		for(int g=0;g<for_image_indentification.size();g++)
		{
		  int counts=1;
		  string get_image_number = for_image_indentification[g] ;
		  Glib::ustring image_number;
		  Glib::ustring child_number_for_image;
		  tokenizer<> tok(get_image_number);
		  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		  {
			if(counts==1)
			image_number =*beg;
			else
			child_number_for_image=*beg;
			counts++;
		   }	
			 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
			 int  image_int = boost::lexical_cast<int>(image_number);


			current_clicked_next_item = current_clicked_item+1;

		   if(current_clicked_item==child_number_for_image_int)
				{
					number_for_image = image_int;
					image_vector_position = g;
				    image_vector_position_str = boost::lexical_cast<std::string>(g);
					current_clicked_item_new  = child_number_for_image_int+1;
					image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				}		

			if(current_clicked_next_item == child_number_for_image_int)
				{
					number_for_image = image_int;
					image_vector_position = g;
				    image_vector_position_str = boost::lexical_cast<std::string>(g);
					current_clicked_item_new  = child_number_for_image_int-1;
					current_clicked_next_item = current_clicked_item+1;
					image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				}		
			
		}

		for(int g=0;g<changed_image_vector_values.size();g++)
		{
		   string new_image_value =	changed_image_vector_values[g];


			 tokenizer<> tok(new_image_value);
			 int count=1;
			 Glib::ustring vector_no;
			 std::string image_no;
			 std::string item_no;
			 std::string delimiter = ",";
			 std::string storestring="";
			 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			 {
			   if(count==1)
				   vector_no=*beg;
			   else 
				  storestring=storestring + *beg ;
				  count++;
			 }
			 int  vector_no_int = boost::lexical_cast<int>(vector_no);
			 size_t pos = 0;
			 std::string token;
			 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
			 {
				token = changed_image_vector_values[g] .substr(0, pos);
				changed_image_vector_values[g] .erase(0, pos + delimiter.length());
			 }
			image_no=token;
			item_no=changed_image_vector_values[g];

			new_image_vector_position_value = image_no + "," + item_no;
	 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
		 }	

			/*SARU*/

        for(int j=0; j<group_child_total_list.size(); j++)
        {
          if(j==index_value)
          {
          int_to_string_value = boost::lexical_cast<std::string>(current_clicked_item);
          total_arr="S,"+int_to_string_value;
          group_child_total_list[j]=total_arr;
          }
        }
        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+next_item_num,xml_scene_overall_tag[changed_item_num-1]);
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+(changed_item_num-1));
        changed_item_num++;
      }
      else if(raise_current_child_temp_vector.size()==0 && raise_next_child_temp_vector.size()>0)
      {
        xx=s_xx;
        yy=s_yy;
        ww=s_ww;
        hh=s_hh;
        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end(), std::greater<double>());
        int g=raise_next_child_temp_vector.size()-1;

        Glib::RefPtr< Goocanvas::Item > temp_item ;
        int b=raise_next_child_temp_vector[0];
        int h=raise_next_child_temp_vector[g];
        temp_item=root->get_child(b);
        select_item->raise(temp_item);
        Glib::ustring int_to_string_value;
        std::string total_arr;
        for(int i=0; i<group_child_total_list.size(); i++)
        {
          tokenizer<> tok(group_child_total_list[i]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
                int child_in_total_list;
                std::stringstream str(*beg);
                str>>child_in_total_list;
                if(child_in_total_list==changed_item_num)
                {
                int_to_string_value = boost::lexical_cast<std::string>(b);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[i]=total_arr;

				/* SARU START*/

				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(changed_item_num==child_number_for_image_int)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(b);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
								
						 }
					}
				/* SARU END */		
			
                }
                else if(child_in_total_list<=b && child_in_total_list>changed_item_num)
                {
                int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[i]=total_arr;	



				/* SARU START */

				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
                		 if(child_number_for_image_int==child_in_total_list)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_in_total_list-1);
								new_image_vector_position_value = image_number + "," + image_vector_position_value;
						 		for_image_indentification.at(g) = new_image_vector_position_value;
								store_image_vector_index.push_back(g);								
						 }

					}
				/* SARU END*/				
                }
              }
              l++;
            }
          }
        }

		/*SARU START*/

			for(int g=0;g<for_image_indentification.size();g++)
				{
					int same_index_image=0;
					for(int g1=0;g1<store_image_vector_index.size();g1++)
					  {	 
						  if(store_image_vector_index[g1]==g)
						  {
							same_index_image =1;
						  }
					  }
					if(same_index_image==0)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(child_number_for_image_int==changed_item_num)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(b);
								new_image_vector_position_value = image_number + "," + image_vector_position_value;
						 		for_image_indentification.at(g) = new_image_vector_position_value;
								store_image_vector_index.push_back(g);								
						 }
						}
					}

			for(int g=0;g<for_image_indentification.size();g++)
				{
					int same_index_image=0;
 					for(int g1=0;g1<store_image_vector_index.size();g1++)
					  {	 
						  if(store_image_vector_index[g1]==g)
						  {
							same_index_image =1;
						  }
					  }
					if(same_index_image==0)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);

						  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
						  {
							if(counts==1)
							image_number =*beg;
							else
							child_number_for_image=*beg;
							counts++;
						   }	
					 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);

						if(child_number_for_image_int<b && changed_item_num<child_number_for_image_int)
						{
								number_for_image = image_int;
								move_image_vector_value.push_back(child_number_for_image_int);
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int-1);
								new_image_vector_position_value = image_number + "," + image_vector_position_value;
						 		for_image_indentification.at(g) = new_image_vector_position_value;
							
						 }	
					} // IF SAME INDEX					
				}	// 10 FOR LOOP	


			/*SARU END*/	


        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+b,xml_scene_overall_tag[changed_item_num-1]);
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+(changed_item_num-1));
        changed_item_num=b;
      }
      else if(raise_current_child_temp_vector.size()>0 && raise_next_child_temp_vector.size()==0)
      {
        std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end(), std::greater<double>());
        int size=raise_current_child_temp_vector.size()-1;
        int low_value=raise_current_child_temp_vector[size];

        int hi_value=raise_current_child_temp_vector[0];
        int nxt_value=hi_value+1;
        Glib::RefPtr< Goocanvas::Item > raise_to=root->get_child(nxt_value);
        Glib::ustring int_to_string_value;
        std::string total_arr;
        int grp_chi_dec_value;
        int grp_chi_dec_value1;
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          Glib::RefPtr< Goocanvas::Item > raise_this=root->get_child(cur_value);
          raise_this->raise(raise_to);
          grp_chi_dec_value=nxt_value-i;
          if(i==0)
          grp_chi_dec_value1=grp_chi_dec_value;
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(child_in_total_list==cur_value)
                  {
                  int_to_string_value = boost::lexical_cast<std::string>(grp_chi_dec_value);
                  total_arr="S,"+int_to_string_value;
                  group_child_total_list[j]=total_arr;
                  raise_next_child_temp_vector.push_back(j);

				/* SARU START*/

				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(cur_value==child_number_for_image_int)
                		 {
								number_for_image = image_int;
								move_image_vector_value.push_back(child_number_for_image_int);
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(grp_chi_dec_value);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
								store_image_vector_index.push_back(g);
								
						 }
					}

				/* SARU END*/

                  }
                }
                l++;
              }
            }
          }
        }	

		/*SARU START*/

		for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];

					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 std::string the_value = changed_image_vector_values[g] ;
					
					 while ((pos =  the_value.find(delimiter)) != std::string::npos) 
					 {
						token = the_value .substr(0, pos);
						the_value .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=the_value;

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
			 	}

			/* SARU START*/
				changed_image_vector_values.clear();

				int count=0;
				for(int i1=move_image_vector_value.size()-1;i1>=0;i1--)
				{
						count = count+1;
						for(int g=0;g<for_image_indentification.size();g++)
						{
							int same_index_image=0;
		 					for(int g1=0;g1<store_image_vector_index.size();g1++)
							  {	 
								  if(store_image_vector_index[g1]==g)
								  {
									same_index_image =1;
								  }
							  }
							if(same_index_image==0)
							{
							  int counts=1;
							  string get_image_number = for_image_indentification[g] ;
							  Glib::ustring image_number;
							  Glib::ustring child_number_for_image;
							  tokenizer<> tok(get_image_number);

								  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
								  {
									if(counts==1)
									image_number =*beg;
									else
									child_number_for_image=*beg;
									counts++;
								   }	
							 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
							 int  image_int = boost::lexical_cast<int>(image_number);


							 int first_image_value = move_image_vector_value[i1];
				 			 int last_image_value;
							if(count == move_image_vector_value.size())
								{

									 last_image_value = move_image_vector_value[0];

								if(child_number_for_image_int==last_image_value+1)
									{
									 image_vector_position = g;
									image_vector_position_str = boost::lexical_cast<std::string>(g);
									image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int-move_image_vector_value.size());
									new_image_vector_position_value = image_number + "," + image_vector_position_value;
							 		for_image_indentification.at(g) = new_image_vector_position_value;
								   }
								} //IF 
							else
							   {

									 last_image_value = move_image_vector_value[i1-1];
	
							  if((child_number_for_image_int>first_image_value) && (child_number_for_image_int<last_image_value))
								 {
										image_vector_position = g;
										image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int-count);
										new_image_vector_position_value = image_number + "," + image_vector_position_value;
								 		for_image_indentification.at(g) = new_image_vector_position_value;
								 }	
								} // ELSE 
							} // IF SAME INDEX					
						}	// 10 FOR LOOP					
				  }	// FIRST FOR

				/* SARU END*/	

        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int same_index=0;
              for(int k=0; k<raise_next_child_temp_vector.size(); k++)
              {
                if(j==raise_next_child_temp_vector[k])
                {
                same_index=1;
                }
              }
              if(same_index==0)
              {
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                    int child_in_total_list;
                    std::stringstream str(*beg);
                    str>>child_in_total_list;
                    if(child_in_total_list<=nxt_value && child_in_total_list>cur_value)
                    {
                    int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
                    total_arr="S,"+int_to_string_value;
                    group_child_total_list[j]=total_arr;	

					/* SARU START*/

					for(int g=0;g<for_image_indentification.size();g++)
						{
						int same_index_image=0;
						  for(int g1=0;g1<store_image_vector_index.size();g1++)
						  {	 
							  if(store_image_vector_index[g1]==g)
							  {
								same_index_image =1;
							  }
						  }
						if(same_index_image==0)
						{
						  int counts=1;
						  string get_image_number = for_image_indentification[g] ;
						  Glib::ustring image_number;
						  Glib::ustring child_number_for_image;
						  tokenizer<> tok(get_image_number);

						  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
						  {
							if(counts==1)
							image_number =*beg;
							else
							child_number_for_image=*beg;
							counts++;
						   }	
							 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
							 int  image_int = boost::lexical_cast<int>(image_number);
			   				 if((child_number_for_image_int==child_in_total_list))
			        		 {
									number_for_image = image_int;
									image_vector_position = g;
									image_vector_position_str = boost::lexical_cast<std::string>(g);
									image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int-1);
									new_image_vector_position_value = image_number + "," + image_vector_position_value;
							 		for_image_indentification.at(g) = new_image_vector_position_value;
							 }
						  }
					  }	

					/* SARU END*/		

		
                    }
                  }
                  l++;
                }
              }
            }
          }
        }

		/*SARU*/


		/*SARU*/
        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+nxt_value+i,xml_scene_overall_tag[raise_current_child_temp_vector[i]-1]);
        for(int i=raise_current_child_temp_vector.size()-1; i>=0; i--)
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+raise_current_child_temp_vector[i]-1);
        changed_item_num=grp_chi_dec_value1;
        raise_current_child_temp_vector.erase(raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
        xx=grp_xx;
        yy=grp_yy;
        ww=grp_ww;
        hh=grp_hh;
      }
      else if(raise_current_child_temp_vector.size()>0 && raise_next_child_temp_vector.size()>0)
      {
        std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end(), std::greater<double>());
        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end(), std::greater<double>());
        int hi_value=raise_next_child_temp_vector[0];
        int nxt_value=hi_value;
        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        Glib::RefPtr< Goocanvas::Item > raise_to=root->get_child(nxt_value);
        Glib::ustring int_to_string_value;
        std::string total_arr;
        int grp_chi_dec_value;
        int grp_chi_dec_value1;
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          Glib::RefPtr< Goocanvas::Item > raise_this=root->get_child(cur_value);
          raise_this->raise(raise_to);
          grp_chi_dec_value=nxt_value-i;
          if(i==0)
          grp_chi_dec_value1=grp_chi_dec_value;
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(child_in_total_list==cur_value)
                  {
                  int_to_string_value = boost::lexical_cast<std::string>(grp_chi_dec_value);
                  total_arr="S,"+int_to_string_value;
                  group_child_total_list[j]=total_arr;
                  raise_next_child_temp_vector.push_back(j);

				/* SARU */

				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(cur_value==child_number_for_image_int)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(grp_chi_dec_value);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
								store_image_vector_index.push_back(g);
								
						 }
					}

				/* SARU */
                  }
                }
                l++;
              }
            }
          }
        }	

		/*SARU*/

		for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];

					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 std::string the_value = changed_image_vector_values[g] ;
					
					 while ((pos =  the_value.find(delimiter)) != std::string::npos) 
					 {
						token = the_value .substr(0, pos);
						the_value .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=the_value;

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
			 	}

			/*SARU*/

        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int same_index=0;
              for(int k=0; k<raise_next_child_temp_vector.size(); k++)
              {
                if(j==raise_next_child_temp_vector[k])
                {
                same_index=1;
                }
              }
              if(same_index==0)
              {
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                    int child_in_total_list;
                    std::stringstream str(*beg);
                    str>>child_in_total_list;
                    if(child_in_total_list<=nxt_value && child_in_total_list>cur_value)
                    {
                    int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
                    total_arr="S,"+int_to_string_value;
                    group_child_total_list[j]=total_arr;	
				
					/* SARU */

					for(int g=0;g<for_image_indentification.size();g++)
						{
						int same_index_image=0;
						  for(int g1=0;g1<store_image_vector_index.size();g1++)
						  {	 
							  if(store_image_vector_index[g1]==g)
							  {
								same_index_image =1;
							  }
						  }
						if(same_index_image==0)
						{
						  int counts=1;
						  string get_image_number = for_image_indentification[g] ;
						  Glib::ustring image_number;
						  Glib::ustring child_number_for_image;
						  tokenizer<> tok(get_image_number);

						  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
						  {
							if(counts==1)
							image_number =*beg;
							else
							child_number_for_image=*beg;
							counts++;
						   }	
							 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
							 int  image_int = boost::lexical_cast<int>(image_number);
		       				 if((child_number_for_image_int==child_in_total_list))
		            		 {
									number_for_image = image_int;
									image_vector_position = g;
									image_vector_position_str = boost::lexical_cast<std::string>(g);
									image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int-1);
									new_image_vector_position_value = image_number + "," + image_vector_position_value;
							 		for_image_indentification.at(g) = new_image_vector_position_value;
							 }
						  }
					  }	

					/* SARU */	

		
                    }
                  }
                  l++;
                }
              }
            }
          }
        }

	/* SARU*/

        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());

        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
		{
        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+nxt_value+i,xml_scene_overall_tag[raise_current_child_temp_vector[i]-1]);
		}
        for(int i=raise_current_child_temp_vector.size()-1; i>=0; i--)
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+raise_current_child_temp_vector[i]-1);

        changed_item_num=grp_chi_dec_value1;

        raise_current_child_temp_vector.erase(raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
        xx=s_xx;
        yy=s_yy;
        ww=s_ww;
        hh=s_hh;
      }
    }

    Glib::RefPtr<Goocanvas::Rect> rect1 ;
    rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
    #ifdef GLIBMM_PROPERTIES_ENABLED
    rect1->property_stroke_color() = "red" ;
    rect1->property_line_width() = 0.5 ;
    #endif
    root->add_child(rect1);
    child_num=child_num+1;

    first(xx-16,yy-16,xx,yy);
    second(xx+ww+16,yy-16,xx+ww,yy);
    third(xx-16,yy+hh+16,xx,yy+hh);
    fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
    fifth(xx+ww/2,yy-22,xx+ww/2,yy);
    sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
    seventh(xx-22,yy+hh/2,xx,yy+hh/2);
    eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);

    //If the child is in group, should pop all values at each release event //code starts here
    group_xx.erase(group_xx.begin(), group_xx.end());
    group_yy.erase(group_yy.begin(), group_yy.end());
    group_end_xx.erase(group_end_xx.begin(), group_end_xx.end());
    group_end_yy.erase(group_end_yy.begin(), group_end_yy.end());
    //code end here
  } 
}

void KalanjiyamWindow::edit_raise_to_top()
{
  current_clicked_item=changed_item_num;
  std::vector<std::string>changed_image_vector_values;
  std::vector<int>store_image_vector_index;
  int image_vector_position;
  int current_clicked_item_new;
  std::string image_vector_position_str;
  std::string image_vector_position_value;
  std::string new_image_vector_position_value;
  std::vector<int>move_image_vector_value;

  int child_number1;
  if(grid_mode==1)
  child_number1=child_num-10;
  else if(grid_mode==0)
  child_number1=child_num-9;

  if(move_var>0 && changed_item_num<child_number1)
  {
    pSbar->push("Raised to Top...");	
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    Glib::RefPtr< Goocanvas::Item > select_item ;
    select_item=root->get_child(changed_item_num);
    if(move_var>0)
    {
      int chi_del=child_num-8;
      for(child_var=chi_del; child_var<=child_num; child_var++)
      {
      root->remove_child(chi_del);
      }
      child_num=child_num-9;
    }

    find_group_or_not(changed_item_num,"single_if","sort_true","raise_current_child");	


    if(raise_current_child_temp_vector.size()==0)
		{
				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);


					   if(current_clicked_item==child_number_for_image_int)
							{
								number_for_image = image_int;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								if(grid_mode==1)
									image_vector_position_value =boost::lexical_cast<std::string>(child_num-1);
								else
									image_vector_position_value =boost::lexical_cast<std::string>(child_num);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
							}		
						else if((child_number_for_image_int!=2)&&(child_number_for_image_int>current_clicked_item))
							{
								number_for_image = image_int;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								current_clicked_item_new  = child_number_for_image_int-1;
								image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
							}		

			
					}

				for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];


					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
					 {
						token = changed_image_vector_values[g] .substr(0, pos);
						changed_image_vector_values[g] .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=changed_image_vector_values[g];

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
			 	}	
			}



    if(raise_current_child_temp_vector.size()>0)
    {
      std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end(), std::greater<double>());
      int nxt_value;
      if(grid_mode==1)
      nxt_value=child_num-1;
      else if(grid_mode==0)
      nxt_value=child_num;

      Glib::RefPtr< Goocanvas::Item > raise_to=root->get_child(nxt_value);
      Glib::ustring int_to_string_value;
      std::string total_arr;
      int grp_chi_dec_value1;
      for(int i=0; i<raise_current_child_temp_vector.size(); i++)
      {
        int cur_value=raise_current_child_temp_vector[i];
        Glib::RefPtr< Goocanvas::Item > raise_this=root->get_child(cur_value);
        raise_this->raise(raise_to);
        int grp_chi_dec_value=nxt_value-i;
        if(i==0)
        grp_chi_dec_value1=grp_chi_dec_value;
        for(int j=0; j<group_child_total_list.size(); j++)
        {
          tokenizer<> tok(group_child_total_list[j]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
                int child_in_total_list;
                std::stringstream str(*beg);
                str>>child_in_total_list;
                if(child_in_total_list==cur_value)
                {
                int_to_string_value = boost::lexical_cast<std::string>(grp_chi_dec_value);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[j]=total_arr;
                raise_next_child_temp_vector.push_back(j);
				
				/* SARU */

				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(cur_value==child_number_for_image_int)
                		 {
								number_for_image = image_int;
								move_image_vector_value.push_back(child_number_for_image_int);
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(grp_chi_dec_value);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
								store_image_vector_index.push_back(g);
								
						 }
					}

				/* SARU */

                }
              }
              l++;
            }
          }
        }
      }	

	/*SARU*/
    if(raise_current_child_temp_vector.size()>0)
		{
		for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];

					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 std::string the_value = changed_image_vector_values[g] ;
					
					 while ((pos =  the_value.find(delimiter)) != std::string::npos) 
					 {
						token = the_value .substr(0, pos);
						the_value .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=the_value;

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
			 	}
			}
			/*SARU*/
				changed_image_vector_values.clear();
  		 /*SARU*/



				int count=0;
				for(int i1=move_image_vector_value.size()-1;i1>=0;i1--)
				{
						count = count+1;
						for(int g=0;g<for_image_indentification.size();g++)
						{
							int same_index_image=0;
		 					for(int g1=0;g1<store_image_vector_index.size();g1++)
							  {	 
								  if(store_image_vector_index[g1]==g)
								  {
									same_index_image =1;
								  }
							  }
							if(same_index_image==0)
							{
							  int counts=1;
							  string get_image_number = for_image_indentification[g] ;
							  Glib::ustring image_number;
							  Glib::ustring child_number_for_image;
							  tokenizer<> tok(get_image_number);

								  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
								  {
									if(counts==1)
									image_number =*beg;
									else
									child_number_for_image=*beg;
									counts++;
								   }	
							 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
							 int  image_int = boost::lexical_cast<int>(image_number);


							 int first_image_value = move_image_vector_value[i1];
				 			 int last_image_value;
							if(count == move_image_vector_value.size())
								{

									 last_image_value = move_image_vector_value[0];

								if(child_number_for_image_int>=last_image_value)
									{
									 image_vector_position = g;
									image_vector_position_str = boost::lexical_cast<std::string>(g);
									image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int-move_image_vector_value.size());
									new_image_vector_position_value = image_number + "," + image_vector_position_value;
							 		for_image_indentification.at(g) = new_image_vector_position_value;
								   }
								} //IF 
							else
							   {

									 last_image_value = move_image_vector_value[i1-1];
	
							  if((child_number_for_image_int>first_image_value) && (child_number_for_image_int<last_image_value))
								 {
										image_vector_position = g;
										image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int-count);
										new_image_vector_position_value = image_number + "," + image_vector_position_value;
								 		for_image_indentification.at(g) = new_image_vector_position_value;
								 }	
								} // ELSE 
							} // IF SAME INDEX					
						}	// 10 FOR LOOP					
				  }	// FIRST FOR

				/* SARU END*/	


      std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
      for(int i=0; i<raise_current_child_temp_vector.size(); i++)
      {
        int cur_value=raise_current_child_temp_vector[i];
        for(int j=0; j<group_child_total_list.size(); j++)
        {
          tokenizer<> tok(group_child_total_list[j]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int same_index=0;
            for(int k=0; k<raise_next_child_temp_vector.size(); k++)
            {
              if(j==raise_next_child_temp_vector[k])
              {
              same_index=1;
              }
            }
            if(same_index==0)
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(child_in_total_list<=nxt_value && child_in_total_list>cur_value)
                  {
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
                  total_arr="S,"+int_to_string_value;
                  group_child_total_list[j]=total_arr;	
				
                  }
                }
                l++;
              }
            }
          }
        }
      }
      xx=grp_xx;
      yy=grp_yy;
      ww=grp_ww;
      hh=grp_hh;
      changed_item_num=grp_chi_dec_value1;
      std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
      for(int i=0; i<raise_current_child_temp_vector.size(); i++)
      xml_scene_overall_tag.push_back(xml_scene_overall_tag[raise_current_child_temp_vector[i]-1]);
      for(int i=raise_current_child_temp_vector.size()-1; i>=0; i--)
      xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+raise_current_child_temp_vector[i]-1);
    }
    else
    {
      Glib::RefPtr< Goocanvas::Item > sing_item ;
      int sin_value;
      if(grid_mode==1)
      sin_value=child_num-1;
      else if(grid_mode==0)
      sin_value=child_num;
      sing_item=root->get_child(sin_value);
      select_item->raise(sing_item);
      Glib::ustring int_to_string_value;
      std::string total_arr;
      int index_value;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          int l=1;
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            if(l!=1)
            {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list==changed_item_num)
              {
              index_value=i;
              }
              else if(child_in_total_list>changed_item_num && child_in_total_list<child_num)
              {
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
              total_arr="S,"+int_to_string_value;
              group_child_total_list[i]=total_arr;			
              }
            }
            l++;
          }
        }
      }
      for(int j=0; j<group_child_total_list.size(); j++)
      {
        if(j==index_value)
        {
        int_to_string_value = boost::lexical_cast<std::string>(sin_value);
        total_arr="S,"+int_to_string_value;	
        group_child_total_list[j]=total_arr;
        }
      }
      xml_scene_overall_tag.push_back(xml_scene_overall_tag[changed_item_num-1]);
      xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+(changed_item_num-1));

      if(grid_mode==1)
      changed_item_num=child_num-1;
      else if(grid_mode==0)
      changed_item_num=child_num;
    }
    raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
    raise_current_child_temp_vector.erase(raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());

    Glib::RefPtr<Goocanvas::Rect> rect1 ;
    rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
    #ifdef GLIBMM_PROPERTIES_ENABLED
    rect1->property_stroke_color() = "red" ;
    rect1->property_line_width() = 0.5 ;
    #endif
    root->add_child(rect1);
    child_num=child_num+1;

    first(xx-16,yy-16,xx,yy);
    second(xx+ww+16,yy-16,xx+ww,yy);
    third(xx-16,yy+hh+16,xx,yy+hh);
    fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
    fifth(xx+ww/2,yy-22,xx+ww/2,yy);
    sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
    seventh(xx-22,yy+hh/2,xx,yy+hh/2);
    eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);

    //If the child is in group, should pop all values at each release event //code starts here
    group_xx.erase(group_xx.begin(), group_xx.end());
    group_yy.erase(group_yy.begin(), group_yy.end());
    group_end_xx.erase(group_end_xx.begin(), group_end_xx.end());
    group_end_yy.erase(group_end_yy.begin(), group_end_yy.end());
    //code end here
	/*SARU*/

  }
}
void KalanjiyamWindow::edit_lower_to_back()
{
  current_clicked_item=changed_item_num;
  std::vector<int>move_image_vector_value;
  std::vector<std::string>changed_image_vector_values;
  std::vector<int>store_image_vector_index;
  int image_vector_position;
  int current_clicked_item_new;
  int current_clicked_next_item;
  std::string image_vector_position_str;
  std::string image_vector_position_value;
  std::string new_image_vector_position_value;
  if(move_var>0 && current_clicked_item>2)
  {
    pSbar->push("Lowered to Back...");	
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    Glib::RefPtr< Goocanvas::Item > select_item ;
    Glib::RefPtr< Goocanvas::Item > prev_item ;
    int prev_item_num;
    select_item=root->get_child(changed_item_num);
    int s_xx, s_yy, s_ww, s_hh;		//Stored Values
    if(move_var>0)
    {
      int chi_del=child_num-8;
      for(child_var=chi_del; child_var<=child_num; child_var++)
      {
      root->remove_child(chi_del);
      }
      child_num=child_num-9;
    }


  find_group_or_not(changed_item_num,"single_if","sort_true","raise_current_child");	

    if(raise_current_child_temp_vector.size()>0)
    {
      std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
      int b=raise_current_child_temp_vector[0];
      prev_item_num=b-1;
      xx=grp_xx;
      yy=grp_yy;
      ww=grp_ww;
      hh=grp_hh;
    }
    else
    {
      prev_item_num=changed_item_num-1;
    }
    s_xx=xx;
    s_yy=yy;
    s_ww=ww;
    s_hh=hh;
    if(prev_item_num>=2)
    {
      prev_item=root->get_child(prev_item_num);
      find_group_or_not(prev_item_num,"single_if","sort_true","raise_next_child");
      if(raise_current_child_temp_vector.size()==0 && raise_next_child_temp_vector.size()==0)
      {
        select_item->lower(prev_item);
        Glib::ustring int_to_string_value;
        std::string total_arr;
        int index_value;
        int prev_to_current_clicked_item=changed_item_num-1;
        for(int i=0; i<group_child_total_list.size(); i++)
        {
          tokenizer<> tok(group_child_total_list[i]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
                int child_in_total_list;
                std::stringstream str(*beg);
                str>>child_in_total_list;
                if(child_in_total_list==prev_to_current_clicked_item)
                {
                index_value=i;
                }
                else if(child_in_total_list==current_clicked_item)
                {
                int_to_string_value = boost::lexical_cast<std::string>(prev_to_current_clicked_item);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[i]=total_arr;			
                }
              }
              l++;
            }
          }
        }
        for(int j=0; j<group_child_total_list.size(); j++)
        {
          if(j==index_value)
          {
          int_to_string_value = boost::lexical_cast<std::string>(current_clicked_item);
          total_arr="S,"+int_to_string_value;
          group_child_total_list[j]=total_arr;
          }
        }

	 for(int g=0;g<for_image_indentification.size();g++)
		{
		  int counts=1;
		  string get_image_number = for_image_indentification[g] ;
		  Glib::ustring image_number;
		  Glib::ustring child_number_for_image;
		  tokenizer<> tok(get_image_number);
		  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		  {
			if(counts==1)
			image_number =*beg;
			else
			child_number_for_image=*beg;
			counts++;
		   }	
			 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
			 int  image_int = boost::lexical_cast<int>(image_number);


			current_clicked_next_item = current_clicked_item-1;
		   if(current_clicked_item==child_number_for_image_int)
				{
					number_for_image = image_int;
					image_vector_position = g;
				    image_vector_position_str = boost::lexical_cast<std::string>(g);
					current_clicked_item_new  = child_number_for_image_int-1;
					image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				}		

			if(current_clicked_next_item == child_number_for_image_int)
				{
					number_for_image = image_int;
					image_vector_position = g;
				    image_vector_position_str = boost::lexical_cast<std::string>(g);
					current_clicked_item_new  = child_number_for_image_int+1;
					current_clicked_next_item = current_clicked_item-1;
					image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				}		

			
		}

		for(int g=0;g<changed_image_vector_values.size();g++)
		{
		   string new_image_value =	changed_image_vector_values[g];


			 tokenizer<> tok(new_image_value);
			 int count=1;
			 Glib::ustring vector_no;
			 std::string image_no;
			 std::string item_no;
			 std::string delimiter = ",";
			 std::string storestring="";
			 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			 {
			   if(count==1)
				   vector_no=*beg;
			   else 
				  storestring=storestring + *beg ;
				  count++;
			 }
			 int  vector_no_int = boost::lexical_cast<int>(vector_no);
			 size_t pos = 0;
			 std::string token;
			 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
			 {
				token = changed_image_vector_values[g] .substr(0, pos);
				changed_image_vector_values[g] .erase(0, pos + delimiter.length());
			 }
			image_no=token;
			item_no=changed_image_vector_values[g];

			new_image_vector_position_value = image_no + "," + item_no;
	 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
   	  	}	

        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+prev_item_num-1,xml_scene_overall_tag[changed_item_num-1]);
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_item_num);
        changed_item_num--;
      }
      else if(raise_current_child_temp_vector.size()==0 && raise_next_child_temp_vector.size()>0)
      {
        xx=s_xx;
        yy=s_yy;
        ww=s_ww;
        hh=s_hh;
        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());

        Glib::RefPtr< Goocanvas::Item > temp_item ;
        int b=raise_next_child_temp_vector[0];
        temp_item=root->get_child(b);

        select_item->lower(temp_item);

        Glib::ustring int_to_string_value;
        std::string total_arr;
        for(int i=0; i<group_child_total_list.size(); i++)
        {
          tokenizer<> tok(group_child_total_list[i]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
                int child_in_total_list;
                std::stringstream str(*beg);
                str>>child_in_total_list;
                if(child_in_total_list==changed_item_num)
                {
                int_to_string_value = boost::lexical_cast<std::string>(b);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[i]=total_arr;			
                }
                else if(child_in_total_list>=b && child_in_total_list<changed_item_num)
                {
                int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list+1);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[i]=total_arr;	
			
                }
              }
              l++;
            }
          }
        }

			/*SARU START*/


				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
                	 if(child_number_for_image_int>=b && child_number_for_image_int<changed_item_num)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int+1);
								new_image_vector_position_value = image_number + "," + image_vector_position_value;
						 		for_image_indentification.at(g) = new_image_vector_position_value;
								store_image_vector_index.push_back(g);								
						 }

					}
				/* SARU END*/


			for(int g=0;g<for_image_indentification.size();g++)
				{
					int same_index_image=0;
					for(int g1=0;g1<store_image_vector_index.size();g1++)
					  {	 
						  if(store_image_vector_index[g1]==g)
						  {
							same_index_image =1;
						  }
					  }
					if(same_index_image==0)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(child_number_for_image_int==changed_item_num)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(b);
								new_image_vector_position_value = image_number + "," + image_vector_position_value;
						 		for_image_indentification.at(g) = new_image_vector_position_value;
								store_image_vector_index.push_back(g);								
						 }
						}
					}


				for(int g=0;g<for_image_indentification.size();g++)
					{
						int same_index_image=0;
	 					for(int g1=0;g1<store_image_vector_index.size();g1++)
						  {	 
							  if(store_image_vector_index[g1]==g)
							  {
								same_index_image =1;
							  }
						  }
						if(same_index_image==0)
						{
						  int counts=1;
						  string get_image_number = for_image_indentification[g] ;
						  Glib::ustring image_number;
						  Glib::ustring child_number_for_image;
						  tokenizer<> tok(get_image_number);

							  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
							  {
								if(counts==1)
								image_number =*beg;
								else
								child_number_for_image=*beg;
								counts++;
							   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);

							if(child_number_for_image_int<b && changed_item_num<child_number_for_image_int)
							{
									number_for_image = image_int;
									move_image_vector_value.push_back(child_number_for_image_int);
									current_clicked_item_new = g;
									image_vector_position = g;
									image_vector_position_str = boost::lexical_cast<std::string>(g);
									image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int+1);
									new_image_vector_position_value = image_number + "," + image_vector_position_value;
							 		for_image_indentification.at(g) = new_image_vector_position_value;
							
							 }	
						} // IF SAME INDEX					
					}	// 10 FOR LOOP	



				/*SARU END*/	
        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+b-1,xml_scene_overall_tag[changed_item_num-1]);
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_item_num);
        changed_item_num=b;
      }
      else if(raise_current_child_temp_vector.size()>0 && raise_next_child_temp_vector.size()==0)
      {
        std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
        int low_value=raise_current_child_temp_vector[0];
        int pre_value=low_value-1;
        Glib::RefPtr< Goocanvas::Item > lower_to=root->get_child(pre_value);

        Glib::ustring int_to_string_value;
        std::string total_arr;
        int grp_chi_incr_value;
        int grp_chi_incr_value1;
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          Glib::RefPtr< Goocanvas::Item > lower_this=root->get_child(cur_value);
          lower_this->lower(lower_to);
          grp_chi_incr_value=pre_value+i;
          if(i==0)
          grp_chi_incr_value1=grp_chi_incr_value;
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(child_in_total_list==cur_value)
                  {
                  int_to_string_value = boost::lexical_cast<std::string>(grp_chi_incr_value);
                  total_arr="S,"+int_to_string_value;
                  group_child_total_list[j]=total_arr;
                  raise_next_child_temp_vector.push_back(j);


		/* SARU START*/

				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(cur_value==child_number_for_image_int)
                		 {
								number_for_image = image_int;
								move_image_vector_value.push_back(child_number_for_image_int);
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(grp_chi_incr_value);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
								store_image_vector_index.push_back(g);
								
						 }
					}

				/* SARU END*/


                  }
                }
                l++;
              }
            }
          }
        }	


		/*SARU START*/

		for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];

					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 std::string the_value = changed_image_vector_values[g] ;
					
					 while ((pos =  the_value.find(delimiter)) != std::string::npos) 
					 {
						token = the_value .substr(0, pos);
						the_value .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=the_value;

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
			 	}

			/* SARU START*/
				changed_image_vector_values.clear();

				int count=0;
				for(int i1=move_image_vector_value.size()-1;i1>=0;i1--)
				{
						count = count+1;
						for(int g=0;g<for_image_indentification.size();g++)
						{
							int same_index_image=0;
		 					for(int g1=0;g1<store_image_vector_index.size();g1++)
							  {	 
								  if(store_image_vector_index[g1]==g)
								  {
									same_index_image =1;
								  }
							  }
							if(same_index_image==0)
							{
							  int counts=1;
							  string get_image_number = for_image_indentification[g] ;
							  Glib::ustring image_number;
							  Glib::ustring child_number_for_image;
							  tokenizer<> tok(get_image_number);

								  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
								  {
									if(counts==1)
									image_number =*beg;
									else
									child_number_for_image=*beg;
									counts++;
								   }	
							 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
							 int  image_int = boost::lexical_cast<int>(image_number);


							 int first_image_value = move_image_vector_value[i1];
				 			 int last_image_value;
							if(count == move_image_vector_value.size())
								{

									 last_image_value = move_image_vector_value[0];

								if(child_number_for_image_int==last_image_value-1)
									{
									 image_vector_position = g;
									image_vector_position_str = boost::lexical_cast<std::string>(g);
									image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int+move_image_vector_value.size());
									new_image_vector_position_value = image_number + "," + image_vector_position_value;
							 		for_image_indentification.at(g) = new_image_vector_position_value;
								   }
								} //IF 
							else
							   {

									 last_image_value = move_image_vector_value[i1-1];
	
							  if((child_number_for_image_int<first_image_value) && (child_number_for_image_int>last_image_value))
								 {
										image_vector_position = g;
										image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int+count);
										new_image_vector_position_value = image_number + "," + image_vector_position_value;
								 		for_image_indentification.at(g) = new_image_vector_position_value;
								 }	
								} // ELSE 
							} // IF SAME INDEX					
						}	// 10 FOR LOOP					
				  }	// FIRST FOR


				/* SARU END*/	


        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int same_index=0;
              for(int k=0; k<raise_next_child_temp_vector.size(); k++)
              {
                if(j==raise_next_child_temp_vector[k])
                {
                same_index=1;
                }
              }
              if(same_index==0)
              {
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                    int child_in_total_list;
                    std::stringstream str(*beg);
                    str>>child_in_total_list;
                    if(child_in_total_list>=pre_value && child_in_total_list<cur_value)
                    {
                    int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list+1);
                    total_arr="S,"+int_to_string_value;
                    group_child_total_list[j]=total_arr;			
                    }
                  }
                  l++;
                }
              }
            }
          }
        }
        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+pre_value+i-1,xml_scene_overall_tag[raise_current_child_temp_vector[i]-1]);
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+raise_current_child_temp_vector[i]);
        }
        changed_item_num=grp_chi_incr_value1;
        raise_current_child_temp_vector.erase(raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
        xx=grp_xx;
        yy=grp_yy;
        ww=grp_ww;
        hh=grp_hh;
      }
      else if(raise_current_child_temp_vector.size()>0 && raise_next_child_temp_vector.size()>0)
      {
        std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        int low_value=raise_next_child_temp_vector[0];
        int pre_value=low_value;
        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        Glib::RefPtr< Goocanvas::Item > lower_to=root->get_child(pre_value);
        Glib::ustring int_to_string_value;
        std::string total_arr;
        int grp_chi_incr_value;
        int grp_chi_incr_value1;



        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          Glib::RefPtr< Goocanvas::Item > lower_this=root->get_child(cur_value);
          lower_this->lower(lower_to);
          grp_chi_incr_value=pre_value+i;
          if(i==0)
          grp_chi_incr_value1=grp_chi_incr_value;
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(child_in_total_list==cur_value)
                  {
                  int_to_string_value = boost::lexical_cast<std::string>(grp_chi_incr_value);
                  total_arr="S,"+int_to_string_value;
                  group_child_total_list[j]=total_arr;
                  raise_next_child_temp_vector.push_back(j);


				/* SARU */

				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(cur_value==child_number_for_image_int)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(grp_chi_incr_value);
								new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								changed_image_vector_values.push_back(new_image_vector_position_value);
								store_image_vector_index.push_back(g);
								
						 }
					}

				/* SARU */

                  }
                }
                l++;
              }
            }
          }
        }	


		/*SARU*/

		for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];

					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 std::string the_value = changed_image_vector_values[g] ;
					
					 while ((pos =  the_value.find(delimiter)) != std::string::npos) 
					 {
						token = the_value .substr(0, pos);
						the_value .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=the_value;

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
			 	}

			/*SARU*/
        std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());



				/* SARU */
				
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
				for(int g=0;g<for_image_indentification.size();g++)
					{
					int same_index_image=0;
					  for(int g1=0;g1<store_image_vector_index.size();g1++)
					  {	 
						  if(store_image_vector_index[g1]==g)
						  {
							same_index_image =1;
						  }
					  }
					if(same_index_image==0)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);

					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
					  
                    if(child_number_for_image_int>=pre_value && child_number_for_image_int<cur_value)
                		 {
								number_for_image = image_int;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int+1);
								new_image_vector_position_value = image_number + "," + image_vector_position_value;
						 		for_image_indentification.at(g) = new_image_vector_position_value;
						 }
					  }
				  }	
			 }

				/* SARU */	
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
          int cur_value=raise_current_child_temp_vector[i];
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="S")
            {
              int same_index=0;
              for(int k=0; k<raise_next_child_temp_vector.size(); k++)
              {
                if(j==raise_next_child_temp_vector[k])
                {
                same_index=1;
                }
              }
              if(same_index==0)
              {
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                    int child_in_total_list;
                    std::stringstream str(*beg);
                    str>>child_in_total_list;
                    if(child_in_total_list>=pre_value && child_in_total_list<cur_value)
                    {
                    int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list+1);
                    total_arr="S,"+int_to_string_value;
                    group_child_total_list[j]=total_arr;			
                    }
                  }
                  l++;
                }
              }
            }
          }
        }

	/*SARU*/

	/* SARU*/

        raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
        for(int i=0; i<raise_current_child_temp_vector.size(); i++)
        {
        xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+pre_value+i-1,xml_scene_overall_tag[raise_current_child_temp_vector[i]-1]);
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+raise_current_child_temp_vector[i]);
        }
        changed_item_num=grp_chi_incr_value1;
        raise_current_child_temp_vector.erase(raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
        xx=s_xx;
        yy=s_yy;
        ww=s_ww;
        hh=s_hh;
      }
    }
    Glib::RefPtr<Goocanvas::Rect> rect1 ;
    rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
    #ifdef GLIBMM_PROPERTIES_ENABLED
    rect1->property_stroke_color() = "red" ;
    rect1->property_line_width() = 0.5 ;
    #endif
    root->add_child(rect1);
    child_num=child_num+1;

    first(xx-16,yy-16,xx,yy);
    second(xx+ww+16,yy-16,xx+ww,yy);
    third(xx-16,yy+hh+16,xx,yy+hh);
    fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
    fifth(xx+ww/2,yy-22,xx+ww/2,yy);
    sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
    seventh(xx-22,yy+hh/2,xx,yy+hh/2);
    eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);

    //If the child is in group, should pop all values at each release event //code starts here
    group_xx.erase(group_xx.begin(), group_xx.end());
    group_yy.erase(group_yy.begin(), group_yy.end());
    group_end_xx.erase(group_end_xx.begin(), group_end_xx.end());
    group_end_yy.erase(group_end_yy.begin(), group_end_yy.end());
    //code end here
  }  
}

void KalanjiyamWindow::edit_lower_to_bottom()
{
  current_clicked_item=changed_item_num;
  std::vector<std::string>changed_image_vector_values;
  std::vector<int>store_image_vector_index;
  int image_vector_position;
  int current_clicked_item_new;
  int current_clicked_next_item;
  std::string image_vector_position_str;
  std::string image_vector_position_value;
  std::string new_image_vector_position_value;
  std::vector<int>move_image_vector_value;

  if(move_var>0 && changed_item_num>2)
  {
    pSbar->push("Lowered to Bottom...");	
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    Glib::RefPtr< Goocanvas::Item > select_item ;
    select_item=root->get_child(changed_item_num);
    if(move_var>0)
    {
      int chi_del=child_num-8;
      for(child_var=chi_del; child_var<=child_num; child_var++)
      {
      root->remove_child(chi_del);
      }
      child_num=child_num-9;
    }

    find_group_or_not(changed_item_num,"single_if","sort_true","raise_current_child");	

    if(raise_current_child_temp_vector.size()==0)
	{

	for(int g=0;g<for_image_indentification.size();g++)
		{
		  int counts=1;
		  string get_image_number = for_image_indentification[g] ;
		  Glib::ustring image_number;
		  Glib::ustring child_number_for_image;
		  tokenizer<> tok(get_image_number);
		  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		  {
			if(counts==1)
			image_number =*beg;
			else
			child_number_for_image=*beg;
			counts++;
		   }	
			 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
			 int  image_int = boost::lexical_cast<int>(image_number);


		   if(current_clicked_item==child_number_for_image_int)
				{
					number_for_image = image_int;
					image_vector_position = g;
				    image_vector_position_str = boost::lexical_cast<std::string>(g);
					image_vector_position_value =boost::lexical_cast<std::string>(2);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				}
			else
			{
			  if(grid_mode==1)
			   {		
			   if(child_number_for_image_int!=(child_num-1)&&(child_number_for_image_int<current_clicked_item))
				 {
					number_for_image = image_int;
					image_vector_position = g;
				    image_vector_position_str = boost::lexical_cast<std::string>(g);
					current_clicked_item_new  = child_number_for_image_int+1;
					image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				 }		
			 }
		  else
			{	
			   if(child_number_for_image_int!=(child_num)&&(child_number_for_image_int<current_clicked_item))
				 {
					number_for_image = image_int;
					image_vector_position = g;
				    image_vector_position_str = boost::lexical_cast<std::string>(g);
					current_clicked_item_new  = child_number_for_image_int+1;
					image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				 }	
			  }	
			}
			
		}

	for(int g=0;g<changed_image_vector_values.size();g++)
	{
	   string new_image_value =	changed_image_vector_values[g];


		 tokenizer<> tok(new_image_value);
		 int count=1;
		 Glib::ustring vector_no;
		 std::string image_no;
		 std::string item_no;
		 std::string delimiter = ",";
		 std::string storestring="";
		 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		 {
		   if(count==1)
			   vector_no=*beg;
		   else 
			  storestring=storestring + *beg ;
			  count++;
		 }
		 int  vector_no_int = boost::lexical_cast<int>(vector_no);
		 size_t pos = 0;
		 std::string token;
		 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
		 {
			token = changed_image_vector_values[g] .substr(0, pos);
			changed_image_vector_values[g] .erase(0, pos + delimiter.length());
		 }
		image_no=token;
		item_no=changed_image_vector_values[g];

		new_image_vector_position_value = image_no + "," + item_no;
 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
 	}	
	}



    int pre_value=2;
    Glib::RefPtr< Goocanvas::Item > first_item=root->get_child(pre_value);
    if(raise_current_child_temp_vector.size()>0)
    {
      std::sort (raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
      int low_value=raise_current_child_temp_vector[0];

      Glib::RefPtr< Goocanvas::Item > lower_to=root->get_child(pre_value);
      Glib::ustring int_to_string_value;
      std::string total_arr;
      int grp_chi_incr_value1;
      for(int i=0; i<raise_current_child_temp_vector.size(); i++)
      {
        int cur_value=raise_current_child_temp_vector[i];
        Glib::RefPtr< Goocanvas::Item > lower_this=root->get_child(cur_value);
        lower_this->lower(lower_to);
        int grp_chi_incr_value=pre_value+i;
        if(i==0)
        grp_chi_incr_value1=grp_chi_incr_value;
        for(int j=0; j<group_child_total_list.size(); j++)
        {
          tokenizer<> tok(group_child_total_list[j]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
                int child_in_total_list;
                std::stringstream str(*beg);
                str>>child_in_total_list;
                if(child_in_total_list==cur_value)
                {
                int_to_string_value = boost::lexical_cast<std::string>(grp_chi_incr_value);
                total_arr="S,"+int_to_string_value;
                group_child_total_list[j]=total_arr;
                raise_next_child_temp_vector.push_back(j);
                }
              }
              l++;
            }
          }
        }
      }	

			/* SARU */
      for(int i=0; i<raise_current_child_temp_vector.size(); i++)
      {
        int cur_value=raise_current_child_temp_vector[i];
        int grp_chi_incr_value=pre_value+i;
			
				for(int g=0;g<for_image_indentification.size();g++)
					{
					  int counts=1;
					  string get_image_number = for_image_indentification[g] ;
					  Glib::ustring image_number;
					  Glib::ustring child_number_for_image;
					  tokenizer<> tok(get_image_number);
					  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					  {
						if(counts==1)
						image_number =*beg;
						else
						child_number_for_image=*beg;
						counts++;
					   }	
						 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
						 int  image_int = boost::lexical_cast<int>(image_number);
						 if(cur_value==child_number_for_image_int)
                		 {
								number_for_image = image_int;
								current_clicked_item_new = g;
								image_vector_position = g;
								image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(grp_chi_incr_value);
								move_image_vector_value.push_back(child_number_for_image_int);
							//	new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
								//changed_image_vector_values.push_back(new_image_vector_position_value);
								new_image_vector_position_value = image_number + "," + image_vector_position_value;
						 		for_image_indentification.at(g) = new_image_vector_position_value;
								store_image_vector_index.push_back(g);
								
						 }
					}
			}


			/*SARU*/
				changed_image_vector_values.clear();


				int count=0;
				for(int i1=move_image_vector_value.size()-1;i1>=0;i1--)
				{
						count = count+1;
						for(int g=0;g<for_image_indentification.size();g++)
						{
							int same_index_image=0;
		 					for(int g1=0;g1<store_image_vector_index.size();g1++)
							  {	 
								  if(store_image_vector_index[g1]==g)
								  {
									same_index_image =1;
								  }
							  }
							if(same_index_image==0)
							{
							  int counts=1;
							  string get_image_number = for_image_indentification[g] ;
							  Glib::ustring image_number;
							  Glib::ustring child_number_for_image;
							  tokenizer<> tok(get_image_number);

								  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
								  {
									if(counts==1)
									image_number =*beg;
									else
									child_number_for_image=*beg;
									counts++;
								   }	
							 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
							 int  image_int = boost::lexical_cast<int>(image_number);


							 int first_image_value = move_image_vector_value[i1];
				 			 int last_image_value;
							if(count == move_image_vector_value.size())
								{

									 last_image_value = move_image_vector_value[0];

								if(child_number_for_image_int<=last_image_value)
									{
									 image_vector_position = g;
									image_vector_position_str = boost::lexical_cast<std::string>(g);
									image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int+move_image_vector_value.size());
									new_image_vector_position_value = image_number + "," + image_vector_position_value;
							 		for_image_indentification.at(g) = new_image_vector_position_value;
								   }
								} //IF 
							else
							   {

									 last_image_value = move_image_vector_value[i1-1];
	
							  if((child_number_for_image_int<first_image_value) && (child_number_for_image_int>last_image_value))
								 {
										image_vector_position = g;
										image_vector_position_str = boost::lexical_cast<std::string>(g);
								image_vector_position_value =boost::lexical_cast<std::string>(child_number_for_image_int+count);
										new_image_vector_position_value = image_number + "," + image_vector_position_value;
								 		for_image_indentification.at(g) = new_image_vector_position_value;
								 }	
								} // ELSE 
							} // IF SAME INDEX					
						}	// 10 FOR LOOP					
				  }	// FIRST FOR


				/* SARU END*/	


      std::sort (raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
      for(int i=0; i<raise_current_child_temp_vector.size(); i++)
      {
        int cur_value=raise_current_child_temp_vector[i];
        for(int j=0; j<group_child_total_list.size(); j++)
        {
          tokenizer<> tok(group_child_total_list[j]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            int same_index=0;
            for(int k=0; k<raise_next_child_temp_vector.size(); k++)
            {
              if(j==raise_next_child_temp_vector[k])
              {
              same_index=1;
              }
            }
            if(same_index==0)
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  if(child_in_total_list>=pre_value && child_in_total_list<cur_value)
                  {
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list+1);
                  total_arr="S,"+int_to_string_value;
                  group_child_total_list[j]=total_arr;
		
                  }
                }
                l++;
              }
            }
          }
        }
      }



      for(int i=0; i<raise_current_child_temp_vector.size(); i++)
      {
      xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+1+i,xml_scene_overall_tag[raise_current_child_temp_vector[i]-1]);
      xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+raise_current_child_temp_vector[i]);
      }
      raise_current_child_temp_vector.erase(raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
      raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
      xx=grp_xx;
      yy=grp_yy;
      ww=grp_ww;
      hh=grp_hh;
      changed_item_num=grp_chi_incr_value1;
    }
    else
    {
      select_item->lower(first_item);
      Glib::ustring int_to_string_value;
      std::string total_arr;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          int l=1;
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            if(l!=1)
            {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list==changed_item_num)
              {
              int_to_string_value = boost::lexical_cast<std::string>("1");
              total_arr="S,"+int_to_string_value;
              group_child_total_list[i]=total_arr;			
              }
              else if(child_in_total_list<changed_item_num && child_in_total_list>=pre_value)
              {
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list+1);
              total_arr="S,"+int_to_string_value;
              group_child_total_list[i]=total_arr;			
              }
            }
            l++;
          }
        }
      }
      xml_scene_overall_tag.insert(xml_scene_overall_tag.begin()+1,xml_scene_overall_tag[changed_item_num-1]);
      xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+changed_item_num);
      changed_item_num=2;
    }
    raise_next_child_temp_vector.erase(raise_next_child_temp_vector.begin(), raise_next_child_temp_vector.end());
    raise_current_child_temp_vector.erase(raise_current_child_temp_vector.begin(), raise_current_child_temp_vector.end());
    Glib::RefPtr<Goocanvas::Rect> rect1 ;
    rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
    #ifdef GLIBMM_PROPERTIES_ENABLED
    rect1->property_stroke_color() = "red" ;
    rect1->property_line_width() = 0.5 ;
    #endif
    root->add_child(rect1);
    child_num=child_num+1;

    first(xx-16,yy-16,xx,yy);
    second(xx+ww+16,yy-16,xx+ww,yy);
    third(xx-16,yy+hh+16,xx,yy+hh);
    fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
    fifth(xx+ww/2,yy-22,xx+ww/2,yy);
    sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
    seventh(xx-22,yy+hh/2,xx,yy+hh/2);
    eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2); 

    //If the child is in group, should pop all values at each release event //code starts here
    group_xx.erase(group_xx.begin(), group_xx.end());
    group_yy.erase(group_yy.begin(), group_yy.end());
    group_end_xx.erase(group_end_xx.begin(), group_end_xx.end());
    group_end_yy.erase(group_end_yy.begin(), group_end_yy.end());
    //code end here
  }  
}

void KalanjiyamWindow::edit_clear_selected_object()
{
  pSbar->push("Eraser Tool Clicked...");	
  selected_objects_delete();
  to_png();
} 

void KalanjiyamWindow::edit_clear_window1()
{
  polyline_cnt_curve_cnt();  
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
  {
  selected_items_remove();
  }
  int grid_no=root->find_child(grid);
  for(child_var=child_num; child_var>=2; child_var--)
  {
    if(grid_no!=child_var)
    {
    root->remove_child(child_var);
    child_num=child_num-1;
    }
  }
  move_var=0;
  
  if(undo_status==0)
  {
	if(undo_count>0)
	{
	  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
	  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
	  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
	  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
	  undo_count=0;
	}
    int status=7;
	int position=-1;
	std::string val1="ClearWindowStarts";
	std::string val2="GroupValues";
	std::string val3="ClearWindowEnds";
	undo_redo_tag_vector.push_back(val1);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(position);
	undo_redo_position_vector.push_back(position);
	for(int i=xml_scene_overall_tag.size()-1; i>=1; i--)
	{
	undo_redo_tag_vector.push_back(xml_scene_overall_tag[i]);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(i+1);
	undo_redo_position_vector.push_back(position);
	}
	undo_redo_tag_vector.push_back(val2);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(position);
	undo_redo_position_vector.push_back(position);
	for(int i=group_child_total_list.size()-1; i>=0; i--)
	{
	undo_redo_tag_vector.push_back(group_child_total_list[i]);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(position);
	undo_redo_position_vector.push_back(position);
	}
	undo_redo_tag_vector.push_back(val3);
	undo_redo_delete_status_vector.push_back(status);
	undo_redo_child_number_vector.push_back(position);
	undo_redo_position_vector.push_back(position);

	standing_position=undo_redo_tag_vector.size()-1;
  }
  to_png();	
  clear_global_varaiables_values();
  pSbar->push("Window Cleared ...");	
} 
void KalanjiyamWindow::edit_clear_window()
{
  polyline_cnt_curve_cnt();  
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
  {
  selected_items_remove();
  }
  for_image_indentification.clear();
  int grid_no=root->find_child(grid);
  for(child_var=child_num; child_var>=2; child_var--)
  {
    if(grid_no!=child_var)
    {
    root->remove_child(child_var);
    child_num=child_num-1;
    }
  }
  move_var=0;
  clear_global_varaiables_values();
  pSbar->push("Window Cleared ...");
} 
/*edit menu definition ends*/


void KalanjiyamWindow::file_new()
{
  if(mcanvas_show_flag==0)
  {
	event1->set_visible(true); 
    v_port8->set_visible(false);  
	//m_canvas.show();
	mcanvas_show_flag=1;
	reset_window();
  }
  else if(mcanvas_show_flag==1)
  {
	ConfirmStatus = 10;
	if (strcmp(active_file_name.c_str(), "" ) != 0)
	  file_save();
	Glib::ustring msg;
	msg = "Do You Want To Close the Current File... ?  ";
	pConfirmLabel->set_text(msg.c_str());
	pConfirmDialog->show();
  }
}

void KalanjiyamWindow::reset_window()
{
event1->set_visible(true); 
v_port8->set_visible(false);  
//m_canvas.show();
mcanvas_show_flag=1;
//
		edit_clear_window();
xml_kalanjiyam_overall_tag.clear();
global_scene_shot_number_list_vector.clear();
xml_scene_overall_tag.clear();
xml_scene_overall_tag.push_back("0");
global_scene_shot_number_list_vector.push_back("1,1");
global_temp_scene_xml = create_temp_scene_xml();
xml_kalanjiyam_overall_tag.push_back(global_temp_scene_xml);	 //For save. That is, by default for (1,1) xml should be created. add scene/add shot creates xml also.


		show_thumbnail_mode=0;
	    pNotebook->get_nth_page(1)->hide();
		//Gtk::TreeModel::Row my_row;
		if(total_rows1==0)
		{
		  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
		  Glib::RefPtr<Gtk::TreeView::Selection> refSelection =my_Tree_View_Test_Tree_View. get_selection(); 
		  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
		  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
		  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (store_iter);
		  my_Tree_View_Test_Tree_Model->erase(store_iter);
		}
		else
		{
			for(int i=0; i<total_rows1; i++)
			{
			  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
			  Glib::RefPtr<Gtk::TreeView::Selection> refSelection =my_Tree_View_Test_Tree_View. get_selection(); 
			  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
			  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
			  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (store_iter);
			  my_Tree_View_Test_Tree_Model->erase(store_iter);
			}
		}
		reset_global_variables();

xml_scene_overall_tag.push_back("0");
global_scene_shot_number_list_vector.push_back("1,1");
global_temp_scene_xml = create_temp_scene_xml();
xml_kalanjiyam_overall_tag.push_back(global_temp_scene_xml);	 //For save. That is, by default for (1,1) xml should be created. add scene/add shot creates xml also.

child_num=child_num+1;	//For tiny rectangle child
if(grid_mode==0)
view_grid();
else
child_num=child_num+1;	//For Grid child 


		Gtk::TreeModel::Row my_row;
		Glib::RefPtr<Gtk::TreeView::Selection> refSelection =my_Tree_View_Test_Tree_View. get_selection(); 
		my_row = *(my_Tree_View_Test_Tree_Model->append());
		my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/kalanjiyam_logo.png");
		my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = "Scene1 shot1";
pDialog->set_title("[New Document]   Kalanjiyam - 0.2");
		refSelection->select(my_row);


m_refDrawable = m_canvas.get_window();
Glib::RefPtr<Gdk::Pixbuf> pixbuf;

pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/arrow.svg"); 
Gdk::Cursor cursor = Gdk::Cursor(Gdk::Display::get_default(),pixbuf,0, 0);
m_refDrawable->set_cursor(cursor);

  tSave->set_sensitive(1);
  tImportImage->set_sensitive(1);
  tShowThumbnail->set_sensitive(1);
  tToolpallete->set_sensitive(1);
  pSave->set_sensitive(1);
  pSaveAs->set_sensitive(1);
  pExportFile1->set_sensitive(1);
  pExportFile2->set_sensitive(1);
  pExportFile3->set_sensitive(1);
  pExportFile4->set_sensitive(1);
  pProperties->set_sensitive(1);
  pPpreviewFile1->set_sensitive(1);
  pPpreviewFile2->set_sensitive(1);
  pPpreviewFile3->set_sensitive(1);
  pPrintAll->set_sensitive(1);
  pPrintFile1->set_sensitive(1);
  pPrintFile2->set_sensitive(1);
  pPrintFile3->set_sensitive(1);
  tGrid->set_sensitive(1);
  pImportImage->set_sensitive(1);
  pExportImage->set_sensitive(1);

  m_Combo.set_active_text("Select"); 
  pTotalFrames->set_text("");
  pSceneTitle->set_text("");

  text_buffer = Gtk::TextBuffer::create();
  text_buffer->set_text("");
  pDialogue->set_buffer(text_buffer);

  text_buffer = Gtk::TextBuffer::create();
  text_buffer->set_text("");
  pActionNotes->set_buffer(text_buffer);

  text_buffer = Gtk::TextBuffer::create();
  text_buffer->set_text("");
  pAudioNotes->set_buffer(text_buffer);
  pNotebook->set_current_page(1);
}



/*view menu definition begins*/
void KalanjiyamWindow::view_toolbar()
{
  if(toolbar_mode ==1)
  {
  toolbar_mode = 0;
  toolbar->hide();
  }
  else
  {
  toolbar_mode = 1;
  toolbar->show();
  }
} 

void KalanjiyamWindow::clear_global_varaiables_values()
{
  /*Clearing all vectors begins*/
  xml_scene_overall_tag.clear();
  group_child_total_list.clear();
  group_child_total_list_buffer.clear();
  group_child_no.clear();
  grouped_child_no.clear();
  group_child_region_no.clear();
  group_xx.clear();
  group_yy.clear();
  group_end_xx.clear();
  group_end_yy.clear();
  //copy_tag_vector.clear();
  //copy_group_temp_vector.clear();
  //copy_single_temp_vector.clear();
  copy_single_index_temp_vector.clear();
  for_grp_check=1;
  for_image_indentification.clear();	

  loaded_img_count = 1;  
  /*Clearing all vectors ends*/

  /*Loading Default Values Begins*/
  xml_scene_overall_tag.push_back("0");
  open_node_name_ellipse_string="2";
  open_node_name_line_string="2";
  open_global_python_data="";

  my_str1_last_tag_modified = "";
  my_str1_tag_modified.clear();
  my_str1_tag_modified1.clear();
  my_str1_tag = "";
  open_node_name_ellipse = "";
  open_node_name_line = "";
  global_y_diff=0;
  global_x_diff=0;
  image_edit_status = 0;	
  eraser_status = 0;
  for_image_set =0;
  erase_dragging_status = 0;

  /*Loading Default Values Begins*/
  try
  {
    if(system("exec rm -rf /tmp/Kalanjiyam/Images/convert_png/*")==0)
    {
    }
    else
    {
    throw 1;	
    }
  }
  catch(int e)
  {
    pSbar->push("Unable to Exit From Kalanjiyam...");	
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Access Temp Directory...");
    pInfoDialog->show();
  }
}

void KalanjiyamWindow::view_propertyBar()
{
  if(propertyBar_mode ==1)
  {
  propertyBar_mode = 0;
  pViewport->set_visible(false); 
  }
  else
  {
  propertyBar_mode = 1;
  pViewport->set_visible(true); 
  }
} 

void KalanjiyamWindow::view_toolPallete()
{
  if(toolPallete_mode ==1)
  {
  toolPallete_mode = 0;
  toolswindow->hide();
  }
  else
  {
  toolPallete_mode = 1;
  toolswindow->show();
  }
} 

void KalanjiyamWindow::view_kalanjiyamInfo()
{
  if(kalanjiyaInfo_mode ==1)
  {
  kalanjiyaInfo_mode = 0;
  full_screen_mode = 1;
  phan->hide();
  }
  else
  {
  kalanjiyaInfo_mode = 1;
  full_screen_mode = 0;
  phan->show();
  }
} 

void KalanjiyamWindow::view_grid()
{
  polyline_cnt_curve_cnt();
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(grid_mode ==1)
  {
    //Code starts here
    if(move_var>0 && group_child_no.size()==0)
    {
    control_points_remove();
    }
    else if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
    {
    selected_items_remove();
    }
    move_var=0;
    //Code ends here
    //Should change the single item number, while the grid is off
    //Code starts here
    Glib::ustring int_to_string_value;
    std::string total_arr;
    int grid_no=root->find_child(grid);
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="S")
      {
        int l=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(l!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list>grid_no)
            {
            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
            total_arr="S,"+int_to_string_value;
            group_child_total_list[i]=total_arr;			
            }
          }
          l++;
        }
      }
    }
    //Should change the single item number, while the grid is off
    //Code ends here
    root->remove_child(grid_no);
    grid_mode = 0;
    child_num=child_num-1;  
  }
  else
  {
    //The grid is add after the child item not a control item. So that should remove the control points before add the grid
    //Code starts here
    if(move_var>0 && group_child_no.size()==0)
    {
    control_points_remove();
    }
    else if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
    {
    selected_items_remove();
    }
    move_var=0;
    //The grid is add after the child item not a control item. So that should remove the control points before add the grid
    //Code ends here
    root->add_child(grid);
    grid_mode = 1;
    child_num=child_num+1;
  }
}

/**/
void KalanjiyamWindow::view_grid_on_off()
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(grid_mode ==1)
  {
    //Code starts here
    if(move_var>0 && group_child_no.size()==0)
    {
    control_points_remove();
    }
    else if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
    {
    selected_items_remove();
    }
    move_var=0;
    //Code ends here
    //Should change the single item number, while the grid is off
    //Code starts here
    Glib::ustring int_to_string_value;
    std::string total_arr;

    int grid_no=root->find_child(grid);
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="S")
      {
        int l=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(l!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list>grid_no)
            {
            int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
            total_arr="S,"+int_to_string_value;
            group_child_total_list[i]=total_arr;			
            }
          }
          l++;
        }
      }
    }
    //Should change the single item number, while the grid is off
    //Code ends here
    root->remove_child(grid_no);
    grid_mode = 0;
    child_num=child_num-1;  
  }
  else
  {
    //The grid is add after the child item not a control item. So that should remove the control points before add the grid
    //Code starts here
    if(move_var>0 && group_child_no.size()==0)
    {
    control_points_remove();
    }
    else if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
    {
    selected_items_remove();
    }
    move_var=0;
    //The grid is add after the child item not a control item. So that should remove the control points before add the grid
    //Code ends here
    root->add_child(grid);
    grid_mode = 1;
    child_num=child_num+1;
  }
}

/**/
void KalanjiyamWindow::text_tool()
{
  pSbar->push("Text tool clicked...");
  control_points_selected_items_remove();
  pTextTool->get_buffer()->set_text("");
  pNotebook->get_nth_page(3)->show();
  pNotebook->set_current_page(3);
  pBorderWidth->hide();
  pFont->show();
  pStrokeColor->hide();
  pFillColor->show();	
  pBorderXradius->hide();
  pBorderYradius->hide();
  pShape->hide();
  pEraserWidth->hide();

  drawing_tool_number=16;
  if(mcanvas_show_flag==1)
    show_cursor(drawing_tool_number); 
  
  Pango::FontDescription font;
  Pango::FontDescription font1;
  Glib::ustring font_name = open_global_font; //pFontButton->get_font_name();
  
  font1 = Pango::FontDescription(font_name);  
  Glib::ustring family_name = font1.get_family(); 
  open_global_xposition = 600;
  open_global_yposition = 400;
  
  font.set_family(family_name);
  pTextTool->modify_font(font);
  
  darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#000000"));
  open_global_fillcolor_hex=g_strdup_printf("#%02x%02x%02x",00000,00000,00000);
  open_global_data = pTextTool->get_buffer()->get_text();
  text_edit_index_value = 0;

  if(move_var>0)
  {
    control_points_remove();
	move_var=0;
  }
}

void KalanjiyamWindow::view_zoomIn()
{
  zoom_in();
  pSbar->push("Zoom In Clicked...");	
} 

void KalanjiyamWindow::view_zoomOut()
{
  zoom_out();
  pSbar->push("Zoom Out Clicked...");	
} 

void KalanjiyamWindow::view_resetZoom()
{
  m_canvas.set_scale(0.8);
  zoom_step_count = 1;
  pSbar->push("Zoom Reset Clicked...");	
} 

void KalanjiyamWindow::view_fullScreen()
{
  full_screen();
  pSbar->push("Screen Mode Toggled...");	
} 
/*view menu definition ends*/

/*navigation menu definition starts*/
void KalanjiyamWindow::nav_firstPanel()
{
  right_click_press_status = 0;
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("1"));
  show_selected_thumbnail_contents_in_window();
} 

void KalanjiyamWindow::nav_previousPanel()
{
 right_click_press_status = 0;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();

  Gtk::TreeModel::Row row = *iter ;
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
  Gtk::TreeModel::Row parent = *row.parent() ;

  if(row.parent())
  {
    if(path.prev())
    refSelection ->select (path); 
    else
    refSelection ->select (*parent); 
  }
  else if(row)
  {
    if(path.prev())
    {
      iter1--;
      Gtk::TreeModel::Row row1 = *iter1 ;
      Gtk::TreeModel::Children children = row1.children();
      if (children.size()>0)
      {
        Gtk::TreePath path( iter1) ;
        my_Tree_View_Test_Tree_View.expand_row(path,TRUE);
        for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
        {
        refSelection->select( chi_iter ) ;
        }
      }
      else
      refSelection->select( path ) ;
    }
  }
  else
  refSelection ->select (path); 
  show_selected_thumbnail_contents_in_window();
} 

void KalanjiyamWindow::nav_nextPanel()
{
 right_click_press_status = 0;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
  Gtk::TreeModel::Row row = *iter ;
  Gtk::TreeModel::Children children = row.children() ;
  if( children.size() > 0 )
  {
  Gtk::TreePath path( iter ) ;
  my_Tree_View_Test_Tree_View.expand_row( path, TRUE ) ;
  iter = children.begin() ;
  refSelection->select( iter ) ;
  return ;
  }
  Gtk::TreeModel::iterator next = iter ;
  next++ ;
  if( next )
  {
  refSelection->select( next ) ;
  return ;
  }
  Gtk::TreeModel::Row my_row;		
  my_row = *iter;
  Gtk::TreeModel::Row parent = *my_row.parent() ;
  parent++;
  if(parent)
  {
  refSelection->select( parent ) ;
  return ;
  }
  return ;
  show_selected_thumbnail_contents_in_window();
} 

void KalanjiyamWindow::nav_lasttPanel()
{ 
  right_click_press_status = 0;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection;
  Gtk::TreeModel::iterator iter;
  Gtk::TreeModel::iterator iter1;
  Gtk::TreeModel::Path path;
  Gtk::TreeModel::Row row;
  Gtk::TreeModel::Row row1;
  refSelection = my_Tree_View_Test_Tree_View. get_selection();
  iter = refSelection ->get_selected ();
  row = *iter;
  while(row)
  {
    if(row.parent())
    {
    refSelection = my_Tree_View_Test_Tree_View. get_selection();
    iter = refSelection ->get_selected ();
    row = *iter;
    Gtk::TreeModel::Row parent = *row.parent() ;
    Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
    path.next ();
    refSelection ->select (path);
    refSelection ->select(*parent);
    }
    else
    {
    Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
    path.next ();
    refSelection ->select (path);
    row=*(++iter);
    }
  }
  iter=refSelection ->get_selected ();
  row1=*iter;
  Gtk::TreeModel::Children children = row1.children() ;	
  if(children.size()>0)
  {
    Gtk::TreePath path( iter) ;
    my_Tree_View_Test_Tree_View.expand_row(path,TRUE);
    for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
    {
    refSelection->select( chi_iter ) ;
    }
  }
  show_selected_thumbnail_contents_in_window();
} 

void KalanjiyamWindow::nav_expandLayer()
{
  my_Tree_View_Test_Tree_View.expand_all();
  if(selection_value!=0)
  {
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
  }
  pSbar->push("Expand All Clicked ...");	
}

void KalanjiyamWindow::nav_collapseLayer()
{
  my_Tree_View_Test_Tree_View.collapse_all();
  if(selection_value!=0)
  {
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
  }
  pSbar->push("Collapse All Clicked ...");	
}

/*kalanjiyam menu definition starts*/
void KalanjiyamWindow::addScene()
{
 right_click_press_status = 0;
  on_description_save=1;
  update_tag_values();
  scene_sel_flag=1;
  edit_clear_window();
  clear_info_contents();
  clear_global_varaiables_values();
  pSbar->push("New Scene Added...");

  int row_no;
  int tot_no;
	sc_sh_add_from_any_panel();
  int local_number_of_children=global_number_of_children;
  scene_sel = scene_number_for_use;
  shot_sel = shot_number_for_use;
  if(selection_value==0)
  {	  
    global_total_panels_in_thumbnail = global_total_panels_in_thumbnail + 1;
    Glib::RefPtr<Gtk::TreeView::Selection> refSelection=my_Tree_View_Test_Tree_View. get_selection();
    Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
    if (!refSelection->get_selected() )
    {
    char buf1[10];
    sprintf(buf1,"%d",scene_number_for_use-1);
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));	
    }
    Gtk::TreeModel::Row my_row;
    my_row = *(my_Tree_View_Test_Tree_Model->append());
    Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
    Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
    refSelection->select(my_row);
    i	 = *path.get_indices().begin(); 
    row_no = *path.get_indices().begin(); 

    my_scene_number = i;

    i=i+2;
    total_rows=i;
    total_rows1=i;	

    tot_no=selec;
    scene_number = boost::lexical_cast<std::string>(i);
    if(selec+1!=i)
    {
      total_rows1=selec+1;
      scene_number = boost::lexical_cast<std::string>(total_rows1);
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/kalanjiyam_logo.png");
      full_scene_name="Scene"+scene_number+" "+"shot"+"1";
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;
    }
    else
    {
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/kalanjiyam_logo.png");
      full_scene_name="Scene"+scene_number+" "+"shot"+"1";
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;
    }
    /* ROW ALTERD*/

    // MOVE UP
    while(row_no+2 < tot_no+1)
    {
      refSelection = my_Tree_View_Test_Tree_View. get_selection();
      Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
      Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
      path.prev ();
      Gtk::TreeModel::iterator des_iter = my_Tree_View_Test_Tree_Model->get_iter(path);	
      my_Tree_View_Test_Tree_Model->move( iter,des_iter);
      tot_no=tot_no-1;
    }

    refSelection = my_Tree_View_Test_Tree_View. get_selection();
    store_iter = refSelection->get_selected();
    iter = refSelection ->get_selected ();
    Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();
    path = my_Tree_View_Test_Tree_Model->get_path (iter);
    Gtk::TreeModel::Path path1 = my_Tree_View_Test_Tree_Model->get_path (iter);
    Gtk::TreeModel::Row row;
    my_row=*iter1;

    if (refSelection->get_selected() )
    {	
      int  i	 = *path.get_indices().begin(); 
      i=i+1;
      int  j	 = *path.get_indices().begin(); 
      j=j+1;

      int rows_altered=(total_rows1)-(j);

      for(int ij=1;ij<=rows_altered+1;ij++)
      {
        scene_number = boost::lexical_cast<std::string>(i);
        full_scene_name="Scene"+scene_number+" "+"shot"+"1";
        my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;

        int k=1;
        Glib::ustring str1;

        Gtk::TreeModel::Row parent = *my_row.parent() ;
        Gtk::TreeModel::Children children = my_row.children();
        for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
        {
          k=k+1;
          std::ostringstream istr;
          istr <<k;
          str1=istr.str(); 
          full_shot_name="Scene"+scene_number+" "+"shot"+str1;
          if (!children.empty())
          {
          Gtk::TreeModel::Row row1 =  *chi_iter;
          row1[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_shot_name;
          }
        }
        i=i+1;
        my_row=*(++iter1);
      }
    }
    selection_value=0;

    Glib::ustring total_value;
    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {	
      tokenizer<> tok(global_scene_shot_number_list_vector[g]);
      int count=1;
      Glib::ustring first_value;
      Glib::ustring second_value;

      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(count==1)
        first_value=*beg;
        else
        second_value=*beg;
        count++;
      }
      total_value=first_value;
    }
    int my_shot_value;
    my_shot_value = boost::lexical_cast<int>(total_value);

    if(my_shot_value==(my_scene_number+1))
    {
      Glib::ustring ustring_scene = boost::lexical_cast<std::string>(my_scene_number+2);
      Glib::ustring ustring_shot = boost::lexical_cast<std::string>(1);
      global_scene_shot_number_list_vector.push_back(ustring_scene + "," + ustring_shot);
    }
    else
    {
     // to_png();
	for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      tokenizer<> tok(global_scene_shot_number_list_vector[g]);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }
	  int scn_no = boost::lexical_cast<int>(SceneNo);	
	  if(scn_no >= (my_scene_number+2))
	   {
		  Glib::ustring ustring_scene = boost::lexical_cast<std::string>(my_scene_number+1);
		  Glib::ustring ustring_shot ="1";
		  global_scene_shot_number_list_vector.insert(global_scene_shot_number_list_vector.begin() +g,ustring_scene + "," + ustring_shot);
		  break;
	   }
    }
	  add_scn_status=1;
    //  on_parse_layers_for_scene();
    }

    if(scene_sel==0)
    scene_sel=1;
    if(shot_sel==0)
    shot_sel=1;
    std::string scene_sel_string;
    Glib::ustring shot_sel_string;

    std::ostringstream ostr;
    ostr <<scene_sel;
    scene_sel_string = ostr.str();
    std::ostringstream istr;
    istr <<shot_sel;
    shot_sel_string=istr.str(); 
    std::string combined_form;

    combined_form=scene_sel_string+","+shot_sel_string;
    Glib::locale_from_utf8 (combined_form);
    const char* char_scene_sel = combined_form.c_str();

    int count_index_for_add_scene;
    int index_value_for_count;
    const char* vector_index_value;
    int my_size = global_scene_shot_number_list_vector.size();

    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      count_index_for_add_scene = count_index_for_add_scene + 1;
      Glib::locale_from_utf8 (global_scene_shot_number_list_vector[g]);
      vector_index_value = global_scene_shot_number_list_vector[g].c_str();
      if(strcmp(vector_index_value,char_scene_sel)==0)
      {	
      index_value_for_count=count_index_for_add_scene; break;
      }
    }

    global_current_scene_number=scene_sel;
    global_current_shot_number=shot_sel;
    if( local_number_of_children >= 1)
    {
    xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+index_value_for_count+local_number_of_children,global_temp_scene_xml);	 
    }
    else
    {
    xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+index_value_for_count,global_temp_scene_xml);	 
    }

	if(add_scn_status==1)
	      on_parse_layers_for_scene();

    global_current_scene_number = scene_sel+1;
    global_current_shot_number = 1;

    pSceneNumber->set_text(boost::lexical_cast<std::string>(global_current_scene_number));
    pShotNumber->set_text(boost::lexical_cast<std::string>(global_current_shot_number));
    show_selected_thumbnail_contents_in_window();
	add_scn_status=0;
  } 
    on_description_save=0;
} 

void KalanjiyamWindow::addShot()
{
 right_click_press_status = 0;
  on_description_save=1;
  update_tag_values();
  edit_clear_window();
  clear_info_contents();
  clear_global_varaiables_values();
  pSbar->push("New Shot Added...");

  global_total_panels_in_thumbnail = global_total_panels_in_thumbnail + 1;
  sc_sh_add_from_any_panel();
  if(selection_value==0)
  {	
    Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
    Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
    Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
    Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
    Glib::ustring shot_number;
    Glib::ustring str1;
    int child_number=1;
    Gtk::TreeModel::Row row;
    if (refSelection->get_selected() )
    {
      row = *iter;
      Gtk::TreeModel::Row my_row = *( my_Tree_View_Test_Tree_Model->append(row.children()));	
      int i=0;
      Gtk::TreeModel::Row parent = *row.parent() ;
      Gtk::TreeModel::Children children = row.children();
      i	 = *path.get_indices().begin(); 
      my_scene_number = i;
      i=i+1;

      for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
      {
        child_number++;
        std::ostringstream ostr;
        ostr <<child_number;
        str = ostr.str();
        std::ostringstream istr;
        istr <<i;
        str1=istr.str(); 
      }
      full_shot_name="Scene"+str1+" "+"shot"+str;
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/kalanjiyam_logo.png");
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_shot_name; 
    }

    global_current_shot_number = atoi(str.c_str());
    pSceneNumber->set_text(boost::lexical_cast<std::string>(global_current_scene_number));
    pShotNumber->set_text(boost::lexical_cast<std::string>(global_current_shot_number));

    Glib::ustring last_value;
    Glib::ustring correct_scene_value;
    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
    last_value = global_scene_shot_number_list_vector[g];
    }

    std::ostringstream ostr1;
    ostr1 <<my_scene_number+1;
    correct_scene_value= ostr1.str();

    Glib::ustring ch_no=	boost::lexical_cast<std::string>(child_number-1);
    correct_scene_value = correct_scene_value + "," + ch_no;
    if(correct_scene_value==last_value)
    {
      Glib::ustring ustring_scene = boost::lexical_cast<std::string>(my_scene_number+1);
      Glib::ustring ustring_shot = boost::lexical_cast<std::string>(child_number);
      
      global_scene_shot_number_list_vector.push_back(ustring_scene + "," + ustring_shot);
        
      int m =0;
      refSelection = my_Tree_View_Test_Tree_View. get_selection();
      Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();
      Gtk::TreeModel::Path path1 = my_Tree_View_Test_Tree_Model->get_path (iter1);
        
      Gtk::TreeModel::Row my_row;
      if (refSelection->get_selected() )
      {
        my_row = *iter1;	 
        Gtk::TreeModel::Row parent = *my_row.parent();
        Gtk::TreeModel::Children children = my_row.children();
        if( children.size() > 0 )
        {
          Gtk::TreePath path( iter1 ) ;
          my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
          for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
          {	  
          m++;
          }
          global_number_of_children=m;
        }
      }
    }
    else
    {

	for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      tokenizer<> tok(global_scene_shot_number_list_vector[g]);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }
	  int scn_no = boost::lexical_cast<int>(SceneNo);	
	  if(scn_no >= (my_scene_number+2))
	   {
		  Glib::ustring ustring_scene = boost::lexical_cast<std::string>(my_scene_number+1);
		  Glib::ustring ustring_shot = boost::lexical_cast<std::string>(child_number);
		  global_scene_shot_number_list_vector.insert(global_scene_shot_number_list_vector.begin() +g,ustring_scene + "," + ustring_shot);
		  break;
	   }
    }

	  add_scn_status=1;
	  int m =0;
      refSelection = my_Tree_View_Test_Tree_View. get_selection();
      Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();
      Gtk::TreeModel::Path path1 = my_Tree_View_Test_Tree_Model->get_path (iter1);
        
      Gtk::TreeModel::Row my_row;
      if (refSelection->get_selected() )
      {
        my_row = *iter1;	 
        Gtk::TreeModel::Row parent = *my_row.parent();
        Gtk::TreeModel::Children children = my_row.children();
        if( children.size() > 0 )
        {
          Gtk::TreePath path( iter1 ) ;
          my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
          for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
          {	  
          m++;
          }
          global_number_of_children=m;
        }
      }
    }
      
    pSceneNumber->set_text(boost::lexical_cast<std::string>(global_current_scene_number));
    pShotNumber->set_text(boost::lexical_cast<std::string>(global_current_shot_number));
    std::string scene_sel_string;
    Glib::ustring shot_sel_string;
    if(scene_number_for_use==0)
    scene_number_for_use=1;
    if(shot_number_for_use==0)
    shot_number_for_use=1;
    std::ostringstream ostr;
    ostr <<scene_number_for_use;
    scene_sel_string = ostr.str();
    std::ostringstream istr;
    istr <<shot_number_for_use;
    shot_sel_string=istr.str(); 
    std::string combined_form;

    combined_form=scene_sel_string+","+shot_sel_string;
    Glib::locale_from_utf8 (combined_form);
    const char* char_scene_sel = combined_form.c_str();


    int count_index_for_add_scene;
    int index_value_for_count;
    const char* vector_index_value;
    int my_size = global_scene_shot_number_list_vector.size();


    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      count_index_for_add_scene = count_index_for_add_scene + 1;
      Glib::locale_from_utf8 (global_scene_shot_number_list_vector[g]);
      vector_index_value = global_scene_shot_number_list_vector[g].c_str();
      if(strcmp(vector_index_value,char_scene_sel)==0)
      {	
      index_value_for_count=count_index_for_add_scene; break;
      }
	
    }
    global_number_of_children=global_number_of_children-1;

    xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+index_value_for_count+global_number_of_children,global_temp_scene_xml);	
    if(	add_scn_status==1)
	{
		on_parse_layers_for_shot();
	}

    Glib::ustring a1= boost::lexical_cast<std::string>(my_scene_number);
    Glib::ustring a2= boost::lexical_cast<std::string>(global_number_of_children);
    Glib::ustring a3= a1+":"+a2;
    Glib::locale_from_utf8 (a3);
    const char *char_a3 = a3.c_str();
    char buf2[10] ;
    sprintf(buf2,"%s", char_a3);
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf2)); 
	add_scn_status=0;
  }
     on_description_save=0;
}

void KalanjiyamWindow::sc_sh_add_from_any_panel()
{
	if(selection_value!=0)
  {
    int my_scene_number1;
    Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
    Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
    Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
    Gtk::TreeModel::Row row;
    if (refSelection->get_selected() )
    {
      row = *iter;
      int i=0;
      Gtk::TreeModel::Row parent = *row.parent() ;
      Gtk::TreeModel::Children children = row.children();
      i	 = *path.get_indices().begin(); 
      my_scene_number1 = i;
      char buf2[10];
      sprintf(buf2,"%d",my_scene_number1);
      my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
      my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf2));
    }
  }
}

void KalanjiyamWindow::scShotMove()
{
  
  pSceneShotMoveDialog->show();
  source_Combo.clear_items ();
  std::string source_scene = boost::lexical_cast<std::string>(global_current_scene_number)+","+boost::lexical_cast<std::string>(global_current_shot_number);
  source_Combo.append(source_scene);
  source_Combo.set_active_text(source_scene); 

  destination_Combo.clear_items();
  int dest_combo_active_text_flag = 1;
  if(global_current_shot_number==1)
  {
    for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
    { 
      tokenizer<> tok(*global_scene_shot_number_list_vector_it);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }	  
      Glib::ustring destination_scenes = *global_scene_shot_number_list_vector_it; 
      int int_shotNumber = atoi(ShotNo.c_str());
      if ((strcmp(source_scene.c_str(),destination_scenes.c_str())!=0) && (int_shotNumber==1))
      { 
        destination_Combo.append(*global_scene_shot_number_list_vector_it);
        if(dest_combo_active_text_flag==1)
        {
        destination_Combo.set_active_text(*global_scene_shot_number_list_vector_it);
        dest_combo_active_text_flag = 0;
        destination_on_combo_changed();
        }
      }
    }  
  }
  else
  {
    int temp_shot_number = global_current_shot_number;
    global_current_shot_number = 1;
    int position = find_correct_scene_shot_position();
    global_current_shot_number = temp_shot_number;
    for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
    { 
      tokenizer<> tok(*global_scene_shot_number_list_vector_it);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }
      int int_sceneNumber = atoi(SceneNo.c_str());
      int int_shotNumber = atoi(ShotNo.c_str());
      Glib::ustring destintion_shots;
      //if(int_sceneNumber==global_current_scene_number && int_shotNumber!=1 && int_shotNumber!=global_current_shot_number)
      //{
      destintion_shots = (*global_scene_shot_number_list_vector_it);
      destination_Combo.append(destintion_shots);
        //if(dest_combo_active_text_flag==1)
       // {
        destination_Combo.set_active_text(destintion_shots);
        //dest_combo_active_text_flag = 0;
        destination_on_combo_changed();
        //}
      //}
      //if(int_sceneNumber>global_current_scene_number)
      //{
      //break;
      //}
    }  	  
  }
  std::string destin_scene_shot=destination_Combo.get_active_text();
  if(strcmp(destin_scene_shot.c_str(),"")==0)
  {
  MoveOkay->set_sensitive(0);
  }
  else
  {
  MoveOkay->set_sensitive(1);
  }
  
}

void KalanjiyamWindow::moveOkay()
{
  on_description_save=1; 
  source_index = find_correct_scene_shot_position();
  source_index = source_index -1;

  //Calculation for Selected Scene //Code Starts here
  int children_count_value=0;
  Glib::ustring scene_number;
  Glib::ustring shot_number;
  tokenizer<> tokie(global_scene_shot_number_list_vector[source_index]);
  int loop_count=1;
  for(tokenizer<>::iterator beg=tokie.begin(); beg!=tokie.end();++beg)
  {
    if(loop_count==1)
    scene_number=*beg;
    else
    shot_number=*beg;
    loop_count++;
  }

	  Glib::ustring source_text = source_Combo.get_active_text();
	  string dest_text = destination_Combo.get_active_text();

	  Glib::ustring SceneNo, ShotNo;
	  int  dest_scene,dest_shot;
	  int counts=1;
	  tokenizer<> tok(dest_text);
	  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
	  {
		if(counts==1)
		SceneNo=*beg;
		else
		ShotNo=*beg;
		counts++;
	  }	

	  dest_scene = boost::lexical_cast<int>(SceneNo);	
	  dest_shot = boost::lexical_cast<int>(ShotNo);	  
	  int source_scene = boost::lexical_cast<int>(scene_number);	
	  int source_shot = boost::lexical_cast<int>(shot_number);	
	  Glib::ustring a1= boost::lexical_cast<std::string>(dest_scene-1);
	  Glib::ustring a2= boost::lexical_cast<std::string>(dest_shot-2);
	  Glib::ustring a02= boost::lexical_cast<std::string>(dest_shot-1);

	  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
	  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
	  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);

	  Gtk::TreeModel::Row my_row;		
	  my_row = *iter;
	  int move_scene;

	  drop_flag=1;

  if((source_shot==1) || (source_scene==dest_scene))
  {
	  if(strcmp(shot_number.c_str(),"1")==0)
	  {
		Glib::locale_from_utf8 (scene_number);
		const char* get_value = scene_number.c_str();
		for(int i=0; i<global_scene_shot_number_list_vector.size(); i++)
		{
		  tokenizer<> tok(global_scene_shot_number_list_vector[i]);
		  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		  {
		    Glib::ustring scene_number1=*beg;
		    Glib::locale_from_utf8 (scene_number1);
		    const char* compare_value = scene_number1.c_str();
		    if(strcmp(get_value,compare_value)==0)
		    children_count_value++;
		    break;
		  }
		}
	  }
	  else
	  children_count_value=1;
	  //Calculation for Selected Scene //Code ends here

	  //Next Scene or Next Shot find code starts here
	  std::string destin_scene_shot=destination_Combo.get_active_text();
	  tokenizer<> toki(destin_scene_shot);
	  Glib::ustring scene_number1;
	  Glib::ustring shot_number1;
	  loop_count=1;
	  for(tokenizer<>::iterator beg=toki.begin(); beg!=toki.end();++beg)
	  {
		if(loop_count==1)
		scene_number1=*beg;
		else
		shot_number1=*beg;
		loop_count++;
	  }
	  Glib::ustring nxt_scne;
	  Glib::ustring scene_or_shot;
	  if(strcmp(shot_number.c_str(),"1")==0)	
	  {
	  int selected_scene_number=boost::lexical_cast<int>(scene_number1);
	  int next_scene_number=selected_scene_number+1;
	  nxt_scne =boost::lexical_cast<std::string>(next_scene_number)+",1";
	  scene_or_shot="Scene";
	  }
	  else	
	  {
	  int selected_shot_number=boost::lexical_cast<int>(shot_number1);
	  int next_shot_number=selected_shot_number+1;
	  nxt_scne =scene_number1+","+boost::lexical_cast<std::string>(next_shot_number);
	  scene_or_shot="Shot";
	  }
	  release_index=-1;
	  for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
	  {
		Glib::ustring array_scene_shot = global_scene_shot_number_list_vector[g];
		if((strcmp(array_scene_shot.c_str(),nxt_scne.c_str())==0))
		{
		release_index = g;
		break;
		}
	  }
	  //Next Scene or Next Shot find code ends here
	  if(release_index>source_index)
	  {
		for(int i=0; i<children_count_value; i++)
		xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+release_index+i,xml_kalanjiyam_overall_tag[source_index+i]);
		for(int i=0; i<children_count_value; i++)
		xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+source_index);
	  }
	  else if(release_index<source_index)
	  {
		if(release_index==-1 && strcmp(scene_or_shot.c_str(),"Scene")==0)
		{
		  for(int i=0; i<children_count_value; i++)
		  xml_kalanjiyam_overall_tag.push_back(xml_kalanjiyam_overall_tag[source_index+i]);
		  for(int i=0; i<children_count_value; i++)
		  xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+source_index);
		}
		else if(release_index==-1 && strcmp(scene_or_shot.c_str(),"Shot")==0)
		{
		  int find_position;
		  for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
		  {
		    Glib::ustring array_scene_shot = global_scene_shot_number_list_vector[g];
		    if((strcmp(array_scene_shot.c_str(),destin_scene_shot.c_str())==0))
		    {
		    find_position = g;
		    break;
		    }
		  }
		  if(find_position==global_scene_shot_number_list_vector.size()-1)
		  {
		  xml_kalanjiyam_overall_tag.push_back(xml_kalanjiyam_overall_tag[source_index]);
		  }
		  else
		  {
		  xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+find_position+1,xml_kalanjiyam_overall_tag[source_index]);
		  }
		  xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+source_index);
		}
		else
		{
		  int source_index1=source_index;
		  for(int i=0; i<children_count_value; i++)
		  {
		  xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+release_index+i,xml_kalanjiyam_overall_tag[source_index1]);
		  source_index1=source_index1+1;
		  xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+source_index1);
		  }
		}
	  }


	  Glib::ustring status = source_text + " will be added After " + dest_text;

	  Glib::ustring SceneNo, ShotNo;
	  int  dest_scene,dest_shot;
	  int counts=1;
	  tokenizer<> tok(dest_text);
	  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
	  {
		if(counts==1)
		SceneNo=*beg;
		else
		ShotNo=*beg;
		counts++;
	  }	

	  dest_scene = boost::lexical_cast<int>(SceneNo);	
	  dest_shot = boost::lexical_cast<int>(ShotNo);	  
	  int source_scene = boost::lexical_cast<int>(scene_number);	
	  int source_shot = boost::lexical_cast<int>(shot_number);	
	  Glib::ustring a1= boost::lexical_cast<std::string>(dest_scene-1);
	  Glib::ustring a2= boost::lexical_cast<std::string>(dest_shot-2);
	  Glib::ustring a02= boost::lexical_cast<std::string>(dest_shot-1);

	  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
	  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
	  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);

	  Gtk::TreeModel::Row my_row;		
	  my_row = *iter;
	  int move_scene;

	  drop_flag=1;

	  if(dest_scene>source_scene)
	  {
		my_scene_number = source_scene-1;
		move_scene = dest_scene - source_scene;

		while(move_scene!=0)
		{
		Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
		Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
		Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
		path.next ();
		Gtk::TreeModel::iterator des_iter = my_Tree_View_Test_Tree_Model->get_iter(path);    
		my_Tree_View_Test_Tree_Model->move( des_iter,iter);
		move_scene=move_scene-1;
		}
		on_selection1_changed();
		on_parse_layers();
		char buf_t[10] ;
		sprintf(buf_t,"%d",my_scene_number);
		if (strcmp(active_file_name.c_str(), "" ) != 0)
		{
		if(my_scene_number==0)
		{
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf_t)); 
		file_save();	
		char buf[10];
		sprintf(buf,"%d", dest_scene-1);
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
		file_save();	
		}
		}  
		
		char buf2[10];
		sprintf(buf2,"%d", dest_scene-1);
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
	  }
	  else if(dest_scene<source_scene)
	  {
		my_scene_number = dest_scene;
		move_scene = source_scene - dest_scene;
		move_scene = move_scene -1;
		while(move_scene!=0)
		{
		Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
		Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
		Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
		path.prev ();
		Gtk::TreeModel::iterator des_iter = my_Tree_View_Test_Tree_Model->get_iter(path);	
		my_Tree_View_Test_Tree_Model->move( iter,des_iter);
		move_scene=move_scene-1;
		}
		on_selection1_changed();
		on_parse_layers();

		char buf2[10];
		sprintf(buf2,"%d", dest_scene);
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
	  }
	  else if(dest_scene==source_scene)
	  {
		my_scene_number = dest_scene;
		on_parse_layers();
		if(dest_shot>source_shot)
		{
		Glib::ustring a3= a1+":"+a2; 
		Glib::locale_from_utf8 (a3);
		const char *char_a3 = a3.c_str();
		char buf1[10];
		sprintf(buf1,"%s",char_a3);
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
		}
		else if(dest_shot<source_shot)
		{
		Glib::ustring a3= a1+":"+a02; 
		Glib::locale_from_utf8 (a3);
		const char *char_a3 = a3.c_str();
		char buf1[10];
		sprintf(buf1,"%s",char_a3);
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
		}
	  }
	}
   else
	{
		std::string copy_move_xml_tag;
		int copy_move_xml_tag_index;
		int paste_move_xml_tag_index;

		for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
		{
			if(source_text==global_scene_shot_number_list_vector[g])
			{
			  copy_move_xml_tag = xml_kalanjiyam_overall_tag[g];
			  copy_move_xml_tag_index = g;
			}
			if(dest_text==global_scene_shot_number_list_vector[g])
			{
			  paste_move_xml_tag_index = g;
			}
		}

		  if(source_scene<dest_scene)
			 {
				xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+copy_move_xml_tag_index);
				xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+paste_move_xml_tag_index,copy_move_xml_tag);
				my_scene_number = source_scene-1;
			  }
		  else
			{
				xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+copy_move_xml_tag_index);
				xml_kalanjiyam_overall_tag.insert(xml_kalanjiyam_overall_tag.begin()+1+paste_move_xml_tag_index,copy_move_xml_tag);
				my_scene_number = dest_scene-1;
			}

  	 	global_total_panels_in_thumbnail = global_total_panels_in_thumbnail + 1;

		Glib::RefPtr<Gtk::TreeView::Selection> refSelection;

	    Glib::ustring a1= boost::lexical_cast<std::string>(source_scene-1);
  		Glib::ustring a2= boost::lexical_cast<std::string>(source_shot-1);
  		Glib::ustring a3= a1+":"+a2;
  		Glib::locale_from_utf8 (a3);


  		const char *char_a3 = a3.c_str();
		char buf1[10];
		sprintf(buf1,"%s",char_a3);
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
		my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));


		refSelection = my_Tree_View_Test_Tree_View. get_selection();

		Gtk::TreeModel::iterator store_iter1 = refSelection->get_selected();
		Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (store_iter1 );
		refSelection->select(my_row);


		  if ( refSelection->get_selected() )
		  {
			my_Tree_View_Test_Tree_Model->erase( store_iter1 );
  		  }


		char buf_t[10] ;
		sprintf(buf_t,"%d",dest_scene-1);

		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf_t));  //N denotes N+1th row

		refSelection = my_Tree_View_Test_Tree_View. get_selection();
		Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
		  if ( refSelection->get_selected() )
		  {
			Glib::ustring ustring_scene = boost::lexical_cast<std::string>(dest_scene);
			Glib::ustring ustring_shot = boost::lexical_cast<std::string>(dest_shot+1);


			Gtk::TreeModel::Row row;
			row = *iter;
			Gtk::TreeModel::Row my_row = *( my_Tree_View_Test_Tree_Model->append(row.children()));	
			my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/kalanjiyam_logo.png");

			full_scene_name="Scene"+ustring_scene+" "+"shot"+ustring_shot;
			my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;

			  
			global_scene_shot_number_list_vector.push_back(ustring_scene + "," + ustring_shot);


			to_png();

			on_selection1_changed();
			on_parse_layers();

			}
	}

  pSceneShotMoveDialog->hide();
  show_selected_thumbnail_contents_in_window();
  on_description_save=0;
}

void KalanjiyamWindow::moveCancel()
{
pSceneShotMoveDialog->hide();
}

void KalanjiyamWindow::clear_info_contents()
{
  pSceneNumber->set_text("");
  pShotNumber->set_text("");
  m_Combo.set_active_text("Select"); 
  pTotalFrames->set_text("");
  pSceneTitle->set_text("");

  text_buffer = Gtk::TextBuffer::create();
  text_buffer->set_text("");
  pDialogue->set_buffer(text_buffer);

  text_buffer = Gtk::TextBuffer::create();
  text_buffer->set_text("");
  pActionNotes->set_buffer(text_buffer);

  text_buffer = Gtk::TextBuffer::create();
  text_buffer->set_text("");
  pAudioNotes->set_buffer(text_buffer);
  pNotebook->set_current_page(1);
}

void KalanjiyamWindow::addImportImage()
{
  right_click_press_status = 0;
  group_var="";
  polyline_cnt_curve_cnt();
  pNotebook->set_current_page(2);

  button_press_status = 1;

  Glib::RefPtr<Gdk::Pixbuf> pb;
  std::string image_url ; 
  int grid_on_status = 0;
  Gtk::FileChooserDialog dialog("Please choose a file",
  Gtk::FILE_CHOOSER_ACTION_OPEN);
  dialog.add_button(Gtk::Stock::CANCEL, Gtk::RESPONSE_CANCEL);
  dialog.add_button(Gtk::Stock::OPEN, Gtk::RESPONSE_OK);
  Gtk::FileFilter filter;
  filter.set_name(( "Image Files" ) );
  filter.add_mime_type( "image/*" );
  dialog.add_filter( filter ); 
  int result = dialog.run();
  int image_open_status=0;
  //Handle the response:
  switch(result)
  {
    case(Gtk::RESPONSE_OK):
    {
      //view_grid_on_off();
      std::string image_url = dialog.get_filename();
      std::string status = "Image Imported From : " + image_url;
      pSbar->push(status);
      mkdir("/tmp/Kalanjiyam",0750);
      Glib::ustring img_file_name="/tmp/Kalanjiyam/Images/";
      Glib::ustring img_file_name1="/tmp/Kalanjiyam/Images/convert_png/";
      Glib::ustring int_to_string_value;
      Glib::ustring img_file_extension=".png";
      Glib::ustring img_file_extension1=".jpg";
      Glib::ustring img_file_extension2=".svg";
      Glib::ustring img_file_extension4=".jpeg";
      Glib::ustring img_file_extension3=".gif";   //GIF

      Glib::ustring img_full_name_with_extension;
      Glib::ustring img_full_name_with_extension1;
	  Glib::ustring img_full_name_with_extension_png;
	  Glib::ustring img_full_name_with_extension_svg;
	  Glib::ustring img_full_name_with_extension_gif;  //GIF
	  Glib::ustring img_full_name_with_extension_jpeg;  //JPEG
	
	  
	 std::string delimiter = ".";
	 std::string storestring="";
	 std::string url_extension = image_url;


		if(image_url!="")
		{

			std::string token;

			 int pos = image_url.find(delimiter);	
			 token =  url_extension.substr(pos);

			  int img_number = loaded_img_count;
			  string my_image_number = "1";
			  loaded_img_count = loaded_img_count + 1;
			  int_to_string_value = boost::lexical_cast<std::string>(img_number);


			  img_full_name_with_extension = img_file_name + int_to_string_value + img_file_extension;
			  img_full_name_with_extension1 = img_file_name1+ my_image_number + img_file_extension1;

			  img_full_name_with_extension_svg = img_file_name1+ my_image_number + img_file_extension2;  //SVG


			  img_full_name_with_extension_gif = img_file_name1+ my_image_number + img_file_extension3;  //GIF

			  img_full_name_with_extension_jpeg = img_file_name1+ my_image_number + img_file_extension4;  //JPG

			  img_full_name_with_extension_png = img_file_name1 + my_image_number + img_file_extension;


			  const char * abc11 = img_full_name_with_extension.c_str();
			  const char * abc12 = img_full_name_with_extension1.c_str();
			  const char * abc13 = img_full_name_with_extension_png.c_str();
			  const char * abc14 = img_full_name_with_extension_svg.c_str();		//SVG
			  const char * abc15 = img_full_name_with_extension_gif.c_str();		//GIF
			  const char * abc16 = img_full_name_with_extension_jpeg.c_str();		//JPEG

	
			  if(token==".jpg" || token==".JPG")
			   {
				  try 
				  {
					image.read(image_url);
					image.write(abc12);	
					int nice = system("convert /tmp/Kalanjiyam/Images/convert_png/1.jpg -fuzz 0% -transparent white /tmp/Kalanjiyam/Images/convert_png/1.png");
				   	image.read(abc13);
					image.write(abc11);	
				  }
				  catch( Exception &error_ )
				  {
					cout << "Caught exception: " << error_.what() << endl;
				  }
			  }
		 	 else if(token==".jpeg" || token==".JPEG" )
			   {
				  try 
				  {
					image.read(image_url);
					image.write(abc16);	
					int nice = system("convert /tmp/Kalanjiyam/Images/convert_png/1.jpeg -fuzz 0% -transparent white /tmp/Kalanjiyam/Images/convert_png/1.png");
				   	image.read(abc13);
					image.write(abc11);	
				  }
				  catch( Exception &error_ )
				  {
					cout << "Caught exception: " << error_.what() << endl;
					image_open_status=1;
				  }
			  }
			 else if(token==".png")
			 {
				  try 
				  {
					image.read(image_url);
					image.write(abc13);	
					int nice = system("convert /tmp/Kalanjiyam/Images/convert_png/1.png -fuzz 0% -transparent white /tmp/Kalanjiyam/Images/convert_png/1.png");
					//image.read(image_url);
					//image.write(abc11);	
				   	image.read(abc13);
					image.write(abc11);	
				  }
				  catch( Exception &error_ )
				  {
					cout << "Caught exception: " << error_.what() << endl;
					image_open_status=1;
				  }
	
			 }
			else  if(token==".svg" || token==".SVG")
			   {
				  try 
				  {
					image.read(image_url);
					image.write(abc12);
					int nice = system("convert /tmp/Kalanjiyam/Images/convert_png/1.jpg -fuzz 0% -transparent white /tmp/Kalanjiyam/Images/convert_png/1.png");
				   	image.read(abc13);
					image.write(abc11);	
				  }
				  catch( Exception &error_ )
				  {
					cout << "Caught exception: " << error_.what() << endl;
					image_open_status=1;
				  }
			  }
			else  if(token==".gif" || token==".GIF")
			   {
				  try 
				  {
					image.read(image_url);
					image.write(abc15);
					int nice = system("convert -verbose /tmp/Kalanjiyam/Images/convert_png/1.gif /tmp/Kalanjiyam/Images/convert_png/1.png"); 
				   	image.read(abc13);
					image.write(abc11);	
				  }
				  catch( Exception &error_ )
				  {
					cout << "Caught exception: " << error_.what() << endl;
					image_open_status=1;
				  }
			  }
		 	
			else
			 {
				image_open_status=1;
			 }
	 if(image_open_status==0)
	 {
	  if(grid_mode==1)
	  {
		view_grid_on_off();
		grid_on_status = 1;  	  
  	  }

 
      pb = Gdk::Pixbuf::create_from_file(abc11);
      double w = pb->get_width();
      double h = pb->get_height();
      Glib::RefPtr<Goocanvas::Image> img = Goocanvas::Image::create(pb, 100.0 - w / 2.0, 225.0 - h / 2.0);
      m_canvas.get_root_item()->add_child(img);
      #ifdef GLIBMM_PROPERTIES_ENABLED
      img->property_width() = w ;
      img->property_height() = h ;
      img->get_property("x",open_global_xposition =0);
      img->get_property("y",open_global_yposition =0);
      img->get_property("height",open_global_height =0);
      img->get_property("width",open_global_width =0);
      #else
      img->set_property("width", w);
      img->set_property("height", h);
      #endif
      img->property_scale_to_fit()=true;
      child_num=child_num+1; 
      Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
      if(move_var>0 && group_child_no.size()==0)
      {
      control_points_remove();
      }
      else if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
      {
      selected_items_remove();
      }
	  open_node_name_curve=0;
      move_var=0;
      /*Encoding Begins*/
      Image image(abc11);
      std::string img_encode;
      Blob blob;
      image.magick("PNG"); 
      image.write( &blob);
      img_encode = blob.base64();	
      /*Encoding Ends*/

	  open_global_width = w;
	  open_global_height = h;
	  open_global_image_data = img_encode;
	  open_global_python_data = "";

	  string image_count_str =  boost::lexical_cast<std::string>(loaded_img_count-1);
	  string item_number_str =  boost::lexical_cast<std::string>(child_num);

	  string combined_image_count_item_no = image_count_str + "," + item_number_str;

	  for_image_indentification.push_back(combined_image_count_item_no);


      if(grid_mode==0)
      changed_item_num=child_num;
      else
      changed_item_num=child_num-1;

	  int m=open_global_xposition;
	  int m1=open_global_yposition;
	  int l=open_global_xposition + open_global_width;
	  int l1=open_global_yposition +open_global_height; 
	  string value_of_m,value_of_m1,value_of_l,value_of_l1;
	  value_of_m=boost::lexical_cast<std::string>(m);
	  value_of_m1=boost::lexical_cast<std::string>(m1);
	  value_of_l=boost::lexical_cast<std::string>(l);
	  value_of_l1=boost::lexical_cast<std::string>(l1);
	  open_global_data="M "+value_of_m+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_l1+" "+"L "+value_of_m+" "+value_of_l1+" "+"z";

	  button_press_status = 1;
      create_xml_for_image();	
to_png();
	 }
	else
	  {
		  pSbar->push("Image File Location Is Invaild...");
		  pInfoLabel->set_text("Image File Location Is Invaild...");
		  pInfoDialog->show();
	  }
	 }
	else
	{
		  pSbar->push("Image File Location Is Invaild...");
		  pInfoLabel->set_text("Image File Location Is Invaild...");
		  pInfoDialog->show();
	}


	  if(grid_on_status == 1)
	      view_grid_on_off();

      return;
      break;
    }
    case(Gtk::RESPONSE_CANCEL):
    {
    break;
    }
    default:
    {
    break;
    }
  }
  return ;
} 

void KalanjiyamWindow::addExportImage()
{ 
  if (strcmp(active_file_name.c_str(), "" ) != 0)
  {
    Glib::ustring export_image_dir = active_folder_name + "/ExportedImages";
    if ( access( export_image_dir.c_str(), 0 ) == 0 )
    {
      try
      {
        std::string remove_dir = "exec rm -r " + export_image_dir;
        if(system(remove_dir.c_str())!=0)
        {
        throw 1;	
        }
      }
      catch(int e)
      {
        pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Access Current Directory...");
        pInfoDialog->show();
      }
    }
    /*Directory existance check ends*/

    /*Folder creation begins */
    mkdir(export_image_dir.c_str(),0777);
    /*Folder creation ends */

    ifstream in(active_file_name.c_str());
    string input_xml;
    string line;
    Glib::ustring sceneShotImagePath = export_image_dir + "/";
    Glib::ustring img_file_name;
     Glib::ustring int_to_string_value;
    while(getline(in,line))
      input_xml += line;
	//input_xml = Decrypt(input_xml);	
    vector<char> xml_copy(input_xml.begin(), input_xml.end());
    xml_copy.push_back('\0');
    xml_document<> doc;
    doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);

    xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
    xml_node<>* Scene = Kalanjiyam->first_node("Scene");
    xml_node<> * abc;
    while (Scene != NULL )
    {
      int image_count = 1;
      Glib::ustring int_to_string_value;
      int img_status = 0, height_status = 0, width_status = 0;
      int scene_status = 0, shot_status = 0;
      Glib::ustring combine_cur_scene_shot_number;
      Glib::ustring path;
      for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
      { 
        const char * test1 = abc->name();	
        if (strcmp(test1, "SceneNumber" ) == 0)
        {
        SceneNumber = abc->value();
        global_current_scene_number = atoi(SceneNumber.c_str());
        scene_status = 1;
        }	
        if (strcmp(test1, "ShotNumber" ) == 0)
        {
        ShotNumber = abc->value();
        global_current_shot_number = atoi(ShotNumber.c_str());
        shot_status = 1;
        }
        if(scene_status==1 && shot_status==1)
        {
        combine_cur_scene_shot_number = boost::lexical_cast<std::string>(global_current_scene_number) + "," + boost::lexical_cast<std::string>(global_current_shot_number);
        path = sceneShotImagePath + combine_cur_scene_shot_number;
        mkdir(path.c_str(),0777);
        }
        int img_status = 0, height_status = 0, width_status = 0;
        for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
        {
          const char * node_name = abc->name();
          const char * node_value = abc->value();		
          open_node_name = node_name;
          open_node_value = node_value;
          const char * attribute_name = attribute->name();	
          const char * attribute_value = attribute->value();	
          open_attr_name = attribute_name;
          open_attr_value = attribute_value;
          if (strcmp(node_name, "Image") == 0)
          {
            if (strcmp(attribute_name, "data") == 0) 
            {
            open_global_data = attribute_value;
            img_status = 1;
            }
            else if (strcmp(attribute_name, "height") == 0) 
            {
            open_global_height = atof(attribute_value);
            height_status = 1;
            }
			else if (strcmp(open_attr_name, "ImageData") == 0 ) 
			 {
			open_global_image_data = open_attr_value;
			img_status = 1;
			 }
            else if (strcmp(attribute_name, "width") == 0) 
            {
            open_global_width = atof(attribute_value);
            width_status = 1;
            }
            if(img_status==1 && height_status==1 && width_status==1)
            {
              Magick::Blob lBlob;
              lBlob.base64(open_global_image_data);
              Magick::Image lTest(lBlob);
              int_to_string_value = boost::lexical_cast<std::string>(image_count);
              Glib::ustring img_file_name = path+"/"+int_to_string_value+".png";
              lTest.write(img_file_name);
              Glib::ustring size = boost::lexical_cast<std::string>(open_global_height) + "x" + boost::lexical_cast<std::string>(open_global_width);
              image.resize(size.c_str());
              lTest.write(img_file_name);
              image_count++;
              img_status = 0, height_status = 0, width_status = 0;
            }
          }
        }
      }
    Scene = Scene->next_sibling("Scene");	  
    }
  }
  else
  {
    pInfoLabel->set_text("No File Opened (or) Created Yet...");
    pInfoDialog->show();
    pSbar->push("No File Loaded (or) Created Yet......");
  }
}

void KalanjiyamWindow::addExternalImageEditor()
{
 right_click_press_status = 0;
  std::string show_gimp = "gimp";
  try
  {
    if(system(show_gimp.c_str())==0)
    {
    pSbar->push("External Editor Loaded");
    }
    else
    {
    throw 1;	
    }
  }
  catch(int e)
  {
    pSbar->push("Unable to Load External Editor");
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Load Gimp...");
    pInfoDialog->show();
  }
} 
/*kalanjiyam menu definition ends here*/

void KalanjiyamWindow::addShortcut()
{
  std::string destination_path(getenv("HOME"));
  destination_path += "/Desktop";
  std::string source_path = "/usr/share/applications/Kalanjiyam/Gui/kalanjiyam.desktop";
  
  std::string copy_syntax = "cp -r " + source_path + " " + destination_path + "/";
  try
  {
    if(system(copy_syntax.c_str())==0)
    {
    pSbar->push("Desktop Shortcut Created...");
    }
    else
    {
    throw 1;	
    }
  }
  catch(int e)
  {
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable Create Desktop Shortcut File...");
    pInfoDialog->show();
    pSbar->push("Unable to Create Desktop Shortcut File...");
  }	
}

/*about menu definition starts here*/
void KalanjiyamWindow::quickStart()
{
  std::string show_quickstart = "firefox https://launchpad.net/kathaikalam";
  try
  {
    if(system(show_quickstart.c_str())==0)
    {
    pSbar->push("Quick Start Clicked");
    }
    else
    {
    throw 1;
    }
  }
  catch(int e)
  {
    pSbar->push("Unable to Launch Quik Start...");
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Open Site in Firefox Browser...");
    pInfoDialog->show();
  }
} 

void KalanjiyamWindow::onTheWeb()
{
  std::string show_onTheWeb = "firefox https://launchpad.net/kathaikalam";
  try
  {
    if(system(show_onTheWeb.c_str())==0)
    {
    pSbar->push("Kalanjiyam On the Web Clicked");
    }
    else
    {
    throw 1;	
    }
  }
  catch(int e)
  {
    pSbar->push("Unable to Launch Kalanjiyam On the Web...");
    pInfoLabel->set_text("Kalanjiyam - 0.2 is Unable to Open Site in Firefox Browser...");
    pInfoDialog->show();
  }
} 

void KalanjiyamWindow::text_okay()
{
  open_node_name_curve=1;
  if(move_var>0)
    text_edit_index_value=1;

  polyline_cnt_curve_cnt();
  view_grid_on_off();

  darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#000000"));
  open_global_fillcolor_hex=g_strdup_printf("#%02x%02x%02x",00000,00000,00000);
  open_global_data = pTextTool->get_buffer()->get_text();

  pSbar->push("Text Added...");
  Glib::ustring font_name = pFontButton->get_font_name();
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Text> m_text;
  m_text = Goocanvas::Text::create(pTextTool->get_buffer()->get_text(),open_global_xposition,open_global_yposition);
  root->add_child(m_text);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  m_text->property_font() = font_name;
  m_text->property_line_width() = border_width;	
  m_text->property_stroke_color() = open_global_strokecolor_hex;
  m_text->property_fill_color() = open_global_fillcolor_hex;
  m_text->get_property("x",open_global_xposition =0);
  m_text->get_property("y",open_global_yposition =0);
  #else
  m_text->set_property("font", Glib::ustring("Sans 15"));
  m_text->set_property("line_width", border_width);	
  m_text->set_property("stroke_color", open_global_strokecolor_hex);	
  m_text->set_property("fill_color", open_global_fillcolor_hex);
  #endif
  child_num=child_num+1; 

  Pango::FontDescription font;
  Pango::FontDescription font1;
  
  font1 = Pango::FontDescription(font_name);  
  Glib::ustring family_name = font1.get_family(); 
  
  font.set_family(family_name);
  pTextTool->modify_font(font);
  
  darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#000000"));
  open_global_fillcolor_hex=g_strdup_printf("#%02x%02x%02x",00000,00000,00000);
  open_global_data = pTextTool->get_buffer()->get_text();

  open_global_data = pTextTool->get_buffer()->get_text();
  open_global_font = font_name;
  edit_flag=0;

  if(grid_mode==0)
    changed_item_num=child_num;
  else
    changed_item_num=child_num-1;

  create_xml_for_text();

  pTextTool->get_buffer()->set_text("");
  view_grid_on_off();
  text_edit_index_value=0;
}

void KalanjiyamWindow::text_cancel()
{
pNotebook->get_nth_page(3)->hide();
}

void KalanjiyamWindow::about()
{
  pAboutDialog->set_position(Gtk::WIN_POS_CENTER);
  pAboutDialog->show();
  pSbar->push("About Window Clicked...");
} 

/*about menu definition ends here*/
void KalanjiyamWindow::show_cursor(int a)
{
  if(pDialog)
  {int cur=0;
    m_refDrawable = m_canvas.get_window();
    Glib::RefPtr<Gdk::Pixbuf> pixbuf;
    switch(a)
    {
    case 1:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/line1.svg"); //line
    break;        
    case 2:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/shape_arrow.svg"); //arrow 
    break;        
    case 3:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/brush1.svg"); //brush
    break;        
    case 4:
    cur=1;
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/eraser_final.png"); //eraser
    break;        
    case 5:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/circle1.svg"); //ellipse
    break;        
    case 6:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/rectangle1.svg"); //rectangle
    break;        
    case 7:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/star02.svg"); //star1
    break;        
    case 8:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/star01.svg"); //star2
    break;        
    case 9:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/triangle1.svg"); //triangle
    break;        
    case 10:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/polyline1.svg"); //polyline
    break;        
    case 11:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/move21.svg"); //Move
    break;
    case 12:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/zooi.svg"); //zoom in
    break;        
    case 13:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/zooo.svg"); //zoom out
    break;        
    case 14:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/curve1.svg"); //Curve
    break; 
    case 15:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/image_collection.svg"); //Image
    break; 
    case 16:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/a15.svg"); //text
    break;        
    default:
    pixbuf = Gdk::Pixbuf::create_from_file("/usr/share/applications/Kalanjiyam/Gui/Icon/arrow.svg"); 
    break;        
    }
if(cur==0)
{
    Gdk::Cursor cursor = Gdk::Cursor(Gdk::Display::get_default(),pixbuf,0, 0);
    m_refDrawable->set_cursor(cursor);
}
else
{
  Gdk::Cursor cursor = Gdk::Cursor(Gdk::Display::get_default(),pixbuf,(eraser_width/2), (eraser_width/2));
    m_refDrawable->set_cursor(cursor);
}
  }
}

bool KalanjiyamWindow::on_Window_key_press_event(GdkEventKey *Key)
{
  int b=Key->keyval;
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(b!=65513 && b!=65514)
  group_var = gdk_keyval_name(Key->keyval);	
  std::string s1(gdk_keyval_name(Key->keyval));
  std::string s2("Escape");
  std::string s3("Delete");
  if(s1.compare(s2)==0)
  {
  polyline_cnt_curve_cnt();
  pAboutDialog->hide();
  pPreferenceDialog->hide();
  pInfoDialog->hide();
  pSceneShotMoveDialog->hide();
  pConfirmDialog->hide();
  }
  else if(s1.compare(s3)==0)		
  {
  selected_objects_delete();
  }
  return false;
}

bool KalanjiyamWindow::on_Window_key_release_event(GdkEventKey *Key)
{
  group_var = "";
}

bool KalanjiyamWindow::on_PopUpWindow_key_press_event(GdkEventKey *Key)
{
  std::string s1(gdk_keyval_name(Key->keyval));
  std::string s2("Escape");
  if(s1.compare(s2)==0)
  {
  pAboutDialog->hide();
  pPreferenceDialog->hide();
  pInfoDialog->hide();
  pSceneShotMoveDialog->hide();
  pConfirmDialog->hide();
  }
  return false;
}

void KalanjiyamWindow::on_combo_changed()
{
  Glib::ustring text = m_Combo.get_active_text();
}

void KalanjiyamWindow::preference_on_combo_changed()
{
  Glib::ustring text = preference_m_Combo.get_active_text();
}

void KalanjiyamWindow::destination_on_combo_changed()
{
  Glib::ustring source_text = source_Combo.get_active_text();
  Glib::ustring dest_text = destination_Combo.get_active_text();
  Glib::ustring status = source_text + " will be added After " + dest_text;
  pSceneShotMoveInfoLabel->set_text(status);
}

bool KalanjiyamWindow::on_button_press_event1(GdkEventButton* event)
{
  if (event->type == GDK_BUTTON_PRESS && event->button == 1) 
  {
    GtkWidget *stroke_colorseldlg = NULL;
    stroke_colorseldlg = gtk_color_selection_dialog_new ("Select Stroke color");
    GtkColorSelection *colorsel;   
    colorsel = GTK_COLOR_SELECTION (GTK_COLOR_SELECTION_DIALOG (stroke_colorseldlg)->colorsel);       
    gint response; 
    response = gtk_dialog_run (GTK_DIALOG (stroke_colorseldlg));  
    if (response == GTK_RESPONSE_OK)  
    {
      gtk_color_selection_get_current_color (colorsel, &color);
      darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));  
      darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(&color));
      gfloat r, g, b;

      r=color.red;
      g=color.green;
      b=color.blue;
      r=(r/65535)*255;
      g=(g/65535)*255;
      b=(b/65535)*255;	
      open_global_strokecolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) r,(gint) g,(gint) b);
      open_global_strokecolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) r,(gint) g,(gint) b);	
      r = round(r);   //accurate
      g = round(g);
      b = round(b);

      open_global_strokecolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) r,(gint) g,(gint) b);    //accurate	
      strokecolor = open_global_strokecolor_hex;
      gtk_widget_hide (stroke_colorseldlg);
      if(col_flag==1)
      {
      Glib::ustring storke_col = boost::lexical_cast<std::string>(open_global_strokecolor_hex);
      //my_item->set_property(Glib::ustring("stroke_color"), storke_col);
      //get_property(my_item,item_pos);

//
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==item_pos)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no==-1)
      {
		  my_item->set_property(Glib::ustring("stroke_color"), storke_col);
		  get_property(my_item,item_pos);
      }
      else
      {
		if(undo_count>0)
		{
		  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		  undo_count=0;
		}
		std::string str_val="GroupPropertyStarts";
		std::string str_val1="GroupPropertyEnds";
		int status=5;
		int position=-1;
		group_select=1;
		undo_redo_tag_vector.push_back(str_val);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              if(i==child_in_total_list)
              {
                tokenizer<> tok(group_child_total_list[i]);
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
				  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
                  Glib::RefPtr<Goocanvas::Item> get_item = root->get_child(child_in_total_list1);
				  action_status=1;	//Get Property starts
				  my_item = get_item;
				  item_pos = child_in_total_list1;
				  current_clicked_item= child_in_total_list1;
				  get_item->set_property(Glib::ustring("stroke_color"), storke_col);
				  get_property(get_item,child_in_total_list1);	//Get Property performs
				  action_status=0;	//Get Property ends
                  }
                  l++;
                }
              }
            }
          }
          k++;
        }
		if(group_select==1)
		{
		undo_redo_tag_vector.push_back(str_val1);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
		standing_position=undo_redo_tag_vector.size()-1;
		}
		group_select=0;
      }

//
      }
    }
    else
    {
      open_global_fillcolor_hex = "#FFFFFF";		
      darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
      if(col_flag==1)
      {
      Glib::ustring fil_col = boost::lexical_cast<std::string>(fillcolor);
      //my_item->set_property(Glib::ustring("fill_color"), fil_col );
      //get_property(my_item,item_pos);
//
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==item_pos)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no==-1)
      {
		 my_item->set_property(Glib::ustring("fill_color"), fil_col );
		  get_property(my_item,item_pos);
      }
      else
      {
		if(undo_count>0)
		{
		  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		  undo_count=0;
		}
		std::string str_val="GroupPropertyStarts";
		std::string str_val1="GroupPropertyEnds";
		int status=5;
		int position=-1;
		group_select=1;
		undo_redo_tag_vector.push_back(str_val);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              if(i==child_in_total_list)
              {
                tokenizer<> tok(group_child_total_list[i]);
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
				  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
                  Glib::RefPtr<Goocanvas::Item> get_item = root->get_child(child_in_total_list1);
				  action_status=1;	//Get Property starts
				  my_item = get_item;
				  item_pos = child_in_total_list1;
				  current_clicked_item= child_in_total_list1;
				  get_item->set_property(Glib::ustring("fill_color"), fil_col );	
				  get_property(get_item,child_in_total_list1);		//Get Property performs
				  action_status=0;	//Get Property ends
                  }
                  l++;
                }
              }
            }
          }
          k++;
        }
		if(group_select==1)
		{
		undo_redo_tag_vector.push_back(str_val1);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
		standing_position=undo_redo_tag_vector.size()-1;
		}
		group_select=0;
      }

//

      }
      gtk_widget_hide (stroke_colorseldlg);
    } 
  }
  to_png();
  return true;
}

bool KalanjiyamWindow::on_button_press_event2(GdkEventButton* event)
{
  if (event->type == GDK_BUTTON_PRESS && event->button == 1) 
  {
    GtkWidget *fill_colorseldlg = NULL;
    fill_colorseldlg = gtk_color_selection_dialog_new ("Select Fill color");
    GtkColorSelection *colorsel;   
    colorsel = GTK_COLOR_SELECTION (GTK_COLOR_SELECTION_DIALOG (fill_colorseldlg)->colorsel);       
    gint response; 
    response = gtk_dialog_run (GTK_DIALOG (fill_colorseldlg));  
    if (response == GTK_RESPONSE_OK)
    { 
      gtk_color_selection_get_current_color (colorsel, &color);
      darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color("#ffffff"));  
      darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(&color));  	
      gfloat r, g, b;
      r=color.red;
      g=color.green;
      b=color.blue;
      r=(r/65535)*255;
      g=(g/65535)*255;
      b=(b/65535)*255;	
      open_global_fillcolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) r,(gint) g,(gint) b);
      open_global_fillcolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) r,(gint) g,(gint) b);	
      r = round(r);   //accurate
      g = round(g);
      b = round(b);

      open_global_fillcolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) r,(gint) g,(gint) b);    //accurate	
      fillcolor = open_global_fillcolor_hex;
      gtk_widget_hide (fill_colorseldlg);
      if(col_flag==1)
      {
      Glib::ustring fil_col = boost::lexical_cast<std::string>(open_global_fillcolor_hex);
      //my_item->set_property(Glib::ustring("fill_color"), fil_col );
      //get_property(my_item,item_pos);
//
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==item_pos)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no==-1)
      {
		 my_item->set_property(Glib::ustring("fill_color"), fil_col );
		  get_property(my_item,item_pos);
      }
      else
      {
		if(undo_count>0)
		{
		  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		  undo_count=0;
		}
		std::string str_val="GroupPropertyStarts";
		std::string str_val1="GroupPropertyEnds";
		int status=5;
		int position=-1;
		group_select=1;
		undo_redo_tag_vector.push_back(str_val);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              if(i==child_in_total_list)
              {
                tokenizer<> tok(group_child_total_list[i]);
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
				  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
                  Glib::RefPtr<Goocanvas::Item> get_item = root->get_child(child_in_total_list1);
				  action_status=1;	//Get Property Starts
				  my_item = get_item;
				  item_pos = child_in_total_list1;
				  current_clicked_item= child_in_total_list1;
				  get_item->set_property(Glib::ustring("fill_color"), fil_col );	
				  get_property(get_item,child_in_total_list1);	//Get Property Performs
				  action_status=0;	//Get Property Ends
                  }
                  l++;
                }
              }
            }
          }
          k++;
        }
		if(group_select==1)
		{
		undo_redo_tag_vector.push_back(str_val1);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
		standing_position=undo_redo_tag_vector.size()-1;
		}
		group_select=0;
      }
//

      }
    }
    else
    {
      open_global_fillcolor_hex = "#FFFFFF";		
      darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
      if(col_flag==1)
      {
      Glib::ustring fil_col = boost::lexical_cast<std::string>(fillcolor);
      //my_item->set_property(Glib::ustring("fill_color"), fil_col );
      //get_property(my_item,item_pos);
//
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==item_pos)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      int group_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="G")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==single_child_same_no)
            {
            group_child_same_no=i;
            }	
          }
        }
      }
      if(group_child_same_no==-1)
      {
		 my_item->set_property(Glib::ustring("fill_color"), fil_col );
		  get_property(my_item,item_pos);
      }
      else
      {
		if(undo_count>0)
		{
		  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		  undo_count=0;
		}
		std::string str_val="GroupPropertyStarts";
		std::string str_val1="GroupPropertyEnds";
		int status=5;
		int position=-1;
		group_select=1;
		undo_redo_tag_vector.push_back(str_val);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              if(i==child_in_total_list)
              {
                tokenizer<> tok(group_child_total_list[i]);
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list1;
                  std::stringstream str(*beg);
                  str>>child_in_total_list1;
				  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
                  Glib::RefPtr<Goocanvas::Item> get_item = root->get_child(child_in_total_list1);
				  action_status=1;	//Get Property Starts
				  my_item = get_item;
				  item_pos = child_in_total_list1;
				  current_clicked_item= child_in_total_list1;
				  get_item->set_property(Glib::ustring("fill_color"), fil_col );	
				  get_property(get_item,child_in_total_list1);	//Get Property Performs
				  action_status=0;	//Get Property Ends
                  }
                  l++;
                }
              }
            }
          }
          k++;
        }
		if(group_select==1)
		{
		undo_redo_tag_vector.push_back(str_val1);
		undo_redo_child_number_vector.push_back(position);
		undo_redo_delete_status_vector.push_back(status);
		undo_redo_position_vector.push_back(position);
		standing_position=undo_redo_tag_vector.size()-1;
		}
		group_select=0;
      }

      }
      gtk_widget_hide (fill_colorseldlg);
    }
  }
  to_png();
  return true;
}

bool KalanjiyamWindow::on_right_button_press_event(GdkEventButton* event)
{
  bool return_value = false;
  if( (event->type == GDK_BUTTON_PRESS) && (event->button == 1) )
  {
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
  }
  if( (event->type == GDK_BUTTON_PRESS) && (event->button == 3) )
  {
  m_Menu_Popup.popup(event->button, event->time);
  }
  return return_value;
}

void KalanjiyamWindow::on_selection_changed()
{
  polyline_cnt_curve_cnt();
  int i=0;
  int m=0;

  Glib::RefPtr<Gtk::TreeView::Selection> refSelection;
  Gtk::TreeModel::iterator iter;

  Gtk::TreeModel::Path path;
  Gtk::TreeModel::Row row;
  Gtk::TreeModel::Row my_row;
  refSelection = my_Tree_View_Test_Tree_View. get_selection();
  iter = refSelection ->get_selected ();
  row = *iter;
  refSelection->select(my_row);
  my_row = *iter;

  if(shot_parse_status ==0)
  {
  if(row.parent())
  {
    if(on_description_save==0)
    update_tag_values();
    path = my_Tree_View_Test_Tree_Model->get_path (iter);
    i	 = *path.get_indices().begin();
    i=i+1; 
    Gtk::TreeModel::Row parent = *row.parent() ;
    Gtk::TreeModel::Children children = parent.children();
    for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
    {
      m++;	  
      if(refSelection ->is_selected(chi_iter))
      {		
        selection_value=m;
        selection_value1=m;
        std::ostringstream ostr;
        ostr << m;
        Glib::ustring str = ostr.str();
        std::ostringstream ostr1;
        ostr1 << i;		
        Glib::ustring str1= ostr1.str();
        scene_number=str1;
        Glib::ustring result;
        result=str1+"."+str;
        a = atof(result.c_str());
        scene_number_for_use=i;
        shot_number_for_use=m+1;
        if(a==1.1)
        flag_sample=1;
        selec=-1;
      }	
    }
  }
  else 	if (row)
  {
    if(on_description_save==0)
    update_tag_values();
    path = my_Tree_View_Test_Tree_Model->get_path (iter);
    i = *path.get_indices().begin();
    selec=i;
    selection_value=0;
    scene_number_for_use=i+1;
    shot_number_for_use=1;
    Gtk::TreeModel::Row parent = *row.parent() ;
    Gtk::TreeModel::Children children = row.children();
    for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
    {
    m++;	  
    }
    global_number_of_children=m;
  }
  }

  Glib::ustring int_to_string_value;
  int_to_string_value = boost::lexical_cast<std::string>(1);
  Glib::ustring thumbnail_img = "/usr/share/applications/Kalanjiyam/Gui/Icon/kalanjiyam_logo.png";
  my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file(thumbnail_img);

  std::stringstream ss2; 
  ss2 << i;
  s7 = ss2.str();
  result=s7+" . "+s6;
  scno = scene_number_for_use;
  shno = shot_number_for_use;

  global_current_scene_number = scene_number_for_use;
  global_current_shot_number = shot_number_for_use;
  text_edit_index_value=0;

  undo_redo_tag_vector.clear();
  undo_redo_child_number_vector.clear();
  undo_redo_delete_status_vector.clear();
  undo_redo_position_vector.clear();
  undo_redo_buffer_for_group.clear();
  undo_redo_buffer_for_ungroup.clear();

  show_selected_thumbnail_contents_in_window();

  if(undo_redo_tag_vector.size()>0) 
  standing_position_value=undo_redo_tag_vector.size();  

  Glib::ustring combine_cur_scene_shot_number;
  combine_cur_scene_shot_number = boost::lexical_cast<std::string>(global_current_scene_number) + "," + boost::lexical_cast<std::string>(global_current_shot_number);
  Glib::ustring msg = "Selected Scene Shot is : " + combine_cur_scene_shot_number;
  pSbar->push(msg.c_str());
}

void KalanjiyamWindow::on_selection1_changed()
{
  char buf_t[10] ;
  my_scene_number = my_scene_number-1;
  if(my_scene_number==-1)
  my_scene_number=0;

  sprintf(buf_t,"%d",my_scene_number);
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf_t)); 

  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
  Gtk::TreeModel::Path path1 = my_Tree_View_Test_Tree_Model->get_path (iter);
  Gtk::TreeModel::Row my_row;
  Gtk::TreeModel::Row row;
  my_row=*iter1;

  if (refSelection->get_selected() )
  {	
    int i	= *path.get_indices().begin(); 
    i=i+1;
    int j	= *path.get_indices().begin();
    j=j+1; 
    int rows_altered=(total_rows1)-(j);

    for(int ij=1;ij<=rows_altered+1;ij++)
    {
      scene_number = boost::lexical_cast<std::string>(i);
      full_scene_name="Scene"+scene_number+" "+"shot"+"1";
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;

      int k=1;
      Glib::ustring str1;

      Gtk::TreeModel::Row parent = *my_row.parent() ;
      Gtk::TreeModel::Children children = my_row.children();
      for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
      {
        k=k+1;
        std::ostringstream istr;
        istr <<k;
        str1=istr.str(); 
        full_shot_name="Scene"+scene_number+" "+"shot"+str1;
        if (!children.empty())
        {
        Gtk::TreeModel::Row row1 =  *chi_iter;
        row1[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_shot_name;
        }
      }
      i=i+1;
      my_row=*(++iter1);
    }
  }
  selection_value=0;
}

void KalanjiyamWindow::image_on_selection_changed()
{

  right_click_press_status = 0;
  /*Control points remove begins*/
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(move_var>0 && group_child_no.size()==0)
  {
  control_points_remove();
  }
  else if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
  {
  selected_items_remove();
  }
  move_var=0;
  polyline_cnt = 0;
  /*Control points remove ends*/
  int i=0;
  int m =0;

  Glib::RefPtr<Gtk::TreeView::Selection> refSelection;
  Gtk::TreeModel::iterator iter;
  Gtk::TreeModel::Path path;
  Gtk::TreeModel::Row row;
  refSelection = my_Tree_View_Image_Test_Tree_View.get_selection();
  iter = refSelection ->get_selected ();
  row = *iter;

  if(row.parent())
  {
    path = my_Tree_View_Image_Test_Tree_Model->get_path (iter);
    i	 = *path.get_indices().begin(); 
    Gtk::TreeModel::Row parent = *row.parent() ;
    Gtk::TreeModel::Children children = parent.children();
    for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
    {
      m++;	
      if(refSelection ->is_selected(chi_iter))
      {	
      std::ostringstream ostr;
      ostr << m;
      str = ostr.str();
      std::ostringstream ostr1;
      ostr1 << i;		
      str1= ostr1.str();
      Glib::ustring result;
      result=str1+"."+str;
      double a = atof(result.c_str());
      }	
    }
  }
  else 	if (row)
  {
  path = my_Tree_View_Image_Test_Tree_Model->get_path (iter);
  i	 = *path.get_indices().begin(); 
  }
view_grid_on_off();
  Glib::ustring selected_image_name = row[my_Tree_View_Image_Test_Tree_Model->Image_my_Tree_View_Test_Columns.my_Image_Number];
if(selected_image_name=="Symbols")
  selected_image_name=thump_list[0];
if(selected_image_name=="Animals")
  selected_image_name=thump_list[1];
if(selected_image_name=="Birds")
  selected_image_name=thump_list[2];
if(selected_image_name=="Trees")
  selected_image_name=thump_list[3];
if(selected_image_name=="Vehicles")
  selected_image_name=thump_list[4];
if(selected_image_name=="Flowers")
  selected_image_name=thump_list[5];
if(selected_image_name=="Buildings")
  selected_image_name=thump_list[6];
if(selected_image_name=="Fruits")
  selected_image_name=thump_list[7];
if(selected_image_name=="Nature")
  selected_image_name=thump_list[8];
if(selected_image_name=="Clouds")
  selected_image_name=thump_list[9];
if(selected_image_name=="Furnitures")
  selected_image_name=thump_list[10];
if(selected_image_name=="Lights")
  selected_image_name=thump_list[11];
if(selected_image_name=="Roads")
  selected_image_name=thump_list[12];
if(selected_image_name=="Camera")
  selected_image_name=thump_list[13];
if(selected_image_name=="Mountains")
  selected_image_name=thump_list[14];

  std::string ax = "/usr/share/applications/Kalanjiyam/Gui/Images/";
  std::string bx = dir_to_show_names[i] + "/Big_Image/";
  std::string cx = selected_image_name + ".png";
  /*Image Load Begins*/
  
  Glib::RefPtr<Gdk::Pixbuf> pb;
  pb = Gdk::Pixbuf::create_from_file(ax+bx+cx);
 
  
  double w = pb->get_width();
  double h = pb->get_height();
  Glib::RefPtr<Goocanvas::Image> img = Goocanvas::Image::create(pb, 100.0 - w / 2.0, 225.0 - h / 2.0);
  m_canvas.get_root_item()->add_child(img);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  img->property_width() = w ;
  img->property_height() = h ;
  img->get_property("x",open_global_xposition =0);
  img->get_property("y",open_global_yposition =0);
  img->get_property("height",open_global_height =0);
  img->get_property("width",open_global_width =0);
  #else
  img->set_property("width", w);
  img->set_property("height", h);
  #endif
  img->property_scale_to_fit()=true;
  child_num = child_num+1; 
  /*Image Load Ends*/
  /*Xml*/
  image.read(ax+bx+cx);
  Glib::ustring int_to_string_value = boost::lexical_cast<std::string>(loaded_img_count);
  Glib::ustring img_file_name = "/tmp/Kalanjiyam/Images/"+int_to_string_value+".png";
  loaded_img_count = loaded_img_count  + 1;
  image.write(img_file_name);		
  /*xml*/	
  /*Encoding Begins*/
  Image image(img_file_name);
  std::string img_encode;
  Blob blob;
  image.magick("PNG");
  image.write(&blob);
  img_encode = blob.base64();	
  /*Encoding Ends*/
  open_global_width = w;
  open_global_height = h;
  open_global_image_data = img_encode;
  open_global_python_data="";


  if(grid_mode==0)
  changed_item_num=child_num;
  else
  changed_item_num=child_num-1;

  string image_count_str =  boost::lexical_cast<std::string>(loaded_img_count-1);
  string item_number_str =  boost::lexical_cast<std::string>(child_num);

  string combined_image_count_item_no = image_count_str + "," + item_number_str;
  for_image_indentification.push_back(combined_image_count_item_no);



	int mm=open_global_xposition;
	int mm1=open_global_yposition;
	int ll=open_global_xposition + open_global_width;
	int ll1=open_global_yposition +open_global_height; 
	string value_of_m,value_of_m1,value_of_l,value_of_l1;
	value_of_m=boost::lexical_cast<std::string>(mm);
	value_of_m1=boost::lexical_cast<std::string>(mm1);
	value_of_l=boost::lexical_cast<std::string>(ll);
	value_of_l1=boost::lexical_cast<std::string>(ll1);
	open_global_data="M "+value_of_m+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_l1+" "+"L "+value_of_m+" "+value_of_l1+" "+"z";

	button_press_status = 1;
	create_xml_for_image();	
	to_png();

  
  view_grid_on_off();
	
}

void KalanjiyamWindow::ConfirmOkay()
{
	ok_flag=1;
	if(ConfirmStatus == 1)
	{
	 	file_quit();
		ok_flag=0;
	}
	else if(ConfirmStatus==2)
	{
	 	on_button_delete_layer();
		ok_flag=0;
	}
	else if(ConfirmStatus==3)
	{
		 to_png();
		 file_existance_check_for_save();
		 ok_flag=0;
	}
	else if(ConfirmStatus==4)
	{
		 to_png();
		 file_existance_check_for_saveAs();
		ok_flag=0;
	}
	else if(ConfirmStatus==5)
	{
		if(active_file_name1==active_file_name2)
		{
		 active_file_name2="";
		}
		else if(active_file_name1==active_file_name3)
		{
		 active_file_name3="";
		}
		else if(active_file_name2==active_file_name1)
		{
		 active_file_name1="";
		}
		else if(active_file_name2==active_file_name3)
		{
		 active_file_name3="";
		}
		else if(active_file_name3==active_file_name1)
		{
		 active_file_name1="";
		}
		else if(active_file_name3==active_file_name2)
		{
		 active_file_name2="";
		}
		else
		{
		 active_file_name1=active_file_name1;
		 active_file_name2=active_file_name2;
		 active_file_name3=active_file_name3;
		}
		 file_export_to_pdf_full();
		 ok_flag=0;
	}
	else if(ConfirmStatus==6)
	{
		if(active_file_name1==active_file_name2)
		{
		 active_file_name2="";
		}
		else if(active_file_name1==active_file_name3)
		{
		 active_file_name3="";
		}
		else
		{
		 active_file_name1=active_file_name1;
		}

		 file_export_to_pdf();
		 ok_flag=0;
	}
	else if(ConfirmStatus==7)
	{
		if(active_file_name2==active_file_name1)
		{
		 active_file_name1="";
		}
		else if(active_file_name2==active_file_name3)
		{
		 active_file_name3="";
		}
		else
		{
		 active_file_name2=active_file_name2;
		}
		 file_export_to_pdf1();
		 ok_flag=0;
	}
	else if(ConfirmStatus==8)
	{
		if(active_file_name3==active_file_name1)
		{
		 active_file_name1="";
		}
		else if(active_file_name3==active_file_name2)
		{
		 active_file_name2="";
		}
		else
		{
		 active_file_name3=active_file_name3;
		}
		 file_export_to_pdf2();
		 ok_flag=0;
	}
	else if(ConfirmStatus==9)
	{
		 file_open_confirm_flag=1;
		 file_open();
		ok_flag=0;
	}
	else if(ConfirmStatus==10)
	{
	 	reset_window();
		ok_flag=0;
	}
	pConfirmDialog->hide();
}

void KalanjiyamWindow::ConfirmCancel()
{
  cancel_flag=1;
  ok_flag=0;
  if(ConfirmStatus==3)
  {
    active_file_name = "";
    active_folder_name = "";
  }
  if(ConfirmStatus==4)
  {
    SaveAs_file_name = "";
  }  
  if(ConfirmStatus==5)
  {
	active_file_name1 = "";
 	active_file_name2 = "";
 	active_file_name3 = "";
    active_folder_name = "";
  }
 if(ConfirmStatus==6)
  {
	active_file_name1 = "";
  }
 if(ConfirmStatus==7)
  {
 	active_file_name2 = "";
  }
 if(ConfirmStatus==8)
  {
 	active_file_name3 = "";
  }
  ConfirmStatus = 0;
  pConfirmDialog->hide();
}
void KalanjiyamWindow::on_button_delete_layer_confirm()
{
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  if (refSelection->get_selected() )
  {
    ConfirmStatus = 2;
    Glib::ustring msg;
    global_current_scene_number = scene_number_for_use;
    global_current_shot_number = shot_number_for_use;
    Glib::ustring combine_cur_scene_shot_number = boost::lexical_cast<std::string>(global_current_scene_number) + "," + boost::lexical_cast<std::string>(global_current_shot_number);
    if(strcmp(combine_cur_scene_shot_number.c_str(),"1,1")==0)
    {
    msg = "Cannot Delete Scene-1 Shot-1";
    }
    else
    {
    msg = "Do You Want To Delete " + combine_cur_scene_shot_number +" ?";
    }
    pConfirmLabel->set_text(msg.c_str());
    pConfirmDialog->show();
  }
}

void KalanjiyamWindow::on_button_delete_layer()
{ 
  on_description_save=1;
  int first_scene_status;
  scene_sel_flag = 0;
  int i;
  int j;
  int k=0;
  int k5;
  int m=0;
  int deleted_scene_number = global_current_scene_number;
  int deleted_shot_number = global_current_shot_number;
  Glib::ustring combine_cur_scene_shot_number = boost::lexical_cast<std::string>(global_current_scene_number) + "," + boost::lexical_cast<std::string>(global_current_shot_number);
  Glib::ustring msg;
  if(global_current_scene_number==1 && global_current_shot_number==1)
  {
  msg = "Cannot Delete Scene-1 Shot-1";
  pSbar->push(msg.c_str());
  }
  else
  {
  msg = "Panel " + combine_cur_scene_shot_number + " is Deleted.";
  pSbar->push(msg.c_str());
  }
  
  global_total_panels_in_thumbnail = global_total_panels_in_thumbnail - 1;

  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
  Gtk::TreeModel::Path path1 = my_Tree_View_Test_Tree_Model->get_path (iter);

  Gtk::TreeModel::Row my_row;
  Gtk::TreeModel::Row my_row1;
  Gtk::TreeModel::Row my_row2;

  Gtk::TreeModel::Row row2 = *iter ;
  Gtk::TreeModel::Children children = row2.children() ;
  int v=children.size();

  if(selection_value==2)
  shot_flag=1;
  else
  shot_flag=0;

  if(selection_value==1 && selection_value1==1)
  {
    refSelection = my_Tree_View_Test_Tree_View. get_selection();
    iter = refSelection ->get_selected ();
    Gtk::TreeModel::Row my_row;		
    my_row = *iter;
    selection_value=1;
    selection_value1=1;
    flag_delete1=1;
  }

  Gtk::TreeModel::Row row;
  my_row=*(++iter1);
  first_scene_status = selec;
  if(my_row && selec!=0)
  {
    my_Tree_View_Test_Tree_Model->erase( store_iter );
    path.prev();
    refSelection ->select (path);
    i	 = *path.get_indices().begin();

    if(i==0)
    del_flag =1;
    else
    my_scene_number = i;

    if(selection_value==0)
    {
      i	 = *path.get_indices().begin(); 
      i=i+2;
      j	 = *path.get_indices().begin();
      j=j+2; 
      rows_altered1=(total_rows1)-(j);
      total_rows1=total_rows1-1;
    }
    else
    {
      Glib::ustring str;
      Glib::ustring str1;
      Gtk::TreeModel::Row parent = *my_row.parent() ;
      Gtk::TreeModel::Children children = parent.children();
      for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
      {	  
      m++;		   
      } 
      if(selection_value==1)
      {
        if(shot_flag==0)
        {
        k5=selection_value;
        rows_altered1=(m)-(selection_value-1);
        }
        else if(shot_flag==1)
        {
        k5=selection_value+1;
        rows_altered1=(m)-(selection_value);
        }
      }
      else
      {
      k5=selection_value+1;
      rows_altered1=(m)-(selection_value);		
      }	
      zxc=1;
    }
    for(int ij=1;ij<=rows_altered1;ij++)
    {
      if(selection_value==0)
      {
      scene_number = boost::lexical_cast<std::string>(i);
      full_scene_name="Scene"+scene_number+" "+"shot"+"1";
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;
      }
      k=1;
      Glib::ustring str1;

      Gtk::TreeModel::Row parent = *my_row.parent() ;
      if(selection_value==2)
      {  
      Gtk::TreeModel::Children children = my_row.children();	
      }
      Gtk::TreeModel::Children children = my_row.children();		
      if(zxc==1)
      {
        k5=k5+1;
        std::ostringstream istr;
        istr <<k5;
        str1=istr.str(); 
        full_shot_name="Scene"+scene_number+" "+"shot"+str1;
        my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_shot_name;
        zxc_flag=1;	
      }
      for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
      {
        if(selection_value == 0)
        { 
          k=k+1;
          std::ostringstream istr;
          istr <<k;
          str1=istr.str(); 
          full_shot_name="Scene"+scene_number+" "+"shot"+str1;
          if (!children.empty())
          {
          Gtk::TreeModel::Row row1 =  *chi_iter;
          row1[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_shot_name;
          }
        }
        else
        {
          k1=k1+1;
          std::ostringstream istr;
          istr <<k1;
          str1=istr.str(); 
          full_shot_name="Scene"+scene_number+" "+"shot"+str1;
          if (!children.empty())
          {
          Gtk::TreeModel::Row row1 =  *chi_iter;
          row1[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_shot_name;
          }
        }
      }
      i=i+1;
      my_row=*(++iter1);
    }	

    if(selection_value==2)
    shot_flag=1;
    else 
    shot_flag=0;

    k1=0;
    zxc=0;
    m=0;
  }
  else if(selec==0)
  {
  refSelection ->select (path);
  }
  else
  {
    my_Tree_View_Test_Tree_Model->erase( store_iter );
    path.prev();
    refSelection ->select (path);
    i	 = *path.get_indices().begin(); 
    if(i==0)
    del_flag =1;
    else
    my_scene_number = i;
    if(selection_value==0)
    {
    total_rows1=total_rows1-1;
    }
    else
    {
    zxc_flag=1;
    }
    flag_delete=1;	
  }
  Glib::ustring int_to_string_value1 = boost::lexical_cast<std::string>(deleted_scene_number);
  Glib::ustring int_to_string_value2 = boost::lexical_cast<std::string>(deleted_shot_number);
  Glib::ustring delete_item_remove_check_combine = 	int_to_string_value1 + "," + int_to_string_value2;
  to_png();
  if(v==0)
  {
    int pos = 0;
    for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
    { 
      pos= pos + 1;
      Glib::ustring find_scene_shot_position = *global_scene_shot_number_list_vector_it; 
      if (strcmp(delete_item_remove_check_combine.c_str(), find_scene_shot_position.c_str() ) == 0)
      {
      correct_scene_shot_position_occured = pos;
      break;	
      }
    }

    if(first_scene_status==0)
    {
    }
    else
    {
    xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+correct_scene_shot_position_occured-1);
    }
  }

  else if(v>0)
  {
    int m=correct_scene_shot_position_occured-1;
    int pos = 0;
    Glib::ustring find_scene_shot_position;
    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      pos= pos + 1;
      Glib::locale_from_utf8 (global_scene_shot_number_list_vector[g]);
      find_scene_shot_position = global_scene_shot_number_list_vector[g].c_str();
      if (strcmp(delete_item_remove_check_combine.c_str(), find_scene_shot_position.c_str() ) == 0)
      {			
      correct_scene_shot_position_occured = pos; break;
      }
    }
    int pcount=correct_scene_shot_position_occured+v;
    for(int i=correct_scene_shot_position_occured;i<=pcount;i++)
    {  
    if(first_scene_status!=0)
    xml_kalanjiyam_overall_tag.erase(xml_kalanjiyam_overall_tag.begin()+(correct_scene_shot_position_occured-1));
    }
  }
  if(first_scene_status!=0)
  {

     if(deleted_shot_number==1)
	  {
		  if((deleted_scene_number) == 2)
			{
				my_scene_number=0;
			}
		  on_parse_layers_for_delete_scene();	
		  if((deleted_scene_number) == 2)
			{
				//global_scene_shot_number_list_vector.pop_back();
			}
	  }
	  else
	  {
		  if((deleted_scene_number) == 1)
			{
				my_scene_number=0;
			}
		  on_parse_layers_for_delete_shot();

	  }
  }

 if(global_current_scene_number==1)
	{
		my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
	}

  show_selected_thumbnail_contents_in_window();
  on_description_save=0;
}

void KalanjiyamWindow::on_parse_layers()
{
 int for_selection_scene_number;
  int for_selection_shot_number;
  if(scene_number_for_use==1)
  {
  for_selection_scene_number=scene_number_for_use;
  }
  else
  {
  for_selection_scene_number=scene_number_for_use-1;
  }
  for_selection_shot_number=shot_number_for_use-2;

  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
  global_scene_shot_number_list_vector.clear();
  del_flag = 0;
  Glib::ustring ustring_scene;
  Glib::ustring ustring_shot;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);

  Gtk::TreeModel::Row my_row;		
  my_row = *iter;
  on_parse_value_status = 1;
  while(my_row)
  {
    Gtk::TreeModel::iterator next = my_row ;
    if( next )
    {	
      refSelection->select( next ) ;
      ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
      ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);
      global_scene_shot_number_list_vector.push_back(ustring_scene + "," + ustring_shot);
      Gtk::TreeModel::Row parent = *my_row.parent();
      Gtk::TreeModel::Children children = my_row.children();
      if( children.size() > 0 )
      {
        Gtk::TreePath path( iter ) ;
        my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
        for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
        {	  
        refSelection->select(chi_iter) ;
        ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
        ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);
        global_scene_shot_number_list_vector.push_back(ustring_scene + "," + ustring_shot);
        }
      }
    }
    my_row = *(++iter);
  }
  on_parse_value_status = 0;
  Glib::ustring a1= boost::lexical_cast<std::string>(for_selection_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(for_selection_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf2[10] ;
  sprintf(buf2,"%d",scene_sel);
  char buf[10];
  sprintf(buf,"%d",for_selection_scene_number);
  char buf1[10];
  sprintf(buf1,"%s",char_a3);

  if(drop_flag==0)
  {
    if(flag_delete==1 && zxc_flag==1 && flag_delete1==0)
    {
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));
    flag_delete=0;
    zxc_flag=0;
    }
    else if(scene_sel_flag==1)
    {
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf2));
    scene_sel_flag=0;
    }
    else
    {
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf));
    flag_delete=0;
    zxc_flag=0;
    flag_delete1=0;
    }
  }
  drop_flag=0;
  for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
  {
    std::string scene_total_value;
    tokenizer<> tok(*global_scene_shot_number_list_vector_it);
    int counts=1;
    Glib::ustring SceneNo;
    Glib::ustring ShotNo;
    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(counts==1)
      SceneNo=*beg;
      else
      ShotNo=*beg;
      counts++;
    }			
    global_current_scene_number = atoi(SceneNo.c_str());
    global_current_shot_number = atoi(ShotNo.c_str());
  }	

/***************************/
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
	refSelection = my_Tree_View_Test_Tree_View. get_selection();
	iter = refSelection->get_selected();
	
	my_row = *iter;
	while(my_row)
	{
		Gtk::TreeModel::iterator next = my_row ;
		if( next )
		{	
			refSelection->select( next ) ;
				Glib::ustring ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
				Glib::ustring ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);

			Glib::ustring a1= boost::lexical_cast<std::string>(ustring_scene);
			Glib::ustring a2= boost::lexical_cast<std::string>(ustring_shot);
			Glib::ustring a3= a1+":"+a2;
			Glib::locale_from_utf8 (a3);
			 const char *char_a3 = a3.c_str();

			char buf11[10];
			sprintf(buf11,"%s",char_a3);
			my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf11));
			my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf11));

			Gtk::TreeModel::Row parent = *my_row.parent();
			Gtk::TreeModel::Children children = my_row.children();
			if( children.size() > 0 )
			{
				Gtk::TreePath path( iter ) ;
				my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
				for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
				{	  
					refSelection->select(chi_iter) ;
					Glib::ustring ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
					Glib::ustring ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);

					a1= boost::lexical_cast<std::string>(ustring_scene);
					a2= boost::lexical_cast<std::string>(ustring_shot);
					a3= a1+":"+a2;
					Glib::locale_from_utf8 (a3);
					 const char *char_a3 = a3.c_str();

					char buf12[10];
					sprintf(buf12,"%s",char_a3);
					my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf12));
					my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf12));

				}
			}
		}
	  my_row = *(++iter);
	}
}


void KalanjiyamWindow::on_parse_layers_for_scene()
{
	int for_selection_scene_number;
  int for_selection_shot_number;
  if(scene_number_for_use==1)
  {
  for_selection_scene_number=scene_number_for_use;
  }
  else
  {
  for_selection_scene_number=scene_number_for_use-1;
  }
  for_selection_shot_number=shot_number_for_use-2;
  Glib::ustring join_scene_shot;
  Glib::ustring array_scene_shot;
  Glib::ustring total_value;

  total_value = boost::lexical_cast<std::string>(my_scene_number);
  join_scene_shot = total_value +","+"1";

  int find_correct_position=0;

  int pos=0;

  if(del_flag==1)
  {
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
  global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin(),global_scene_shot_number_list_vector.end());
  }
  else 
  {
    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      pos = pos+1;
      array_scene_shot = global_scene_shot_number_list_vector[g];
      tokenizer<> tok(global_scene_shot_number_list_vector[g]);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }

      if((strcmp(SceneNo.c_str(),total_value.c_str())==0))
      {
      find_correct_position = pos;
      }
    }

    char buf_t[10] ;
    sprintf(buf_t,"%d",my_scene_number);
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf_t));  //N denotes N+1th row

    global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin()+find_correct_position+1,global_scene_shot_number_list_vector.end());

  }


  del_flag = 0;
  Glib::ustring ustring_scene;
  Glib::ustring ustring_shot;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);

 std::string combine_sc_sh;

  Gtk::TreeModel::Row my_row;		
  my_row = *iter;
  on_parse_value_status = 1;
  shot_parse_status = 1;
  int my_scene_number1 = my_scene_number;
  while(my_row)
  {
	 int scene_status=0;
	 int shot_status=0;
	 int my_shot_number=2;
    Gtk::TreeModel::iterator next = my_row ;
    if( next )
    {	
	  scene_number_for_use = my_scene_number1+1;
	  shot_number_for_use = 1;

	  ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
      ustring_shot = "1";
	  combine_sc_sh = ustring_scene + "," + ustring_shot;
      for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
  	   {
			if(combine_sc_sh==global_scene_shot_number_list_vector[i])
				scene_status = 1;
	   }
	   if(scene_status==0)
	      global_scene_shot_number_list_vector.push_back(combine_sc_sh);
  		refSelection->select( next);
		on_selection_changed();

      Gtk::TreeModel::Row parent = *my_row.parent();
      Gtk::TreeModel::Children children = my_row.children();
      if( children.size() > 0 )
      {
        Gtk::TreePath path( iter ) ;
        my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
        for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
        {	  
		shot_number_for_use = my_shot_number;
		scene_number_for_use = my_scene_number1+1;
		ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
        ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);
	  	combine_sc_sh = ustring_scene + "," + ustring_shot;
		  for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
	  	   {
				if(combine_sc_sh==global_scene_shot_number_list_vector[i])
					shot_status = 1;
		   }
		   if(shot_status==0)
	      global_scene_shot_number_list_vector.push_back(combine_sc_sh);

        refSelection->select(chi_iter) ;

		my_shot_number ++;


        }
      }
	my_scene_number1 ++;
    }
    my_row = *(++iter);
  }

  on_parse_value_status = 0;
  shot_parse_status = 0;


  Glib::ustring a1= boost::lexical_cast<std::string>(for_selection_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(for_selection_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf2[10] ;
  sprintf(buf2,"%d",scene_sel);
  char buf[10];
  sprintf(buf,"%d",for_selection_scene_number);
  char buf1[10];
  sprintf(buf1,"%s",char_a3);
  
  if(drop_flag==0)
  {
    if(flag_delete==1 && zxc_flag==1 && flag_delete1==0)
    {
  //  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
   // my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));
    flag_delete=0;
    zxc_flag=0;
    }
    else if(scene_sel_flag==1)
    {


    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf2));
    scene_sel_flag=0;
    }
    else
    {
   // my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
  //  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf));
    flag_delete=0;
    zxc_flag=0;
    flag_delete1=0;
    }
  }
  drop_flag=0;
  for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
  {
    std::string scene_total_value;
    tokenizer<> tok(*global_scene_shot_number_list_vector_it);
    int counts=1;
    Glib::ustring SceneNo;
    Glib::ustring ShotNo;
    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(counts==1)
      SceneNo=*beg;
      else
      ShotNo=*beg;
      counts++;
    }			
  //  global_current_scene_number = atoi(SceneNo.c_str());
  //  global_current_shot_number = atoi(ShotNo.c_str());
  }	
}

void KalanjiyamWindow::on_parse_layers_for_shot()
{
	int for_selection_scene_number;
  int for_selection_shot_number;
  if(scene_number_for_use==1)
  {
  for_selection_scene_number=scene_number_for_use;
  }
  else
  {
  for_selection_scene_number=scene_number_for_use-1;
  }
  for_selection_shot_number=shot_number_for_use-2;
  Glib::ustring join_scene_shot;
  Glib::ustring array_scene_shot;
  Glib::ustring total_value;

  total_value = boost::lexical_cast<std::string>(my_scene_number);
  join_scene_shot = total_value +","+"1";

  int find_correct_position=0;

  int pos=0;

  if(del_flag==1)
  {
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
  global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin(),global_scene_shot_number_list_vector.end());
  }
  else 
  {
    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      pos = pos+1;
      array_scene_shot = global_scene_shot_number_list_vector[g];
      tokenizer<> tok(global_scene_shot_number_list_vector[g]);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }

      if((strcmp(SceneNo.c_str(),total_value.c_str())==0))
      {
      find_correct_position = pos;
      }
    }

    char buf_t[10] ;
    sprintf(buf_t,"%d",my_scene_number);
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf_t));  //N denotes N+1th row

    global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin()+find_correct_position+1,global_scene_shot_number_list_vector.end());

  }


  del_flag = 0;
  Glib::ustring ustring_scene;
  Glib::ustring ustring_shot;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);

 std::string combine_sc_sh;

  Gtk::TreeModel::Row my_row;		
  my_row = *iter;
  on_parse_value_status = 1;
  shot_parse_status = 1;
  int my_scene_number1 = my_scene_number;
  while(my_row)
  {
	 int scene_status=0;
	 int shot_status=0;
	 int my_shot_number=2;
    Gtk::TreeModel::iterator next = my_row ;
    if( next )
    {	
	  scene_number_for_use = my_scene_number1+1;
	  shot_number_for_use = 1;

	  ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
      ustring_shot = "1";
	  combine_sc_sh = ustring_scene + "," + ustring_shot;
      for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
  	   {
			if(combine_sc_sh==global_scene_shot_number_list_vector[i])
				scene_status = 1;
	   }
	   if(scene_status==0)
	      global_scene_shot_number_list_vector.push_back(combine_sc_sh);
  		refSelection->select( next);
		on_selection_changed();

      Gtk::TreeModel::Row parent = *my_row.parent();
      Gtk::TreeModel::Children children = my_row.children();
      if( children.size() > 0 )
      {
        Gtk::TreePath path( iter ) ;
        my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
        for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
        {	  
		shot_number_for_use = my_shot_number;
		scene_number_for_use = my_scene_number1+1;
		ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
        ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);
	  	combine_sc_sh = ustring_scene + "," + ustring_shot;
		  for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
	  	   {
				if(combine_sc_sh==global_scene_shot_number_list_vector[i])
					shot_status = 1;
		   }
		   if(shot_status==0)
		      global_scene_shot_number_list_vector.push_back(combine_sc_sh);

		refSelection->select(chi_iter) ;

		my_shot_number ++;


        }
      }
	my_scene_number1 ++;
    }
    my_row = *(++iter);
  }

  on_parse_value_status = 0;
  shot_parse_status = 0;


  Glib::ustring a1= boost::lexical_cast<std::string>(for_selection_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(for_selection_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf2[10] ;
  sprintf(buf2,"%d",scene_sel);
  char buf[10];
  sprintf(buf,"%d",for_selection_scene_number);
  char buf1[10];
  sprintf(buf1,"%s",char_a3);
  
  if(drop_flag==0)
  {
    if(flag_delete==1 && zxc_flag==1 && flag_delete1==0)
    {
  //  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
  //  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));
    flag_delete=0;
    zxc_flag=0;
    }
    else if(scene_sel_flag==1)
    {


  //  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
  //  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf2));
    scene_sel_flag=0;
    }
    else
    {
   // my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
  //  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf));
    flag_delete=0;
    zxc_flag=0;
    flag_delete1=0;
    }
  }
  drop_flag=0;
  for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
  {
    std::string scene_total_value;
    tokenizer<> tok(*global_scene_shot_number_list_vector_it);
    int counts=1;
    Glib::ustring SceneNo;
    Glib::ustring ShotNo;
    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(counts==1)
      SceneNo=*beg;
      else
      ShotNo=*beg;
      counts++;
    }			
    global_current_scene_number = atoi(SceneNo.c_str());
    global_current_shot_number = atoi(ShotNo.c_str());
  }	
}
void KalanjiyamWindow::on_parse_layers_for_delete_scene()
{
  int for_selection_scene_number;
  int for_selection_shot_number;
  if(scene_number_for_use==1)
  {
  for_selection_scene_number=scene_number_for_use;
  }
  else
  {
  for_selection_scene_number=scene_number_for_use-1;
  }
  for_selection_shot_number=shot_number_for_use-2;
  Glib::ustring join_scene_shot;
  Glib::ustring array_scene_shot;
  Glib::ustring total_value;

  total_value = boost::lexical_cast<std::string>(my_scene_number);
  join_scene_shot = total_value +","+"1";

  int find_correct_position=0;

  int pos=0;

  if(del_flag==1)
  {
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
  global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin(),global_scene_shot_number_list_vector.end());
  }
  else 
  {
    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      pos = pos+1;
      array_scene_shot = global_scene_shot_number_list_vector[g];
      tokenizer<> tok(global_scene_shot_number_list_vector[g]);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }

      if((strcmp(SceneNo.c_str(),total_value.c_str())==0))
      {
      find_correct_position = pos;
      }
    }
    char buf_t[10] ;
    sprintf(buf_t,"%d",my_scene_number);
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf_t));  //N denotes N+1th row

    global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin()+find_correct_position+1,global_scene_shot_number_list_vector.end());

  }


  del_flag = 0;
  Glib::ustring ustring_scene;
  Glib::ustring ustring_shot;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);

 std::string combine_sc_sh;

  Gtk::TreeModel::Row my_row;		
  my_row = *iter;
  on_parse_value_status = 1;
  shot_parse_status = 1;
  int my_scene_number1 = my_scene_number;
  while(my_row)
  {
	 int scene_status=0;
	 int shot_status=0;
	 int my_shot_number=2;
    Gtk::TreeModel::iterator next = my_row ;
    if( next )
    {	
	  scene_number_for_use = my_scene_number1+1;
	  shot_number_for_use = 1;

	  ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
      ustring_shot = "1";
	  combine_sc_sh = ustring_scene + "," + ustring_shot;
      for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
  	   {
			if(combine_sc_sh==global_scene_shot_number_list_vector[i])
				scene_status = 1;
	   }
	   if(scene_status==0)
	      global_scene_shot_number_list_vector.push_back(combine_sc_sh);
  		refSelection->select( next);
		on_selection_changed();
      Gtk::TreeModel::Row parent = *my_row.parent();
      Gtk::TreeModel::Children children = my_row.children();
      if( children.size() > 0 )
      {
        Gtk::TreePath path( iter ) ;
        my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
        for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
        {	  
		shot_number_for_use = my_shot_number;
		scene_number_for_use = my_scene_number1+1;
		ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
        ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);
	  	combine_sc_sh = ustring_scene + "," + ustring_shot;
		  for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
	  	   {
				if(combine_sc_sh==global_scene_shot_number_list_vector[i])
					shot_status = 1;
		   }
		   if(shot_status==0)
	      global_scene_shot_number_list_vector.push_back(combine_sc_sh);

		refSelection->select(chi_iter) ;

		my_shot_number ++;


        }
      }
	my_scene_number1 ++;
    }
    my_row = *(++iter);

  }

  on_parse_value_status = 0;
  shot_parse_status = 0;

  Glib::ustring a1= boost::lexical_cast<std::string>(for_selection_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(for_selection_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf2[10] ;
  sprintf(buf2,"%d",scene_sel);
  char buf[10];
  sprintf(buf,"%d",for_selection_scene_number);
  char buf1[10];
  sprintf(buf1,"%s",char_a3);
  

  if(drop_flag==0)
  {
    if(flag_delete==1 && zxc_flag==1 && flag_delete1==0)
    {
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf1));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf1));
    flag_delete=0;
    zxc_flag=0;
    }
    else if(scene_sel_flag==1)
    {


    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf2));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf2));
    scene_sel_flag=0;
    }
    else
    {


    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
    my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf));
    flag_delete=0;
    zxc_flag=0;
    flag_delete1=0;
    }
  }
  drop_flag=0;
  for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
  {
    std::string scene_total_value;
    tokenizer<> tok(*global_scene_shot_number_list_vector_it);
    int counts=1;
    Glib::ustring SceneNo;
    Glib::ustring ShotNo;
    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(counts==1)
      SceneNo=*beg;
      else
      ShotNo=*beg;
      counts++;
    }			
   // global_current_scene_number = atoi(SceneNo.c_str());
  //  global_current_shot_number = atoi(ShotNo.c_str());
  }	
}
void KalanjiyamWindow::on_parse_layers_for_delete_shot()
{
  int for_selection_scene_number;
  int for_selection_shot_number;
  if(scene_number_for_use==1)
  {
  for_selection_scene_number=scene_number_for_use;
  }
  else
  {
  for_selection_scene_number=scene_number_for_use-1;
  }
  for_selection_shot_number=shot_number_for_use-2;
  Glib::ustring join_scene_shot;
  Glib::ustring array_scene_shot;
  Glib::ustring total_value;

  total_value = boost::lexical_cast<std::string>(my_scene_number);
  join_scene_shot = total_value +","+"1";

  int find_correct_position=0;

  int pos=0;

  if(del_flag==1)
  {
  my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath("0"));
  my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath("0"));
  global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin(),global_scene_shot_number_list_vector.end());
  }
  else 
  {
    for(int g=0;g<global_scene_shot_number_list_vector.size();g++)
    {
      pos = pos+1;
      array_scene_shot = global_scene_shot_number_list_vector[g];
      tokenizer<> tok(global_scene_shot_number_list_vector[g]);
      int counts=1;
      Glib::ustring SceneNo;
      Glib::ustring ShotNo;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(counts==1)
        SceneNo=*beg;
        else
        ShotNo=*beg;
        counts++;
      }

      if((strcmp(SceneNo.c_str(),total_value.c_str())==0))
      {
      find_correct_position = pos;
      }
    }

    char buf_t[10] ;
    sprintf(buf_t,"%d",my_scene_number);
    my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf_t));  //N denotes N+1th row

    global_scene_shot_number_list_vector.erase(global_scene_shot_number_list_vector.begin()+find_correct_position+1,global_scene_shot_number_list_vector.end());

  }


  del_flag = 0;
  Glib::ustring ustring_scene;
  Glib::ustring ustring_shot;
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
  Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
  Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
  Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);

 std::string combine_sc_sh;

  Gtk::TreeModel::Row my_row;		
  my_row = *iter;
  on_parse_value_status = 1;
  shot_parse_status = 1;
  int my_scene_number1 = my_scene_number;
  while(my_row)
  {
	 int scene_status=0;
	 int shot_status=0;
	 int my_shot_number=2;
    Gtk::TreeModel::iterator next = my_row ;
    if( next )
    {	
	  scene_number_for_use = my_scene_number1+1;
	  shot_number_for_use = 1;

	  ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
      ustring_shot = "1";
	  combine_sc_sh = ustring_scene + "," + ustring_shot;
      for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
  	   {
			if(combine_sc_sh==global_scene_shot_number_list_vector[i])
				scene_status = 1;
	   }
	   if(scene_status==0)
	      global_scene_shot_number_list_vector.push_back(combine_sc_sh);
  		refSelection->select( next);
		on_selection_changed();

      Gtk::TreeModel::Row parent = *my_row.parent();
      Gtk::TreeModel::Children children = my_row.children();
      if( children.size() > 0 )
      {
        Gtk::TreePath path( iter ) ;
        my_Tree_View_Test_Tree_View.expand_row( path, false ) ;
        for (Gtk::TreeModel::Children::iterator chi_iter=children.begin(); chi_iter!=children.end(); chi_iter++)
        {	  
		shot_number_for_use = my_shot_number;
		scene_number_for_use = my_scene_number1+1;
		ustring_scene = boost::lexical_cast<std::string>(scene_number_for_use);
        ustring_shot = boost::lexical_cast<std::string>(shot_number_for_use);
	  	combine_sc_sh = ustring_scene + "," + ustring_shot;
		  for(int i=0;i<global_scene_shot_number_list_vector.size(); i++)
	  	   {
				if(combine_sc_sh==global_scene_shot_number_list_vector[i])
					shot_status = 1;
		   }
		   if(shot_status==0)
	      global_scene_shot_number_list_vector.push_back(combine_sc_sh);

		refSelection->select(chi_iter) ;

		my_shot_number ++;

        }
      }
	my_scene_number1 ++;
    }
    my_row = *(++iter);

  }


  on_parse_value_status = 0;
  shot_parse_status = 0;

  Glib::ustring a1= boost::lexical_cast<std::string>(for_selection_scene_number);
  Glib::ustring a2= boost::lexical_cast<std::string>(for_selection_shot_number);
  Glib::ustring a3= a1+":"+a2;
  Glib::locale_from_utf8 (a3);
  const char *char_a3 = a3.c_str();
  char buf2[10] ;
  sprintf(buf2,"%d",scene_sel);
  char buf[10];
  sprintf(buf,"%d",for_selection_scene_number);
  char buf1[10];
  sprintf(buf1,"%s",char_a3);
  

  if(drop_flag==0)
  {
    if(flag_delete==1 && zxc_flag==1 && flag_delete1==0)
    {
   my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
   my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf));
    flag_delete=0;
    zxc_flag=0;
    }
    else if(scene_sel_flag==1)
    {

   my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
   my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf));
    scene_sel_flag=0;
    }
    else
    {


   my_Tree_View_Test_Tree_View.set_cursor(Gtk::TreePath(buf));
   my_Tree_View_Test_Tree_View.scroll_to_row(Gtk::TreePath(buf));


    flag_delete=0;
    zxc_flag=0;
    flag_delete1=0;
    }
  }
  drop_flag=0;
  for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
  {
    std::string scene_total_value;
    tokenizer<> tok(*global_scene_shot_number_list_vector_it);
    int counts=1;
    Glib::ustring SceneNo;
    Glib::ustring ShotNo;
    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      if(counts==1)
      SceneNo=*beg;
      else
      ShotNo=*beg;
      counts++;
    }			
    //global_current_scene_number = atoi(SceneNo.c_str());
   // global_current_shot_number = atoi(ShotNo.c_str());
  }	

}

/*Image Tab*/
bool KalanjiyamWindow::image_tab_button_press_event(GdkEventButton* event)
{
  bool return_value = false;
  if( (event->type == GDK_BUTTON_PRESS) && (event->button == 1) )
  {
    int i=0;
    Glib::RefPtr<Gtk::TreeView::Selection> refSelection;
    Gtk::TreeModel::iterator iter;
    Gtk::TreeModel::Path path;
    Gtk::TreeModel::Row row;
    refSelection = my_Tree_View_Image_Test_Tree_View. get_selection();
    iter = refSelection ->get_selected ();
    row = *iter;
    if (row)
    {
    path = my_Tree_View_Image_Test_Tree_Model->get_path (iter);
    i	 = *path.get_indices().begin(); 
    }
  } 
  return return_value;
}
/*Image Tab*/

/*DRAG*/
Glib::ustring origin;
Glib::ustring destination;

TreeModel_Dnd::TreeModel_Dnd()
{
  set_column_types(my_Tree_View_Test_Columns);
}

Glib::RefPtr<TreeModel_Dnd> TreeModel_Dnd::create()
{
  return Glib::RefPtr<TreeModel_Dnd>( new TreeModel_Dnd() );
}

/*Thumbnail*/

/*Open-drawing parsing*/
void KalanjiyamWindow::open_create_rectangle()
{
  view_grid_on_off();
  Glib::RefPtr<Goocanvas::Rect> rect ;
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  rect = Goocanvas::Rect::create(open_global_x,open_global_y,open_global_width,open_global_height);
  root->add_child(rect);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  rect->property_line_width() = open_global_linewidth;
  rect->property_x() = open_global_xposition;
  rect->property_y() = open_global_yposition;	
  rect->property_radius_x() = open_global_xradius;
  rect->property_radius_y() = open_global_yradius;	
  rect->property_fill_color() = open_global_fillcolor_hex;
  rect->property_stroke_color() = open_global_strokecolor_hex;
  rect->rotate(0, a, b);
  #else
  rect->set_property("line_width",open_global_linewidth);
  rect->set_property("x", open_global_xposition);
  rect->set_property("y", open_global_yposition);
  rect->set_property("radius_x", open_global_xradius);
  rect->set_property("radius_y", open_global_yradius);
  rect->set_property("fill_color", open_global_fillcolor_hex);
  rect->set_property("stroke_color",open_global_strokecolor_hex);
  #endif
  child_num=child_num+1;
  if(grid_mode==0)
	changed_item_num=child_num;
  else
	changed_item_num=child_num-1;
  view_grid_on_off();
}

void KalanjiyamWindow::open_create_ellipse()
{
//Bounds  x1;
  view_grid_on_off();
  Glib::RefPtr<Goocanvas::Ellipse> ellipse ;
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item(); 
  ellipse = Goocanvas::Ellipse::create(open_global_centerx,open_global_centery,open_global_xradius,open_global_yradius);
  root->add_child(ellipse);
  //ellipse->get_requested_area(cairo *cr);
  //Cairo::RefPtr<Cairo::ImageSurface> surf= Cairo::ImageSurface::create(Cairo::FORMAT_ARGB32,1000, 650);
  //Cairo::RefPtr<Cairo::Context> cr = Cairo::Context::create(surf);
  //cr->rectangle(265, 120, 700, 500);
//ellipse->get_requested_area(cr,x1);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  ellipse->property_fill_color() = "white";
  ellipse->property_stroke_color() = "black";
  ellipse->property_line_width() = 3;
  #endif
  #ifdef GLIBMM_PROPERTIES_ENABLED
  ellipse->property_line_width() = open_global_linewidth;
  ellipse->property_x() = open_global_xposition;
  ellipse->property_y() = open_global_yposition;	
  ellipse->property_fill_color() = open_global_fillcolor_hex;
  ellipse->property_stroke_color() = open_global_strokecolor_hex;
  #else
  ellipse->set_property("line_width",open_global_linewidth);
  ellipse->set_property("x", open_global_xposition);
  ellipse->set_property("y", open_global_yposition);
  ellipse->set_property("fill_color", open_global_fillcolor_hex);
  ellipse->set_property("stroke_color",open_global_strokecolor_hex);	
  #endif
  child_num=child_num+1;
  if(grid_mode==0)
	changed_item_num=child_num;
  else
	changed_item_num=child_num-1;
  view_grid_on_off();
}
void KalanjiyamWindow::open_create_line()
{ 
  view_grid_on_off();
  Glib::RefPtr<Goocanvas::Polyline> line ;
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  line = Goocanvas::Polyline::create(open_global_x1, open_global_y1, open_global_x2, open_global_y2);
  root->add_child(line);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  line->property_line_width() = open_global_linewidth;
  line->property_x() = open_global_xposition;
  line->property_y() = open_global_yposition;	
  line->property_height() = open_global_height;
  line->property_width() = open_global_width;	
  line->property_stroke_color() = open_global_strokecolor_hex;
  line->property_start_arrow() = false ;
  line->property_end_arrow() = false ;
  line->property_arrow_tip_length() = 5.0 ;
  line->property_arrow_length() = 6.0 ;
  line->property_arrow_width() = 6.0 ;
  #else
  line->set_property("stroke_color", "black");
  line->set_property("line_width", 3);
  line->set_property("start_arrow", false);
  line->set_property("end_arrow", false);
  line->set_property("arrow_tip_length", 5.0);
  line->set_property("arrow_length", 6.0);
  line->set_property("arrow_width", 6.0);
  #endif
  child_num=child_num+1;
  if(grid_mode==0)
	changed_item_num=child_num;
  else
	changed_item_num=child_num-1;
  view_grid_on_off();
}

void KalanjiyamWindow::open_create_path()
{
  view_grid_on_off();

 Glib::RefPtr<Goocanvas::Path> path ;
 Glib::RefPtr<Goocanvas::Item> root;
 if(edit_flag==1)
  {
	root = m_canvas.get_root_item();
  	path = Goocanvas::Path::create(open_global_data); 	

    root->remove_child(current_clicked_item);
    child_num=child_num-1;

	root->add_child(path, current_clicked_item);
	child_num=child_num+1;
	my_item = path;

   if(eraser_grouped_child_no.size()==0)
	{
	Glib::ustring item_no_str = boost::lexical_cast<std::string>(find_child_item);
	Glib::ustring joined_x_y_item = "0,0";
	press_x_y=joined_x_y_item;
	}


  }

else
 {
  path = Goocanvas::Path::create(open_global_data); 	
  root = m_canvas.get_root_item();
  root->add_child(path);
  child_num=child_num+1;
 }	



  if (strcmp(open_node_value, " Star " ) == 0)
  {
  path->property_fill_color() = open_global_fillcolor_hex;
  }
  else if (strcmp(open_node_value, " Star1 " ) == 0)
  {
  path->property_fill_color() = open_global_fillcolor_hex;
  }
  else if (strcmp(open_node_value, " Triangle " ) == 0)
  {
  path->property_fill_color() = open_global_fillcolor_hex;
  }
  else if (strcmp(open_node_value, " Arrow " ) == 0)
  {
  path->property_fill_color() = open_global_fillcolor_hex;
  }
  path->property_x() = open_global_xposition;
  path->property_y() = open_global_yposition;
  path->property_height() = open_global_height;
  path->property_width() = open_global_width;		
  path->property_line_width() = open_global_linewidth;
  path->property_stroke_color() = open_global_strokecolor_hex;
  if(grid_mode==0)
	changed_item_num=child_num;
  else
	changed_item_num=child_num-1;
  view_grid_on_off();
}

void KalanjiyamWindow::open_create_image()
{
  view_grid_on_off();

  Magick::Blob lBlob;
  int m=open_global_data.size();
  if(m>0)
  {
  lBlob.base64(open_global_image_data);
  Magick::Image lTest(lBlob);
  Glib::ustring int_to_string_value;
  int_to_string_value = boost::lexical_cast<std::string>(loaded_img_count);
  loaded_img_count = loaded_img_count + 1;
  Glib::ustring img_file_name = "/tmp/Kalanjiyam/Images/"+int_to_string_value+".png";
  lTest.write(img_file_name);
  Glib::RefPtr<Gdk::Pixbuf> pb;
  pb = Gdk::Pixbuf::create_from_file(img_file_name);
  double w = pb->get_width();
  double h = pb->get_height();
  Glib::RefPtr<Goocanvas::Image> img = Goocanvas::Image::create(pb, 100.0 - w / 2.0, 225.0 - h / 2.0);
  m_canvas.get_root_item()->add_child(img);
  #ifdef GLIBMM_PROPERTIES_ENABLED
  img->property_width() = w ;
  img->property_height() = h ;
  img->property_x() = open_global_xposition;
  img->property_y() = open_global_yposition;
  img->property_width() = open_global_width;
  img->property_height() = open_global_height;	
  #else
  img->set_property("width", w);
  img->set_property("height", h);
  #endif
  img->property_scale_to_fit()=true;
  img->property_clip_path () = open_global_data;
  child_num = child_num+1; 
  if(grid_mode==0)
	changed_item_num=child_num;
  else
	changed_item_num=child_num-1;

	string image_count_str =  boost::lexical_cast<std::string>(loaded_img_count-1);
	string item_number_str =  boost::lexical_cast<std::string>(changed_item_num);

	string combined_image_count_item_no = image_count_str + "," + item_number_str;

	for_image_indentification.push_back(combined_image_count_item_no);
  }
  view_grid_on_off();
}
void KalanjiyamWindow::open_create_text()
{
  view_grid_on_off();
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  Glib::RefPtr<Goocanvas::Text> m_text;
  m_text = Goocanvas::Text::create(open_global_data,600,400);
  root->add_child(m_text);
  m_text->property_font() = open_global_font;
  m_text->property_fill_color() = open_global_fillcolor_hex;
  m_text->property_stroke_color() = open_global_strokecolor_hex;
  m_text->property_x() = open_global_xposition;
  m_text->property_y() = open_global_yposition;
  child_num=child_num+1;
  if(grid_mode==0)
	changed_item_num=child_num;
  else
	changed_item_num=child_num-1;
  view_grid_on_off();
}

void KalanjiyamWindow::open_create_group()
{
}

/*Open-drawing parsing*/
void KalanjiyamWindow::create_xml_for_line()
{
  /*xml begins*/
  Glib::ustring line_open_tag = "\n\t\t<Line";
  Glib::ustring line_x1_tag = " x1=\"";
  Glib::ustring line_y1_tag = " y1=\"";
  Glib::ustring line_x2_tag = " x2=\"";
  Glib::ustring line_y2_tag = " y2=\"";
  Glib::ustring line_stroke_color = " strokecolor=\"";
  Glib::ustring line_line_width = " linewidth=\"";

  Glib::ustring line_height_tag = " height=\"";
  Glib::ustring line_width_tag = " width=\"";

  Glib::ustring line_xposition = " xposition=\"";
  Glib::ustring line_yposition = " yposition=\"";
  Glib::ustring line_end_tag = " Line </Line>";

  Glib::ustring line_x1_tag_value = boost::lexical_cast<std::string>(open_global_x1);
  Glib::ustring line_y1_tag_value = boost::lexical_cast<std::string>(open_global_y1);
  Glib::ustring line_x2_tag_value = boost::lexical_cast<std::string>(open_global_x2);
  Glib::ustring line_y2_tag_value = boost::lexical_cast<std::string>(open_global_y2);
  Glib::ustring border_width_value = boost::lexical_cast<std::string>(open_global_linewidth);

  Glib::ustring line_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
  Glib::ustring line_width_tag_value = boost::lexical_cast<std::string>(open_global_width);

  Glib::ustring line_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
  Glib::ustring line_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);

  Glib::ustring line_tag;
  line_tag = line_open_tag + line_x1_tag + line_x1_tag_value + "\"" + line_y1_tag + line_y1_tag_value + "\""  + line_x2_tag + line_x2_tag_value + "\"" + line_y2_tag + line_y2_tag_value + "\"" + line_stroke_color + open_global_strokecolor_hex + "\"" + line_line_width + border_width_value + "\"" + line_height_tag + line_height_tag_value + "\"" + line_width_tag + line_width_tag_value + "\"" + line_xposition + line_xposition_value + "\"" + line_yposition + line_yposition_value + "\">" + line_end_tag;

  int undo_redo_delete_status;
  int position;
  if(edit_flag==1)
  {
	if(action_status==1)
	  undo_redo_delete_status=5;
	else
	  undo_redo_delete_status=1;
	changed_item_num=vec_pos+1;
    open_global_fillcolor_hex = fillcolor ;
    int vec_coun = -1;
    Glib::ustring x_val;
    for (std::vector<std::string>::iterator xml_scene_overall_tag_it = xml_scene_overall_tag.begin(); xml_scene_overall_tag_it != xml_scene_overall_tag.end(); ++xml_scene_overall_tag_it)
    { 
      vec_coun= vec_coun+1;
      if(vec_coun==vec_pos)
      {
		for(int i=0; i<undo_redo_tag_vector.size(); i++)
		{
			if(undo_redo_tag_vector[i]==xml_scene_overall_tag[vec_pos])
			{
				position=i;
				break;	
			}
		}
        xml_scene_overall_tag.at(vec_coun) = line_tag;
      }
    }
    edit_flag=0;
  }
  else
  {
  undo_redo_delete_status=0;
  changed_item_num=changed_item_num;
  position=-1;
  xml_scene_overall_tag.push_back(line_tag);
  }
  /*xml ends*/
//
//
if(undo_status==0)
{
  if(copy_paste_status==1)
  {
	undo_redo_tag_vector.push_back(line_tag);
	undo_redo_child_number_vector.push_back(changed_item_num);
	undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	undo_redo_position_vector.push_back(position);
	standing_position=undo_redo_tag_vector.size()-1;
  }
  else
  {
  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.push_back(line_tag);
  undo_redo_child_number_vector.push_back(changed_item_num);
  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = line_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)
	{	
	  if(undo_count>0 && group_select==0)
	  {
		undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		undo_count=0;
	  }
	  undo_redo_tag_vector.push_back(line_tag);
	  undo_redo_child_number_vector.push_back(changed_item_num);
	  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{	
	  if(group_select==1)	//To remove the value of "GroupPropertyStarts" from undo redo tag vector
	  {
		std::string val1=undo_redo_tag_vector[undo_redo_tag_vector.size()-1];
		std::string val2="GroupPropertyStarts";
		const char* val3=val1.c_str();
		const char* val4=val2.c_str();
		if(strcmp(val3,val4)==0)
		{
		undo_redo_tag_vector.pop_back();
		undo_redo_child_number_vector.pop_back();
		undo_redo_delete_status_vector.pop_back();
		undo_redo_position_vector.pop_back();
		}
		group_select=0;
	  }
	}
  }
  }
}
//
//
}

void KalanjiyamWindow::create_xml_for_ellipse()
{
  /*xml begins*/
  Glib::ustring ellipse_open_tag = "<Ellipse";
  Glib::ustring ellipse_close_tag = " Ellipse </Ellipse>";
  Glib::ustring ellipse_x_tag = " centerx=\"";
  Glib::ustring ellipse_y_tag = " centery=\"";
  Glib::ustring ellipse_width_tag = " xradius=\"";
  Glib::ustring ellipse_height_tag = " yradius=\"";
  Glib::ustring ellipse_stroke_color = " strokecolor=\"";
  Glib::ustring ellipse_fill_color = " fillcolor=\"";
  Glib::ustring ellipse_line_width = " linewidth=\"";

  Glib::ustring ellipse_xposition = " xposition=\"";
  Glib::ustring ellipse_yposition = " yposition=\"";

  Glib::ustring ellipse_x_tag_value = boost::lexical_cast<std::string>(open_global_centerx);
  Glib::ustring ellipse_y_tag_value = boost::lexical_cast<std::string>(open_global_centery);
  Glib::ustring ellipse_width_tag_value = boost::lexical_cast<std::string>(open_global_xradius);
  Glib::ustring ellipse_height_tag_value = boost::lexical_cast<std::string>(open_global_yradius);
  Glib::ustring ellipse_border_width_value = boost::lexical_cast<std::string>(open_global_linewidth);

  Glib::ustring ellipse_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
  Glib::ustring ellipse_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);

  Glib::ustring ellipse_tag;
  ellipse_tag = ellipse_open_tag + ellipse_x_tag + ellipse_x_tag_value + "\"" + ellipse_y_tag + ellipse_y_tag_value + "\"" + ellipse_stroke_color + open_global_strokecolor_hex + "\"" + ellipse_fill_color + open_global_fillcolor_hex + "\"" + ellipse_line_width + ellipse_border_width_value + "\"" + ellipse_height_tag + ellipse_height_tag_value + "\"" + ellipse_width_tag + ellipse_width_tag_value + "\"" + ellipse_xposition + ellipse_xposition_value + "\"" + ellipse_yposition + ellipse_yposition_value + "\">" + ellipse_close_tag;

  int undo_redo_delete_status;
  int position;
  if(edit_flag==1)
  {
	if(action_status==1)
	  undo_redo_delete_status=5;
	else
	  undo_redo_delete_status=1;
	changed_item_num=vec_pos+1;
    int vec_coun = -1;
    Glib::ustring x_val;
    for (std::vector<std::string>::iterator xml_scene_overall_tag_it = xml_scene_overall_tag.begin(); xml_scene_overall_tag_it != xml_scene_overall_tag.end(); ++xml_scene_overall_tag_it)
    { 
      vec_coun= vec_coun+1;
      if(vec_coun==vec_pos)
      {
		for(int i=0; i<undo_redo_tag_vector.size(); i++)
		{
			if(undo_redo_tag_vector[i]==xml_scene_overall_tag[vec_pos])
			{
				position=i;
				break;	
			}
		}
        xml_scene_overall_tag.at(vec_coun) = ellipse_tag;
      }
    }
    edit_flag=0;
  }
  else
  {
  undo_redo_delete_status=0;
  changed_item_num=changed_item_num;
  position=-1;
  xml_scene_overall_tag.push_back(ellipse_tag);
  }
  /*xml ends*/
//
//
if(undo_status==0)
{
  if(copy_paste_status==1)
  {
	undo_redo_tag_vector.push_back(ellipse_tag);
	undo_redo_child_number_vector.push_back(changed_item_num);
	undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	undo_redo_position_vector.push_back(position);
	standing_position=undo_redo_tag_vector.size()-1;
  }
  else
  {
  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.push_back(ellipse_tag);
  undo_redo_child_number_vector.push_back(changed_item_num);
  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = ellipse_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)
	{	
	  if(undo_count>0 && group_select==0)
	  {
		undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		undo_count=0;
	  }
	  undo_redo_tag_vector.push_back(ellipse_tag);
	  undo_redo_child_number_vector.push_back(changed_item_num);
	  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{  
	  if(group_select==1)
	  {
		std::string val1=undo_redo_tag_vector[undo_redo_tag_vector.size()-1];
		std::string val2="GroupPropertyStarts";
		const char* val3=val1.c_str();
		const char* val4=val2.c_str();
		if(strcmp(val3,val4)==0)
		{
		undo_redo_tag_vector.pop_back();
		undo_redo_child_number_vector.pop_back();
		undo_redo_delete_status_vector.pop_back();
		undo_redo_position_vector.pop_back();
		}
		group_select=0;
	  }
	}
  }
  }
}
//
//
}

void KalanjiyamWindow::create_xml_for_rectangle()
{
  Glib::ustring rect_open_tag = "<Rectangle";
  Glib::ustring rect_close_tag = " Rectangle </Rectangle>";
  Glib::ustring rect_x_tag = " x=\"";
  Glib::ustring rect_y_tag = " y=\"";
  Glib::ustring rect_width_tag = " width=\"";
  Glib::ustring rect_height_tag = " height=\"";
  Glib::ustring rect_radius_x_tag = " xradius=\"";
  Glib::ustring rect_radius_y_tag = " yradius=\"";
  Glib::ustring rect_stroke_color = " strokecolor=\"";
  Glib::ustring rect_fill_color = " fillcolor=\"";
  Glib::ustring rect_line_width = " linewidth=\"";
  Glib::ustring rect_xposition = " xposition=\"";
  Glib::ustring rect_yposition = " yposition=\"";

  Glib::ustring rect_x_tag_value = boost::lexical_cast<std::string>(open_global_x);
  Glib::ustring rect_y_tag_value = boost::lexical_cast<std::string>(open_global_y);
  Glib::ustring rect_width_tag_value = boost::lexical_cast<std::string>(open_global_width);
  Glib::ustring rect_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
  Glib::ustring rect_radius_x_tag_value = boost::lexical_cast<std::string>(open_global_xradius);
  Glib::ustring rect_radius_y_tag_value = boost::lexical_cast<std::string>(open_global_yradius);
  Glib::ustring rect_border_width_value = boost::lexical_cast<std::string>(open_global_linewidth);
  Glib::ustring rect_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
  Glib::ustring rect_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);

  Glib::ustring rect_tag;

  rect_tag = rect_open_tag + rect_x_tag + rect_x_tag_value + "\"" + rect_y_tag + rect_y_tag_value + "\""  + rect_width_tag + rect_width_tag_value + "\"" + rect_height_tag + rect_height_tag_value + "\"" + rect_radius_x_tag + rect_radius_x_tag_value + "\"" + rect_radius_y_tag + rect_radius_y_tag_value + "\"" + rect_stroke_color + open_global_strokecolor_hex + "\"" + rect_fill_color + open_global_fillcolor_hex + "\"" + rect_line_width + rect_border_width_value + "\""  + rect_xposition + rect_xposition_value + "\"" + rect_yposition + rect_yposition_value + "\">" + rect_close_tag; 

  int undo_redo_delete_status;
  int position;
  if(edit_flag==1)
  {
	if(action_status==1)
	  undo_redo_delete_status=5;
	else
	  undo_redo_delete_status=1;
	changed_item_num=vec_pos+1;
    int vec_coun = -1;
    Glib::ustring x_val;
    for (std::vector<std::string>::iterator xml_scene_overall_tag_it = xml_scene_overall_tag.begin(); xml_scene_overall_tag_it != xml_scene_overall_tag.end(); ++xml_scene_overall_tag_it)
    { 
      vec_coun= vec_coun+1;
      if(vec_coun==vec_pos)
      {
		for(int i=0; i<undo_redo_tag_vector.size(); i++)
		{
			if(undo_redo_tag_vector[i]==xml_scene_overall_tag[vec_pos])
			{
				position=i;
				break;	
			}
		}
        xml_scene_overall_tag.at(vec_coun) = rect_tag;
      }
    }
    edit_flag=0;
  }
  else
  {
  undo_redo_delete_status=0;
  changed_item_num=changed_item_num;
  position=-1;
  xml_scene_overall_tag.push_back(rect_tag);
  }
//
//
if(undo_status==0)
{
  if(copy_paste_status==1)
  {
	undo_redo_tag_vector.push_back(rect_tag);
	undo_redo_child_number_vector.push_back(changed_item_num);
	undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	undo_redo_position_vector.push_back(position);
	standing_position=undo_redo_tag_vector.size()-1;
  }
  else
  {
  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.push_back(rect_tag);
  undo_redo_child_number_vector.push_back(changed_item_num);
  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = rect_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)
	{	
	  if(undo_count>0 && group_select==0)
	  {
		undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		undo_count=0;
	  }
	  undo_redo_tag_vector.push_back(rect_tag);
	  undo_redo_child_number_vector.push_back(changed_item_num);
      undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{	
	  if(group_select==1)
	  {
		std::string val1=undo_redo_tag_vector[undo_redo_tag_vector.size()-1];
		std::string val2="GroupPropertyStarts";
		const char* val3=val1.c_str();
		const char* val4=val2.c_str();
		if(strcmp(val3,val4)==0)
		{
		undo_redo_tag_vector.pop_back();
		undo_redo_child_number_vector.pop_back();
		undo_redo_delete_status_vector.pop_back();
		undo_redo_position_vector.pop_back();
		}
		group_select=0;
	  }
	}
  }
  }
}
//
//
}

void KalanjiyamWindow::create_xml_for_path(Glib::ustring path_name1)
{

  /*xml begins*/
  Glib::ustring path_tag;
  path_tag = path_tag_after_eraser;
  if(erase_flag == 0)
	{ 	
	  Glib::ustring path_open_tag = "<Path";
	  Glib::ustring path_close_tag;
	  Glib::ustring path_fill_color;
	  const char* path_name = path_name1.c_str();
	  if (strcmp(path_name, " Arrow " ) == 0)
	  {
	  path_close_tag = " Arrow </Path>";	
	  path_fill_color = " fillcolor=\"";
	  }
	  else if (strcmp(path_name, " Brush " ) == 0)	
	  {
	  path_close_tag = " Brush </Path>";	
	  }
	  else if (strcmp(path_name, " Line " ) == 0)	
	  {
	  path_close_tag = " Line </Path>";	
	  }
	  else if (strcmp(path_name, " Star " ) == 0)	
	  {
	  path_close_tag = " Star </Path>";	
	  path_fill_color = " fillcolor=\"";
	  }
	  else if (strcmp(path_name, " Star1 " ) == 0)	
	  {
	  path_close_tag = " Star1 </Path>";	
	  path_fill_color = " fillcolor=\"";
	  }
	  else if (strcmp(path_name, " Triangle " ) == 0)	
	  {
	  path_close_tag = " Triangle </Path>";	
	  path_fill_color = " fillcolor=\"";
	  }
	  else if (strcmp(path_name, " Curve " ) == 0)	
	  {
	  path_close_tag = " Curve </Path>";	
	  }
	  else if (strcmp(path_name, " Polyline " ) == 0)	
	  {
	  path_close_tag = " Polyline </Path>";	
	  }

	  Glib::ustring path_i_tag = " data=\"";
	  Glib::ustring path_py_tag = " py_data=\"";
	  Glib::ustring path_stroke_color = " strokecolor=\"";
	  Glib::ustring path_line_width = " linewidth=\"";

	  Glib::ustring path_height_tag = " height=\"";
	  Glib::ustring path_width_tag = " width=\"";

	  Glib::ustring path_xposition = " xposition=\"";
	  Glib::ustring path_yposition = " yposition=\"";

	  Glib::ustring path_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
	  Glib::ustring path_width_tag_value = boost::lexical_cast<std::string>(open_global_width);

	  Glib::ustring path_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
	  Glib::ustring path_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
	  Glib::ustring path_width_value = boost::lexical_cast<std::string>(open_global_linewidth);
		if ((strcmp(path_name, " Curve " ) == 0) ||	(strcmp(path_name, " Line " ) == 0) ||	(strcmp(path_name, " Brush " ) == 0) || (strcmp(path_name, " Polyline " ) == 0))
	  {
	  path_tag = path_open_tag + path_i_tag + open_global_data + "\"" + path_py_tag + open_global_python_data + "\"" + path_stroke_color + open_global_strokecolor_hex + "\"" + path_line_width + path_width_value + "\""  + path_xposition + path_xposition_value + "\"" + path_yposition + path_yposition_value + "\"" + path_width_tag + path_width_tag_value + "\"" + path_height_tag + path_height_tag_value + "\">" + path_close_tag;
	  }
	  else
	  {

	  path_tag = path_open_tag + path_i_tag + open_global_data + "\"" + path_py_tag + open_global_python_data + "\"" + path_stroke_color + open_global_strokecolor_hex + "\"" + path_fill_color + open_global_fillcolor_hex + "\"" + path_line_width + path_width_value + "\""  + path_xposition + path_xposition_value + "\"" + path_yposition + path_yposition_value + "\"" + path_width_tag + path_width_tag_value + "\"" + path_height_tag + path_height_tag_value + "\">" + path_close_tag;
	  }	
	}

  int undo_redo_delete_status;
  int position=-1;
  if(edit_flag==1)
  {
	if(action_status==1)
	  undo_redo_delete_status=5;
	else
      undo_redo_delete_status=1;
	changed_item_num=vec_pos+1;
    open_global_fillcolor_hex = fillcolor ;
    int vec_coun = -1;
    Glib::ustring x_val;
    for (std::vector<std::string>::iterator xml_scene_overall_tag_it = xml_scene_overall_tag.begin(); xml_scene_overall_tag_it != xml_scene_overall_tag.end(); ++xml_scene_overall_tag_it)
    { 
      vec_coun= vec_coun+1;
      if(vec_coun==vec_pos)
      {
		for(int i=0; i<undo_redo_tag_vector.size(); i++)
		{
			if(undo_redo_tag_vector[i]==xml_scene_overall_tag[vec_pos])
			{
				position=i;
				break;	
			}
		}
        xml_scene_overall_tag.at(vec_coun) = path_tag;
      }
    }
    edit_flag=0;
  }
  else
  {
  undo_redo_delete_status=0;
  changed_item_num=changed_item_num;
  position=-1;
  xml_scene_overall_tag.push_back(path_tag);
  }

//undo-redo-code-starts here
//undo-redo-code-starts here
if(undo_status==0)
{
  if(copy_paste_status==1)
  {
	undo_redo_tag_vector.push_back(path_tag);
	undo_redo_child_number_vector.push_back(changed_item_num);
	undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	undo_redo_position_vector.push_back(position);
	standing_position=undo_redo_tag_vector.size()-1;
  }
  else
  {
  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.push_back(path_tag);
  undo_redo_child_number_vector.push_back(changed_item_num);
  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = path_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)// && position!=-1)
	{	
	  if(undo_count>0 && group_select==0)
	  {
		undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		undo_count=0;
	  }
	  undo_redo_tag_vector.push_back(path_tag);
	  undo_redo_child_number_vector.push_back(changed_item_num);
	  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{	
	  if(group_select==1)
	  {
		std::string val1=undo_redo_tag_vector[undo_redo_tag_vector.size()-1];
		std::string val2="GroupPropertyStarts";
		const char* val3=val1.c_str();
		const char* val4=val2.c_str();
		if(strcmp(val3,val4)==0)
		{
		undo_redo_tag_vector.pop_back();
		undo_redo_child_number_vector.pop_back();
		undo_redo_delete_status_vector.pop_back();
		undo_redo_position_vector.pop_back();
		}
		group_select=0;
	  }
	}
  }
  }
}
//undo-redo-code-ends here
//undo-redo-code-ends here
  /*x,y reset*/	
}

void KalanjiyamWindow::create_xml_for_image()
{
  /*xml begins*/	
  Glib::ustring image_open_tag = "<Image";
  Glib::ustring image_close_tag = " Image </Image>";
  Glib::ustring image_xposition_tag = " xposition=\"";
  Glib::ustring image_yposition_tag = " yposition=\"";
  Glib::ustring image_height_tag = " height=\"";
  Glib::ustring image_width_tag = " width=\"";
  Glib::ustring image_data_tag = " data=\"";
  Glib::ustring image_data_tag2= " py_data=\"";
  Glib::ustring image_data_tag1 = " ImageData=\"";

  Glib::ustring image_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
  Glib::ustring image_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
  Glib::ustring image_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
  Glib::ustring image_width_tag_value = boost::lexical_cast<std::string>(open_global_width);
  Glib::ustring image_data_tag_value = open_global_data;
  Glib::ustring image_data_tag_value1 = open_global_image_data;
Glib::ustring image_data_tag_value2 = open_global_python_data;


  Glib::ustring image_tag;
  image_tag = image_open_tag + image_xposition_tag + image_xposition_value + "\"" + image_yposition_tag + image_yposition_value+ "\""  + image_height_tag + image_height_tag_value + "\"" + image_width_tag + image_width_tag_value + "\"" + image_data_tag  + image_data_tag_value + "\"" + image_data_tag2  + image_data_tag_value2 + "\"" + image_data_tag1+ image_data_tag_value1 + "\">" + image_close_tag;

  int undo_redo_delete_status;	
  int position;
  if(edit_flag==1)
  {
	if(action_status==1)
	  undo_redo_delete_status=5;
	else
	  undo_redo_delete_status=1;
	changed_item_num=vec_pos+1;
    open_global_fillcolor_hex = fillcolor ;
    int vec_coun = -1;
    Glib::ustring x_val;
    for (std::vector<std::string>::iterator xml_scene_overall_tag_it = xml_scene_overall_tag.begin(); xml_scene_overall_tag_it != xml_scene_overall_tag.end(); ++xml_scene_overall_tag_it)
    { 
      vec_coun= vec_coun+1;
      if(vec_coun==vec_pos)
      {
		for(int i=0; i<undo_redo_tag_vector.size(); i++)
		{
			if(undo_redo_tag_vector[i]==xml_scene_overall_tag[vec_pos])
			{
				position=i;
				break;	
			}
		}
        xml_scene_overall_tag.at(vec_coun) = image_tag;
      }
    }
    edit_flag=0;
  }
  else
  {
  undo_redo_delete_status=0;
  changed_item_num=changed_item_num;
  position=-1;
  xml_scene_overall_tag.push_back(image_tag);
  }

  /*x,y reset*/	
//
//
if(undo_status==0)
{
  if(copy_paste_status==1)
  {
	undo_redo_tag_vector.push_back(image_tag);
	undo_redo_child_number_vector.push_back(changed_item_num);
	undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	undo_redo_position_vector.push_back(position);
	standing_position=undo_redo_tag_vector.size()-1;
  }
  else
  {
  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.push_back(image_tag);
  undo_redo_child_number_vector.push_back(changed_item_num);
  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = image_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)
	{	
	  if(undo_count>0 && group_select==0)
	  {
		undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		undo_count=0;
	  }
	  undo_redo_tag_vector.push_back(image_tag);
	  undo_redo_child_number_vector.push_back(changed_item_num);
	  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{	
	  if(group_select==1)
	  {
		std::string val1=undo_redo_tag_vector[undo_redo_tag_vector.size()-1];
		std::string val2="GroupPropertyStarts";
		const char* val3=val1.c_str();
		const char* val4=val2.c_str();
		if(strcmp(val3,val4)==0)
		{
		undo_redo_tag_vector.pop_back();
		undo_redo_child_number_vector.pop_back();
		undo_redo_delete_status_vector.pop_back();
		undo_redo_position_vector.pop_back();
		}
		group_select=0;
	  }
	}
  }
  }
}
//
//
}

void KalanjiyamWindow::create_xml_for_text()
{
  /*xml begins*/
  Glib::ustring text_open_tag = "<Text";
  Glib::ustring text_close_tag = " Text </Text>";	
  Glib::ustring text_data_tag = " data=\"";
  Glib::ustring text_fill_color = " fillcolor=\"";
  Glib::ustring text_xposition_tag = " xposition=\"";
  Glib::ustring text_yposition_tag = " yposition=\"";	
  Glib::ustring text_font_tag = " font=\"";	

  Glib::ustring text_data_tag_value = open_global_data;
  Glib::ustring text_fill_color_value = open_global_fillcolor_hex;
  Glib::ustring text_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
  Glib::ustring text_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
  Glib::ustring text_font_tag_value = open_global_font;

  Glib::ustring text_tag;
  text_tag = text_open_tag + text_data_tag + text_data_tag_value + "\"" + text_xposition_tag + text_xposition_value+ "\"" + text_yposition_tag + text_yposition_value+ "\""  + text_fill_color + text_fill_color_value + "\"" + text_font_tag + text_font_tag_value + "\">" + text_close_tag;	

  int undo_redo_delete_status;
  int position;
  if(edit_flag==1)
  {
	if(action_status==1)
	  undo_redo_delete_status=5;
	else
	  undo_redo_delete_status=1;
	changed_item_num=vec_pos+1;
    int vec_coun = -1;
    Glib::ustring x_val;
    for (std::vector<std::string>::iterator xml_scene_overall_tag_it = xml_scene_overall_tag.begin(); xml_scene_overall_tag_it != xml_scene_overall_tag.end(); ++xml_scene_overall_tag_it)
    { 
      vec_coun= vec_coun+1;
      if((vec_coun==vec_pos))
      {
		for(int i=0; i<undo_redo_tag_vector.size(); i++)
		{
			if(undo_redo_tag_vector[i]==xml_scene_overall_tag[vec_pos])
			{
				position=i;
				break;	
			}
		}
        xml_scene_overall_tag.at(vec_coun) = text_tag;
      }
    }
    edit_flag=0;
  }
  else
  {
    if(text_edit_index_value==0)
    {
	undo_redo_delete_status=0;
	changed_item_num=changed_item_num;
	position=-1;
    xml_scene_overall_tag.push_back(text_tag);
    }
    else
    {
	if(action_status==1)
	  undo_redo_delete_status=5;
	else
	  undo_redo_delete_status=1;
	changed_item_num=vec_pos+1;
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
		if(undo_redo_tag_vector[i]==xml_scene_overall_tag[vec_pos])
		{
			position=i;
			break;	
		}
	}
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+vec_pos);
    text_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
    text_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
    text_tag = text_open_tag + text_data_tag + text_data_tag_value + "\"" + text_xposition_tag + text_xposition_value+ "\"" + text_yposition_tag + text_yposition_value+ "\""  + text_fill_color + text_fill_color_value + "\"" + text_font_tag + text_font_tag_value + "\">" + text_close_tag;	
    xml_scene_overall_tag.push_back(text_tag);
    root->remove_child(vec_pos+1);
    child_num=child_num-1;
    }
  }
  //to_png();
  /*x,y reset*/	
//
//
if(undo_status==0)
{
  if(copy_paste_status==1)
  {
	undo_redo_tag_vector.push_back(text_tag);
	undo_redo_child_number_vector.push_back(changed_item_num);
	undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	undo_redo_position_vector.push_back(position);
	standing_position=undo_redo_tag_vector.size()-1;
  }
  else
  {
  if(undo_redo_tag_vector.size()==0)
  {
  undo_redo_tag_vector.push_back(text_tag);
  undo_redo_child_number_vector.push_back(changed_item_num);
  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
  undo_redo_position_vector.push_back(position);
  standing_position=undo_redo_tag_vector.size()-1;
  }
  else if(undo_redo_tag_vector.size()>0)
  {
	int same_tag_status=0;
	const char* value1 = text_tag.c_str();
	for(int i=0; i<undo_redo_tag_vector.size(); i++)
	{
	std::string value2 = undo_redo_tag_vector[i];
	const char* value3 = value2.c_str();
	if (strcmp(value1,value3) == 0)
	same_tag_status=1;
	}
	if(same_tag_status==0)
	{	
	  if(undo_count>0 && group_select==0)
	  {
		undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
		undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
		undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
		undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
		undo_count=0;
	  }
	  undo_redo_tag_vector.push_back(text_tag);
	  undo_redo_child_number_vector.push_back(changed_item_num);
	  undo_redo_delete_status_vector.push_back(undo_redo_delete_status);
	  undo_redo_position_vector.push_back(position);
	  standing_position=undo_redo_tag_vector.size()-1;
	}
	else
	{	
	  if(group_select==1)
	  {
		std::string val1=undo_redo_tag_vector[undo_redo_tag_vector.size()-1];
		std::string val2="GroupPropertyStarts";
		const char* val3=val1.c_str();
		const char* val4=val2.c_str();
		if(strcmp(val3,val4)==0)
		{
		undo_redo_tag_vector.pop_back();
		undo_redo_child_number_vector.pop_back();
		undo_redo_delete_status_vector.pop_back();
		undo_redo_position_vector.pop_back();
		}
		group_select=0;
	  }
	}
  }
  }
}
//
//
}

Glib::ustring KalanjiyamWindow::create_xml_for_group()
{
  //To print the group item number for xml concepts //Code starts here
  Glib::ustring int_to_string_value;
  std::string total_numbers;
	Glib::ustring group_tag_concatenate = "";
  int child_in_total_list1;
  for(int i=0; i<group_child_total_list.size(); i++)
  {
    tokenizer<> tok(group_child_total_list[i]);
    tokenizer<>::iterator beg=tok.begin();
    if(*beg=="G")
    {
      int l=1;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(l!=1)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              int m=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(m!=1)
                {
                std::stringstream str(*beg);
                str>>child_in_total_list1;
                }
                m++;
              }
            }
          }
          if(l==2)
          {								
          int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1);
          total_numbers=int_to_string_value;
          }
          else
          {
          int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1);
          total_numbers=total_numbers+","+int_to_string_value;
          }
        }
        l++;
      }
      Glib::ustring group_xposition_tag = " xposition=\"";
      Glib::ustring group_yposition_tag = " yposition=\"";	
      Glib::ustring group_height_tag = " height=\"";
      Glib::ustring group_width_tag = " width=\"";

      Glib::ustring group_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
      Glib::ustring group_width_tag_value = boost::lexical_cast<std::string>(open_global_width);
      Glib::ustring group_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
      Glib::ustring group_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
      if(i==0)
      {
        group_tag_concatenate = "<Group data=\"" + total_numbers + "\"" + group_xposition_tag + group_xposition_value + "\"" + group_yposition_tag + group_yposition_value+ "\""  + group_height_tag + group_height_tag_value + "\"" + group_width_tag + group_width_tag_value + "\">" + " Group </Group>";  //add x,y position tags
      }
      else
      {
      group_tag_concatenate = group_tag_concatenate + "<Group data=\"" + total_numbers + "\"" + group_xposition_tag + group_xposition_value + "\"" + group_yposition_tag + group_yposition_value+ "\""  + group_height_tag + group_height_tag_value + "\"" + group_width_tag + group_width_tag_value + "\">" + " Group </Group>";  //add x,y position tags      
      }
    }
  }
  /*x,y reset*/	
  return group_tag_concatenate;
}

void KalanjiyamWindow::find_current_node_to_get_attribute_value(const char* open_node_name)
{
  const char * node_name = open_node_name;
  const char * attribute_name = open_attr_name;
  const char * attribute_value = open_attr_value;

  if (strcmp(node_name, "Rectangle") == 0)
  {
    if (strcmp(attribute_name, "x") == 0) 
    {
    open_global_x = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "y") == 0) 
    {
    open_global_y = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "width") == 0) 
    {
    open_global_width = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "height") == 0) 
    {
    open_global_height = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "xradius") == 0) 
    {
    open_global_xradius = atoi(attribute_value);
    }
    else if (strcmp(attribute_name, "yradius") == 0) 
    {
    open_global_yradius = atoi(attribute_value);
    }
    else if (strcmp(attribute_name, "strokecolor") == 0) 
    {
    open_global_strokecolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "fillcolor") == 0) 
    {
    open_global_fillcolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "linewidth") == 0) 
    {
    open_global_linewidth = atoi(attribute_value);
    }
    else if (strcmp(attribute_name, "xposition") == 0) 
    {
    open_global_xposition = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "yposition") == 0) 
    {
    open_global_yposition = atof(attribute_value);
    }			
  }
  else if (strcmp(node_name, "Ellipse") == 0)
  {
    if (strcmp(attribute_name, "centerx") == 0) 
    {
    open_global_centerx = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "centery") == 0) 
    {
    open_global_centery = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "yradius") == 0) 
    {
    open_global_yradius = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "xradius") == 0) 
    {
    open_global_xradius = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "strokecolor") == 0) 
    {
    open_global_strokecolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "fillcolor") == 0) 
    {
    open_global_fillcolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "linewidth") == 0) 
    {
    open_global_linewidth = atoi(attribute_value);
    }
    else if (strcmp(attribute_name, "xposition") == 0) 
    {
    open_global_xposition = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "yposition") == 0) 
    {
    open_global_yposition = atof(attribute_value);
    }					
  }
  else if (strcmp(node_name, "Line") == 0)
  {
    if (strcmp(attribute_name, "x1") == 0) 
    {
    open_global_x1 = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "y1") == 0) 
    {
    open_global_y1 = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "x2") == 0) 
    {
    open_global_x2 = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "y2") == 0) 
    {
    open_global_y2 = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "strokecolor") == 0) 
    {
    open_global_strokecolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "linewidth") == 0) 
    {
    open_global_linewidth = atoi(attribute_value);
    }
    else if (strcmp(attribute_name, "height") == 0) 
    {
    open_global_height = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "width") == 0) //If curve means no fill color. But star, arrow means fill color will come ->Do check here
    {
    open_global_width = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "xposition") == 0) 
    {
    open_global_xposition = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "yposition") == 0) 
    {
    open_global_yposition = atof(attribute_value);
    }	
  }
  else if (strcmp(node_name, "Path") == 0)
  {
    if (strcmp(attribute_name, "data") == 0) 
    {
    open_global_data = attribute_value;
    }
	if (strcmp(attribute_name, "py_data") == 0) 
    {
    open_global_python_data = attribute_value;
    }
    else if (strcmp(attribute_name, "strokecolor") == 0) 
    {
    open_global_strokecolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "fillcolor") == 0) //If curve means no fill color. But star, arrow means fill color will come ->Do check here
    {
    open_global_fillcolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "linewidth") == 0) 
    {
    open_global_linewidth = atoi(attribute_value);
    }
    else if (strcmp(attribute_name, "height") == 0) 
    {
    open_global_height = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "width") == 0) 
    {
    open_global_width = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "xposition") == 0) 
    {
    open_global_xposition = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "yposition") == 0) 
    {
    open_global_yposition = atof(attribute_value);
    }	
  }
  else if (strcmp(node_name, "Image") == 0)
  {
    if (strcmp(attribute_name, "data") == 0) 
    {
    open_global_data = attribute_value;
    }
	else if (strcmp(attribute_name, "py_data") == 0) 
    {
    open_global_python_data = attribute_value;//rrkk
    }
	else if (strcmp(attribute_name, "ImageData") == 0) 
    {
    open_global_image_data = attribute_value;
    }
    else if (strcmp(attribute_name, "height") == 0) 
    {
    open_global_height = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "width") == 0) //If curve means no fill color. But star, arrow means fill color will come ->Do check here
    {
    open_global_width = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "xposition") == 0) 
    {
    open_global_xposition = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "yposition") == 0) 
    {
    open_global_yposition = atof(attribute_value);
    }
  }
  else if (strcmp(node_name, "Text") == 0)
  {
    if (strcmp(attribute_name, "data") == 0) 
    {
    open_global_data = attribute_value;
    }
    else if (strcmp(attribute_name, "xposition") == 0) 
    {
    open_global_xposition = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "yposition") == 0) 
    {
    open_global_yposition = atof(attribute_value);
    }
    else if (strcmp(attribute_name, "fillcolor") == 0)
    {
    open_global_fillcolor_hex = attribute_value;
    }
    else if (strcmp(attribute_name, "font") == 0)
    {
    open_global_font = attribute_value;
    }
  }
  else if (strcmp(node_name, "Group") == 0)
  {   
    if (strcmp(attribute_name, "data") == 0) 
    {
      Glib::ustring int_to_string_value;
      std::string vector_child_value;
      std::string vector_group_value;
      stringstream char_input;
      string string_output;

      char_input<<attribute_value;
      char_input>>string_output;

      tokenizer<> tok(string_output);
      int l=0;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        l++;
        int child_number;
        std::stringstream str(*beg);
        str>>child_number;
        int_to_string_value = boost::lexical_cast<std::string>(child_number);
        vector_child_value="S,"+int_to_string_value;

        group_child_no.push_back(child_number);		//To push the child_number value for temporary buffer
        if(group_child_total_list.size()==0)
        group_child_total_list.push_back("Group Vector");

        //To check whether the child_value is already in group_child_total_list_vector or not ?	//Code starts here
        int group_child_total_list_same_no=0;
        for(int i=0; i<group_child_total_list.size(); i++)	//Selected item childs compare with grouped child items
        {
          tokenizer<> tok(group_child_total_list[i]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list==child_number)
              {
              group_child_total_list_same_no=1;
              break;
              }	
            }
          }
        }
        //To check whether the child_value is already in group_child_total_list_vector or not ?	//Code ends here
        if(group_child_total_list_same_no==0)
        group_child_total_list.push_back(vector_child_value);
      }
      //To store the group vector numbers	//Code starts here
      for(int i=0; i<group_child_no.size(); i++)	//Selected item childs in buffer
      {
        int group_child_total_list_same_no=-1;
        for(int j=0; j<group_child_total_list.size(); j++)	//Selected item childs compare with grouped child items
        {
          tokenizer<> tok(group_child_total_list[j]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="S")
          {
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list==group_child_no[i])
              {
              group_child_total_list_same_no=j;
              break;
              }	
            }
          }
        }
        if(group_child_total_list_same_no!=-1)	//If same, it will be a total group
        {
          int_to_string_value = boost::lexical_cast<std::string>(group_child_total_list_same_no);
          if(i==0)
          vector_group_value="G,"+int_to_string_value;					
          else
          vector_group_value=vector_group_value+","+int_to_string_value;
        }
      }
      group_child_total_list.push_back(vector_group_value);
      //To store the group vector numbers //Code ends here
      group_child_no.erase(group_child_no.begin(),group_child_no.end());	//To empty the group_child_no vector
    }	
  }
}

void KalanjiyamWindow::call_function_according_to_node_name(const char* open_node_name)
{
  if (strcmp(open_node_name, "Rectangle") == 0)
  {
    open_create_rectangle();
    create_xml_for_rectangle();
  }
  else if (strcmp(open_node_name, "Ellipse") == 0)
  {
    open_create_ellipse();
    create_xml_for_ellipse();
  }
  else if (strcmp(open_node_name, "Line") == 0)
  {
    open_create_line();
    create_xml_for_line();
  }
  else if (strcmp(open_node_name, "Path") == 0)
  {
    open_create_path();
    Glib::ustring node_value = open_node_value;
    Glib::ustring node_value1 = "" + node_value + "";
    create_xml_for_path(node_value1);
  }	
  else if (strcmp(open_node_name, "Image") == 0)
  {
    open_create_image();
    create_xml_for_image();
  }
  else if (strcmp(open_node_name, "Text") == 0)
  {
    open_create_text();
    create_xml_for_text();
  }
  else if (strcmp(open_node_name, "Group") == 0)
  {
    open_create_group();
    create_xml_for_group();
  }
}

void KalanjiyamWindow::get_property(const Glib::RefPtr<Goocanvas::Item>& item,int item_pos)
{
try
{
 gfloat r1,g1,b1,a1;
 gfloat r2,g2,b2,a2;
 glong it_fil,it_storke;
 open_node_name_curve=0;
 global_x_diff=0;
 global_x_diff=0;

 Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();

 item->get_property(Glib::ustring("width"),open_global_width = 0);
 item->get_property(Glib::ustring("height"),open_global_height =0);
 item->get_property(Glib::ustring("x"),open_global_xposition =0);
 item->get_property(Glib::ustring("y"),open_global_yposition= 0);
 item->get_property(Glib::ustring("line_width"),open_global_linewidth = 0);
// item->get_property(Glib::ustring("center_x"),open_global_centerx=0 );
// item->get_property(Glib::ustring("center_y"),open_global_centery=0 );
// item->get_property(Glib::ustring("radius_x"),open_global_xradius=0 );
// item->get_property(Glib::ustring("radius_y"),open_global_yradius=0 );
 item->get_property(Glib::ustring("fill_color_rgba"),it_fil=0);
 item->get_property(Glib::ustring("stroke_color_rgba"),it_storke=0 );
 item->get_property(Glib::ustring("font"),open_global_font="" );


 a1 = it_fil >> 24 & 255; // 255
 r1 = it_fil >> 16 & 255; // 255
 g1 = it_fil >> 8 & 255; // 122
 b1 = it_fil >> 0 & 255; // 15, wrote this a bit different than above just for example
 a2 = it_storke >> 24 & 255; // 255
 r2 = it_storke >> 16 & 255; // 255
 g2 = it_storke >> 8 & 255; // 122
 b2 = it_storke >> 0 & 255; // 15, wrote this a bit different than above just for example
 fillcolor = open_global_fillcolor_hex;
 strokecolor = open_global_strokecolor_hex;
 open_global_fillcolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) a1,(gint) r1,(gint) g1);
 open_global_strokecolor_hex = g_strdup_printf("#%02x%02x%02x",(gint) a2,(gint) r2,(gint) g2);		
 col_flag=1;
 my_item = item;
 int ijk = item_pos-1;
 int f=-1;
 string my_str1;



 for (std::vector<std::string>::iterator xml_scene_overall_tag_it = xml_scene_overall_tag.begin(); xml_scene_overall_tag_it != xml_scene_overall_tag.end(); xml_scene_overall_tag_it++)
 {
   f=f+1;
   if(ijk==f)
   {
   my_str1=  *xml_scene_overall_tag_it;
   vec_pos=f;		
   }
 }	

 vector<char> xml_copy(my_str1.begin(), my_str1.end());
 xml_copy.push_back('\0');
 xml_document<> doc;
 doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
 xml_node<>* Kalanjiyam = doc.first_node();
 xml_node<> * abc;
 for(abc = Kalanjiyam ; abc; abc = abc->next_sibling())
 {
   for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
   {
     const char * node_name = abc->name();
     const char * node_value = abc->value();		
     open_node_name = node_name;
     open_node_value = node_value;
     const char * attribute_name = attribute->name();	
     const char * attribute_value = attribute->value();	
     open_attr_name = attribute_name;
     open_attr_value = attribute_value;

  Glib::ustring line_x1_tag = " x1=\"";
  Glib::ustring line_y1_tag = " y1=\"";
  Glib::ustring line_x2_tag = " x2=\"";
  Glib::ustring line_y2_tag = " y2=\"";


     if (strcmp(open_attr_name, "x") == 0) 
     {
     open_global_x = atof(open_attr_value);
     }

     if (strcmp(open_attr_name, "x1") == 0) 
     {
     open_global_x1 = atof(open_attr_value);
     }
     if (strcmp(open_attr_name, "y1") == 0) 
     {
     open_global_y1 = atof(open_attr_value);
     }
     if (strcmp(open_attr_name, "x2") == 0) 
     {
     open_global_x2 = atof(open_attr_value);
     }
     if (strcmp(open_attr_name, "y2") == 0) 
     {
     open_global_y2 = atof(open_attr_value);
     }
     if (strcmp(open_attr_name, "y") == 0) 
     {
     open_global_y = atof(open_attr_value);
     }
     if (strcmp(open_attr_name, "data") == 0 && image_status==0)
     {
     	open_global_data = open_attr_value;
		
     }
     if (strcmp(open_attr_name, "ImageData") == 0 ) 
     {
     	open_global_image_data = open_attr_value;		
     }
	 if (strcmp(open_attr_name, "py_data") == 0 && image_status==0) 
     {
     	open_global_python_data = open_attr_value;
     }

     /*Create drawings in working area begins*/
   }

   if (strcmp(open_node_name, "Rectangle") == 0)
   {
     fillcolor = open_global_fillcolor_hex;
     pBorderWidth->show();
     pEraserWidth->hide();
     pFont->hide();
     pStrokeColor->show();
     pFillColor->show();	
     pBorderXradius->show();	
     pBorderYradius->show();
     pShape->hide();

	 if(eraser_grouped_child_no.size()==0)
		{
	     pSpinBorderXRadius->set_value(open_global_xradius);
	     pSpinBorderYRadius->set_value(open_global_yradius);
	     pSpinBorderWidth->set_value(open_global_linewidth);
		}

     edit_flag=1;
     darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
     darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
    // create_xml_for_rectangle();
//	if(eraser_status==1)
	//{

		 int m=open_global_xposition;
		 int m1=open_global_yposition;
		 int l=open_global_xposition + open_global_width;
		 int l1=open_global_yposition +open_global_height; 
		 string value_of_m,value_of_m1,value_of_l,value_of_l1;
		 value_of_m=boost::lexical_cast<std::string>(m);
		 value_of_m1=boost::lexical_cast<std::string>(m1);
		 value_of_l=boost::lexical_cast<std::string>(l);
		 value_of_l1=boost::lexical_cast<std::string>(l1);
		string open_global_data1;
		open_global_data1="M "+value_of_m+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_m1+" "+"L "+value_of_l+" "+value_of_l1+" "+"L "+value_of_m+" "+value_of_l1+" "+"z";
		 my_str1_tag = open_global_data1;
		 erased_value = " Star1 ";
		string strvalue3;

		stringstream stream(open_global_data1);
		open_global_data = open_global_data1;
		edit_flag=1;
		open_node_value = erased_value.c_str();
		open_create_path();

if(eraser_grouped_child_no.size()==0)
		{
		double xx,yy,ww,hh;

		xx = open_global_xposition;
		yy = open_global_yposition;
		ww = open_global_width;
		hh = open_global_height;

		Glib::RefPtr<Goocanvas::Rect> rect2 ;
		rect2 = Goocanvas::Rect::create(xx,yy,ww,hh); 
		#ifdef GLIBMM_PROPERTIES_ENABLED
		rect2->property_stroke_color() = "red" ;
		rect2->property_line_width() = 0.5 ;
		#endif
		root->add_child(rect2);
		child_num=child_num+1;

		first(xx-16,yy-16,xx,yy);
		second(xx+ww+16,yy-16,xx+ww,yy);
		third(xx-16,yy+hh+16,xx,yy+hh);
		fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
		fifth(xx+ww/2,yy-22,xx+ww/2,yy);
		sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
		seventh(xx-22,yy+hh/2,xx,yy+hh/2);
		eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);
		}

	 if((eraser_grouped_child_no.size()!=0) && ((global_y_diff!=0)||(global_x_diff!=0)))
		{

		double xx1,yy1,ww1,hh1;

		xx1 = grp_xx;
		yy1 = grp_yy;
		ww1 = grp_ww;
		hh1 = grp_hh;

		Glib::RefPtr<Goocanvas::Rect> rect1 ;
		rect1 = Goocanvas::Rect::create(xx1,yy1,ww1,hh1); 
		#ifdef GLIBMM_PROPERTIES_ENABLED
		rect1->property_stroke_color() = "red" ;
		rect1->property_line_width() = 0.5 ;
		#endif
		root->add_child(rect1);
		child_num=child_num+1;
		first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
		second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
		third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
		fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
		fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
		sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
		seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
		eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);


	  		}
		move_var=1;	

		create_xml_for_path(erased_value);

 	// }
   }
   else if (strcmp(open_node_name, "Ellipse") == 0)
   {

     fillcolor = open_global_fillcolor_hex;
     pBorderWidth->show();
     pFont->hide();
     pStrokeColor->show();
     pFillColor->show();	
     pBorderXradius->hide();
     pBorderYradius->hide();
     pShape->hide();
     pEraserWidth->hide();

	 if(eraser_grouped_child_no.size()==0)
	     pSpinBorderWidth->set_value(open_global_linewidth);
     
     edit_flag=1;
     darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
     darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
     create_xml_for_ellipse();
//	if(eraser_status==1)
	//{
	 string open_global_centerx1= boost::lexical_cast<std::string>(open_global_centerx);
	string open_global_centery1= boost::lexical_cast<std::string>(open_global_centery);
	string open_global_xposition1= boost::lexical_cast<std::string>(open_global_xradius);
	string open_global_yposition1= boost::lexical_cast<std::string>(open_global_yradius);
string my_str1_tag_modified3="[("+ open_global_centerx1 + ", "+ open_global_centery1 + ", " + open_global_xposition1 + ", " + open_global_yposition1 + ", " + "180)" + ", " + "(305, 153, 5, 1.5, -30)]";

	const char *c = my_str1_tag_modified3.c_str();


	PyObject *main = PyImport_AddModule("__main__"); // borrowed
	PyObject *globals = PyModule_GetDict(main); // borrowed


	PyObject *value = PyString_FromString(c);

	PyDict_SetItemString(globals, "n", value);
	   //error();

	Py_DECREF(value);

		PyRun_SimpleString("import ast\n"
	"import numpy as np\n"
	"from shapely.geometry.polygon import LinearRing , Polygon\n"
	"def ellipse_polyline(ellipses, n=100):\n"
	"	t = np.linspace(0, 2*np.pi, n, endpoint=False)\n"
	"	st = np.sin(t)\n"
	"	ct = np.cos(t)\n"
	"	result = []\n"
	"	for x0, y0, a, b, angle in ellipses:\n"
	"		angle = np.deg2rad(angle)\n"
	"		sa = np.sin(angle)\n"
	"		ca = np.cos(angle)\n"
	"		p = np.empty((n, 2))\n"
	"		p[:, 0] = x0 + a * ca * ct - b * sa * st\n"
	"		p[:, 1] = y0 + a * sa * ct + b * ca * st\n"
	"		result.append(p)\n"
	"	return result\n"
	"a1= ast.literal_eval(n)\n"
	"ellipses = a1\n"
	"a, b = ellipse_polyline(ellipses)\n"
	"a = Polygon(a)\n"
	"erase = a\n"
	"eraser=str(erase)\n"
	"f=open('file.txt','w')\n"
	"f.write(eraser)\n"
	"f=open('file.txt','r')\n"
	"text=f.read()\n");


	PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
	PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
	PyObject * eraser = PyDict_GetItemString(dictionary, "text");
	string erase_value = PyString_AsString(eraser);


	string first_value = erase_value;
	boost::replace_all(first_value, "POLYGON ((", "M ");
	boost::replace_all(first_value, ",", " L");
	boost::replace_all(first_value, "))", " Z");


	
	erased_value = " Star1 ";
	edit_flag=1;
	open_global_data = first_value;
	open_node_value = erased_value.c_str();
	open_create_path();
	create_xml_for_path(erased_value);

	//}*/
   }
 
   else if (strcmp(open_node_name, "Image") == 0)
   {

			edit_flag=1;
			image_edit_status=1;
			if(eraser_status==1 )
			 {
			 my_str1_tag = open_global_data;

			  for(int g=0;g<for_image_indentification.size();g++)
			   {
				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;

				  tokenizer<> tok(get_image_number);

				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	
					 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);	

				   if(current_clicked_item==child_number_for_image_int)
						{
							  number_for_image = image_int;
						}		
				}
			  Glib::ustring int_to_string_value;
			  int_to_string_value = boost::lexical_cast<std::string>(number_for_image);
			  Glib::ustring img_file_name = "/tmp/Kalanjiyam/Images/"+int_to_string_value+".png";
			}	
				
		create_xml_for_image();
   }
   else if (strcmp(open_node_name, "Text") == 0)
   {
	open_node_name_curve=1;
     pSbar->push("Text tool clicked...");
     pNotebook->get_nth_page(3)->show();
     pNotebook->set_current_page(3);
     pBorderWidth->hide();
     pFont->show();
     pStrokeColor->hide();
     pFillColor->show();	
     pBorderXradius->hide();
     pBorderYradius->hide();
     pShape->hide();
     pEraserWidth->hide();
	 if(eraser_grouped_child_no.size()==0)
	     pSpinBorderWidth->set_value(open_global_linewidth);
     darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
     darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
     edit_flag=1;
     create_xml_for_text();
   }
  else if (strcmp(open_node_name, "Path") == 0)
   {
     edit_flag=1;
     Glib::ustring path_val;
     path_val = open_node_value;
     path_val=""+path_val+"";
	std::vector<std::string>split_x_y;  
   
	 if(path_val==" Star ")
     {
       fillcolor = open_global_fillcolor_hex;
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->show();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->show();
       pEraserWidth->hide();
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
       darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
	   if(eraser_grouped_child_no.size()==0)
      	 pSpinBorderWidth->set_value(open_global_linewidth);
       edit_flag = 1;      
	   erased_value = " Star ";
     }
     else if(path_val==" Star1 ")
     {
       fillcolor = open_global_fillcolor_hex;
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->show();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->show();
	   pEraserWidth->hide();
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
       darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
	   if(eraser_grouped_child_no.size()==0)
	       pSpinBorderWidth->set_value(open_global_linewidth);
       fillcolor = open_global_fillcolor_hex;
       edit_flag = 1;        
	   erased_value = " Star1 ";
     }
     else if(path_val==" Triangle ")
     {
       fillcolor = open_global_fillcolor_hex;
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->show();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->show();
       pEraserWidth->hide();
	   if(eraser_grouped_child_no.size()==0)
	       pSpinBorderWidth->set_value(open_global_linewidth);
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
       darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
       edit_flag = 1;
 	   erased_value = " Triangle ";
     }
     else if(path_val==" Arrow ")
     {
       fillcolor = open_global_fillcolor_hex;
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->show();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->show();
       pEraserWidth->hide();
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
       darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
	   if(eraser_grouped_child_no.size()==0)
	       pSpinBorderWidth->set_value(open_global_linewidth);
       edit_flag = 1;
       erased_value = " Arrow ";
     }
     else if(path_val==" Polyline ")
     {
	if(eraser_status==1)
	  	 open_node_name_line="Line";
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->hide();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->hide();
       pEraserWidth->hide();
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
	   if(eraser_grouped_child_no.size()==0)
	       pSpinBorderWidth->set_value(open_global_linewidth);
       open_global_fillcolor_hex = fillcolor ;
       edit_flag = 1;
       erased_value = " Polyline ";
		my_str1_tag = open_global_data;
		string strvalue1;
		string strvalue2;
		stringstream stream(my_str1_tag);
		while( getline(stream, strvalue1, ' ') )
			split_x_y.push_back(strvalue1);

		if(split_x_y.size()<=6)
			{	
			 float m= boost::lexical_cast<float>(split_x_y[1]);
			 float m1=boost::lexical_cast<float>(split_x_y[2]);
			 float l= boost::lexical_cast<float>(split_x_y[4]);
			 float l1= boost::lexical_cast<float>(split_x_y[5]); 
			 float mid_1 = boost::lexical_cast<float>((m + l) /2);
			 float mid_2 = boost::lexical_cast<float>((m1 + l1) /2);

			 string value_of_m,value_of_m1,value_of_l,value_of_l1,value_of_mid1,value_of_mid2;
			 value_of_m=boost::lexical_cast<std::string>(m);
			 value_of_m1=boost::lexical_cast<std::string>(m1);
			 value_of_l=boost::lexical_cast<std::string>(l);
			 value_of_l1=boost::lexical_cast<std::string>(l1);
			 value_of_mid1=boost::lexical_cast<std::string>(mid_1);
			 value_of_mid2=boost::lexical_cast<std::string>(mid_2);

			 string open_global_data1;
			 open_global_data1="M "+value_of_m+" "+value_of_m1+" "+"L "+value_of_mid1+" "+value_of_mid2+" "+"L "+value_of_l+" "+value_of_l1+" "	+"z";
			 my_str1_tag = open_global_data1;
			}
     }
     else if(path_val==" Curve ")
     {
	   open_node_name_curve=1;
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->hide();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->hide();
     pEraserWidth->hide();
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
	   if(eraser_grouped_child_no.size()==0)
	       pSpinBorderWidth->set_value(open_global_linewidth);
       open_global_fillcolor_hex = fillcolor ;
       edit_flag = 1;
       create_xml_for_path(path_val);
	   erased_value = " Curve ";
	   my_str1_tag = "";
	   my_str1_tag = open_global_data;

		string strvalue1;
		string strvalue2;
		stringstream stream(my_str1_tag);
		while( getline(stream, strvalue1, ' ') )
			split_x_y.push_back(strvalue1);

		if(split_x_y.size()<=9)
			{	
			 float m= boost::lexical_cast<float>(split_x_y[1]);
			 float m1=boost::lexical_cast<float>(split_x_y[2]);
			 float l= boost::lexical_cast<float>(split_x_y[7]);
			 float l1= boost::lexical_cast<float>(split_x_y[8]); 
			 float mid_1 = boost::lexical_cast<float>((m + l) /2);
			 float mid_2 = boost::lexical_cast<float>((m1 + l1) /2);

			 string value_of_m,value_of_m1,value_of_l,value_of_l1,value_of_mid1,value_of_mid2;
			 value_of_m=boost::lexical_cast<std::string>(m);
			 value_of_m1=boost::lexical_cast<std::string>(m1);
			 value_of_l=boost::lexical_cast<std::string>(l);
			 value_of_l1=boost::lexical_cast<std::string>(l1);
			 value_of_mid1=boost::lexical_cast<std::string>(mid_1);
			 value_of_mid2=boost::lexical_cast<std::string>(mid_2);

			 string open_global_data1;
			 open_global_data1="M "+value_of_m+" "+value_of_m1+" "+"L "+value_of_mid1+" "+value_of_mid2+" "+"L "+value_of_l+" "+value_of_l1+" "	+"z";
			 my_str1_tag = open_global_data1;
			}
     }
     else if(path_val==" Brush ")
     {
	if(eraser_status==1)
	   open_node_name_line="Line";
       open_global_fillcolor_hex = fillcolor ;
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->hide();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->hide();
       pEraserWidth->hide();
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
	   if(eraser_grouped_child_no.size()==0)
	       pSpinBorderWidth->set_value(open_global_linewidth);
       edit_flag=1;
	   erased_value = " Brush ";
     }
     else if(path_val==" Line ")
     {
	if(eraser_status==1)
	   open_node_name_line="Line";
       open_global_fillcolor_hex = fillcolor ;
       pBorderWidth->show();
       pFont->hide();
       pStrokeColor->show();
       pFillColor->hide();	
       pBorderXradius->hide();
       pBorderYradius->hide();
       pShape->hide();
     pEraserWidth->hide();
       darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
	   if(eraser_grouped_child_no.size()==0)
	       pSpinBorderWidth->set_value(open_global_linewidth);
       edit_flag=1;
	   erased_value = " Line ";
     }


	string strvalue1;
	stringstream stream(my_str1_tag);

	while( getline(stream, strvalue1, ' ') )
		{
		 if(strvalue1=="a")	
			{
				open_node_name_ellipse="Ellipse";
			}
		}

		if(open_node_name_ellipse=="Ellipse")
		my_str1_tag = open_global_data;

		if(open_node_name_ellipse=="")
		{
		if(eraser_status==0 && come_from_line_change==0)
		{//rrkkk

		std::vector<std::string>split_x_y;  
		std::vector<std::string>combined_x_y; 


		my_str1_tag = "";

		my_str1_tag = open_global_data;

		std::string delimiter = ",";
		std::string storestring="";
		std::string the_value = press_x_y ;
		std::string dis_x;
		 std::string dis_y;
		size_t pos = 0;
			std::string token;

			while ((pos =  the_value.find(delimiter)) != std::string::npos) {
				token =  the_value .substr(0, pos);
				the_value .erase(0, pos + delimiter.length());
			}


		dis_x=token;
		dis_y=the_value;
		global_x_diff = boost::lexical_cast<float>(dis_x);
		global_y_diff = boost::lexical_cast<float>(dis_y);

		string strvalue1;
		string strvalue2;
		stringstream stream(my_str1_tag);
		while( getline(stream, strvalue1, ' ') )
		 split_x_y.push_back(strvalue1);



		string dis_x_str;
		string dis_y_str;

		float dis_x_int;
		float dis_y_int;
		int a_size=split_x_y.size();



		if((global_y_diff!=0)||(global_x_diff!=0))
		{
			for (int g=0; g<split_x_y.size(); g++)
			{
			  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
				{
				combined_x_y.push_back("Z");
				break;
				//g = g++;
				}
			  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
				{
				combined_x_y.push_back(split_x_y[g]);
				g=g++;
				}
	
			if(split_x_y[g]=="M" || split_x_y[g]== "L")
			   {
					if(split_x_y[g]=="M")
					{
					combined_x_y.push_back(split_x_y[g]);
					g = g++;
					}
				   else	if(split_x_y[g]=="L")
					{
					combined_x_y.push_back(split_x_y[g]);
					g = g++;
					}
					dis_x_str =split_x_y[g];
				 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
					dis_x_int = dis_x_int + global_x_diff;
					dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
					combined_x_y.push_back(dis_x_str);


					g = g++;
					dis_y_str =split_x_y[g];
					dis_y_int =boost::lexical_cast<float>(dis_y_str);
					dis_y_int= dis_y_int + global_y_diff;
					dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
					combined_x_y.push_back(dis_y_str);			
				}   


			if(split_x_y[g]=="C")
			   {
			
					combined_x_y.push_back(split_x_y[g]);
					g = g++;


					dis_x_str =split_x_y[g];
				 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
					dis_x_int = dis_x_int + global_x_diff;
					dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
					combined_x_y.push_back(dis_x_str);


					g = g++;
					dis_y_str =split_x_y[g];
					dis_y_int =boost::lexical_cast<float>(dis_y_str);
					dis_y_int= dis_y_int + global_y_diff;
					dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
					combined_x_y.push_back(dis_y_str);			

					g = g++;
					dis_x_str =split_x_y[g];
				 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
					dis_x_int = dis_x_int + global_x_diff;
					dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
					combined_x_y.push_back(dis_x_str);


					g = g++;
					dis_y_str =split_x_y[g];
					dis_y_int =boost::lexical_cast<float>(dis_y_str);
					dis_y_int= dis_y_int + global_y_diff;
					dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
					combined_x_y.push_back(dis_y_str);		
			
					g = g++;
					dis_x_str =split_x_y[g];
				 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
					dis_x_int = dis_x_int + global_x_diff;
					dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
					combined_x_y.push_back(dis_x_str);


					g = g++;
					dis_y_str =split_x_y[g];
					dis_y_int =boost::lexical_cast<float>(dis_y_str);
					dis_y_int= dis_y_int + global_y_diff;
					dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
					combined_x_y.push_back(dis_y_str);			
				}



			}
			my_str1_tag="";
			for (int g=0; g<combined_x_y.size(); g++)
			{
			 if(i==0)
				 my_str1_tag = combined_x_y[g] ;
			else
				 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
			}
			 my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
			//come_from_line_change1 = 1;
			open_global_data =  my_str1_tag;


			string open_global_python_data_for_check = open_global_python_data.substr(0,6);
			if((global_y_diff!=0)||(global_x_diff!=0))
			{
			if(open_global_python_data_for_check=="MULTIP")
			{
			string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

			string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

			Glib::locale_from_utf8(open_global_python_data);
			Glib::locale_from_utf8(dis_x_str_str);
			Glib::locale_from_utf8(dis_y_str_str);

			const char *open_global_python_data1 = open_global_python_data.c_str();
			const char *dis_x_str1 = dis_x_str_str.c_str();
			const char *dis_y_str1 = dis_y_str_str.c_str();


				PyObject *main = PyImport_AddModule("__main__"); // borrowed
				/*if (main == NULL)
					//error();
				return 0;*/
				PyObject *globals = PyModule_GetDict(main); // borrowed
				PyObject *py_data = PyString_FromString(open_global_python_data1);
				/*if (py_data == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata", py_data) ;
				//return 0;
				   //error();
				Py_DECREF(py_data);

				PyObject *py_data1 = PyString_FromString(dis_x_str1);
				/*if (py_data1 == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata1", py_data1);
				//return 0;*/
				   //error();
				Py_DECREF(py_data1);


				PyObject *py_data2 = PyString_FromString(dis_y_str1);
				/*if (py_data2 == NULL)
				return 0;
				   //error();*/
				PyDict_SetItemString(globals, "pythondata2", py_data2);
				//return 0;
				   //error();
				Py_DECREF(py_data2);


					PyRun_SimpleString("import ast\n"
				"from shapely.geometry import Polygon, MultiPolygon\n"
				"from shapely.geometry import *\n"
				"from shapely.ops import cascaded_union\n"
				"Multipo = pythondata\n"
				"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
				"Multipo = Multipo.replace(')))','))')\n"
				"Multipo = Multipo.replace(', ((','split[(')\n"
				"Multipo = Multipo.replace('))',')]')\n"
				"Multipo = Multipo.replace('), (',')],[(')\n"
				"Multipo = Multipo.replace(', ','),(')\n"
				"Multipo = Multipo.replace(' ',',')\n"
				"Multipo = Multipo.split('split')\n"
				"s = []\n"
				"for i in Multipo:\n"
				"	a = i.split('],[')\n"
				"	if len(a) >=2:\n"
				"		i = i.replace('],[','],[[',1)\n"
				"		i = '[' + i + ']]'\n"
				"		i = ast.literal_eval(i)\n"
				"		m = []\n"
				"		n = []\n"
				"		o = []\n"
				"		for j in i[0]:\n"
				"			k = j[0]+float(pythondata1)\n"
				"			l = j[1]+float(pythondata2)\n"
				"			m.append((k,l))\n"
				"		for a in i[1]:\n"
				"			for b in a:\n"
				"				k = b[0]+float(pythondata1)\n"
				"				l = b[1]+float(pythondata2)\n"
				"				o.append((k,l))\n"
				"			n.append(o)\n"
				"		s.append(Polygon(m,n).buffer(0))\n"
				"	else:\n"
				"		i = ast.literal_eval(i)\n"
				"		m = []\n"
				"		for j in i:\n"
				"			k = j[0]+float(pythondata1)\n"
				"			l = j[1]+float(pythondata2)\n"
				"			m.append((k,l))\n"
				"		s.append(Polygon(m).buffer(0))\n"
				"C = cascaded_union(s)\n"
				"C1 = str(C)\n");

	
			PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
			PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
			PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
			string changed_val = PyString_AsString(eraserera);

			open_global_python_data = changed_val;
			}

			}
				edit_flag=1;
				open_node_value = path_val.c_str();
				open_create_path();

		if(eraser_grouped_child_no.size()==0)
		{
		double xx,yy,ww,hh;

		xx = open_global_xposition;
		yy = open_global_yposition;
		ww = open_global_width;
		hh = open_global_height;

		Glib::RefPtr<Goocanvas::Rect> rect2 ;
		rect2 = Goocanvas::Rect::create(xx,yy,ww,hh); 
		#ifdef GLIBMM_PROPERTIES_ENABLED
		rect2->property_stroke_color() = "red" ;
		rect2->property_line_width() = 0.5 ;
		#endif
		root->add_child(rect2);
		child_num=child_num+1;

		first(xx-16,yy-16,xx,yy);
		second(xx+ww+16,yy-16,xx+ww,yy);
		third(xx-16,yy+hh+16,xx,yy+hh);
		fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
		fifth(xx+ww/2,yy-22,xx+ww/2,yy);
		sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
		seventh(xx-22,yy+hh/2,xx,yy+hh/2);
		eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);
		}



	 if((eraser_grouped_child_no.size()!=0) && ((global_y_diff!=0)||(global_x_diff!=0)))
		{

		double xx1,yy1,ww1,hh1;

		xx1 = grp_xx;
		yy1 = grp_yy;
		ww1 = grp_ww;
		hh1 = grp_hh;

		Glib::RefPtr<Goocanvas::Rect> rect1 ;
		rect1 = Goocanvas::Rect::create(xx1,yy1,ww1,hh1); 
		#ifdef GLIBMM_PROPERTIES_ENABLED
		rect1->property_stroke_color() = "red" ;
		rect1->property_line_width() = 0.5 ;
		#endif
		root->add_child(rect1);
		child_num=child_num+1;
		first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
		second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
		third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
		fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
		fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
		sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
		seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
		eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);


	  		}
		move_var=1;	
		}
		split_x_y.clear();
	 	combined_x_y.clear();
		}
		   edit_flag=1;
		   create_xml_for_path(path_val);
		   my_str1_tag = "";
		   my_str1_tag = open_global_data;
	   }
	}

 }

if(drawing_tool_number==4)
pEraserWidth->show();
else
pEraserWidth->hide();
}
catch(Exception e)
{
}

}


void KalanjiyamWindow::control_points_remove()
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  int chi_del=child_num-8;
  for(child_var=chi_del; child_var<=child_num; child_var++)
  {
  root->remove_child(chi_del);
  }
  child_num=child_num-9;
}

void KalanjiyamWindow::control_points_selected_items_remove()
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(move_var>0 && group_child_no.size()==0)
  {
  control_points_remove();
  }
  else if(group_child_no.size()>0)		//While the grouping rectangles are there, remove the grouping rectangles
  {
  selected_items_remove();
  }
  move_var=0;
  polyline_cnt_curve_cnt();
}

void KalanjiyamWindow::selected_items_remove()
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  int chi_del=child_num-group_item_no+1;
  for(child_var=chi_del; child_var<=child_num; child_var++)
  {
  root->remove_child(chi_del);
  group_child_no.pop_back(); 
  group_child_region_no.pop_back();
  group_xx.pop_back();
  group_yy.pop_back();
  group_end_xx.pop_back();
  group_end_yy.pop_back();
  }
  child_num=child_num-group_item_no;
  group_item_no=0;
}

void KalanjiyamWindow::find_group_or_not(int child, Glib::ustring if_condi_type, Glib::ustring sort_condi_type, Glib::ustring event_type)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  int n = child;
  std::string if_condi = if_condi_type;
  std::string sort_condi = sort_condi_type;
  std::string evnt_type = event_type;

  int single_child_same_no=-1;
  for(int i=0; i<group_child_total_list.size(); i++)
  {
    tokenizer<> tok(group_child_total_list[i]);
    tokenizer<>::iterator beg=tok.begin();
    if(*beg=="S")
    {
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
        if(if_condi=="single_if")
        {	
          if(child_in_total_list==n)
          {
          single_child_same_no=i;
          break;
          }
        }
        else if(if_condi=="double_if")
        {	
          if((child_in_total_list==changed_item_num) || (child_in_total_list==last_child_num))//chg_itm_no && lst_chi_no are global
          {
          single_child_same_no=i;
          break;
          }
        }
      }
    }
  }
  int group_child_same_no=-1;
  global_group_status=-1;
  for(int i=0; i<group_child_total_list.size(); i++)
  {
    tokenizer<> tok(group_child_total_list[i]);
    tokenizer<>::iterator beg=tok.begin();
    if(*beg=="G")
    {
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
        if(child_in_total_list==single_child_same_no)
        {
        group_child_same_no=i;
        global_group_status=i;
        }	
      }
    }
  }
  if(group_child_same_no!=-1)		//If the child is in a group
  {
    if(evnt_type=="but_press")	//Button Press Event
    {
      if((group_item_no==0 && group_var=="") || (group_item_no!=0 && (group_var=="Shift_L" || group_var=="Shift_R")))
      {
        tokenizer<> tok(group_child_total_list[group_child_same_no]);
        int k=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(k!=1)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            for(int i=0; i<group_child_total_list.size(); i++)
            {
              if(i==child_in_total_list)
              {
                tokenizer<> tok(group_child_total_list[i]);
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  changed_item=root->get_child(child_in_total_list);
                  grouped_child_no.push_back(child_in_total_list);

                  xx=changed_item->property_x();
                  yy=changed_item->property_y();
                  ww=changed_item->property_width();
                  hh=changed_item->property_height();
                  group_xx.push_back(xx);
                  group_yy.push_back(yy);
                  group_end_xx.push_back(xx+ww);
                  group_end_yy.push_back(yy+hh);
                  }
                  l++;
                }
              }
            }
          }
          k++;
        }
        std::sort (group_xx.begin(), group_xx.end());
        std::sort (group_yy.begin(), group_yy.end());
        std::sort (group_end_xx.begin(), group_end_xx.end(), std::greater<double>());
        std::sort (group_end_yy.begin(), group_end_yy.end(), std::greater<double>());

        grp_xx=group_xx[0];
        grp_yy=group_yy[0];
        grp_ww=group_end_xx[0]-grp_xx;
        grp_hh=group_end_yy[0]-grp_yy;

        open_global_width = grp_ww;
        open_global_height = grp_hh;
        open_global_xposition = grp_xx;
        open_global_yposition = grp_yy;
      }
      grouping_flag=1;
    }
    else	//Motion Notify or Button Release Event or group_select or edit paste
    {
      tokenizer<> tok(group_child_total_list[group_child_same_no]);
      int k=1;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(k!=1)
        {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;
                  changed_item=root->get_child(child_in_total_list);

                  if(evnt_type=="grp_select")
                  group_child_no.push_back(child_in_total_list);
                  else if(evnt_type=="raise_current_child")
                  raise_current_child_temp_vector.push_back(child_in_total_list);
                  else if(evnt_type=="raise_next_child")
                  raise_next_child_temp_vector.push_back(child_in_total_list);
                  else
                  grouped_child_no.push_back(child_in_total_list);

                  if(evnt_type=="edit_copy")
                  copy_status=2;

                  if(evnt_type!="edit_copy")	
                  {
                    xx=changed_item->property_x();
                    yy=changed_item->property_y();
                    ww=changed_item->property_width();
                    hh=changed_item->property_height();
                    group_xx.push_back(xx);
                    group_yy.push_back(yy);
                    group_end_xx.push_back(xx+ww);
                    group_end_yy.push_back(yy+hh);

                    if(evnt_type=="grp_select")
                    {
                    Glib::RefPtr<Goocanvas::Rect> rect1 ;
					rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
                    //rect1 = Goocanvas::Rect::create(s1,s3,s2-s1,s4-s3); 
                    #ifdef GLIBMM_PROPERTIES_ENABLED
                    rect1->property_stroke_color() = "red" ;
                    rect1->property_line_width() = 0.5 ;
                    #endif
                    root->add_child(rect1);
                    child_num=child_num+1;
                    group_child_region_no.push_back(child_num);
                    group_item_no=group_item_no+1;
                    }	
                  }
                }
                l++;
              }
            }
          }
        }
        k++;
      }
      if(sort_condi=="sort_true")
      {
      std::sort (group_xx.begin(), group_xx.end());
      std::sort (group_yy.begin(), group_yy.end());
      std::sort (group_end_xx.begin(), group_end_xx.end(), std::greater<double>());
      std::sort (group_end_yy.begin(), group_end_yy.end(), std::greater<double>());

      grp_xx=group_xx[0];
      grp_yy=group_yy[0];
      grp_ww=group_end_xx[0]-grp_xx;
      grp_hh=group_end_yy[0]-grp_yy;
      }
    }
  }
  else	// If the last child is a single item
  {	
    if(evnt_type=="edit_copy")
    {
    copy_status=1;
    }
    if(evnt_type=="grp_select")
    {
      changed_item=root->get_child(n);	
      group_child_no.push_back(n);

      xx=changed_item->property_x();
      yy=changed_item->property_y();
      ww=changed_item->property_width();
      hh=changed_item->property_height();
      group_xx.push_back(xx); 
      group_yy.push_back(yy);
      group_end_xx.push_back(xx+ww);
      group_end_yy.push_back(yy+hh);

      Glib::RefPtr<Goocanvas::Rect> rect1 ;
	  rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
      //rect1 = Goocanvas::Rect::create(s1,s3,s2-s1,s4-s3); 
      #ifdef GLIBMM_PROPERTIES_ENABLED
      rect1->property_stroke_color() = "red" ;
      rect1->property_line_width() = 0.5 ;
      #endif
      root->add_child(rect1);
      child_num=child_num+1;
      group_child_region_no.push_back(child_num);
      group_item_no=group_item_no+1;
    }
  }
}

void KalanjiyamWindow::navi_movement(Glib::ustring move_typ)
{
  if(move_var>0)
  {
	int  child_number_for_image_int;
    Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
    std::string move_type = move_typ;

    int single_child_same_no=-1;

    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="S")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          if(child_in_total_list==changed_item_num)
          {
          single_child_same_no=i;

          break;
          }	
        }
      }
    }
    int group_child_same_no=-1;
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="G")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          if(child_in_total_list==single_child_same_no)
          {
            group_child_same_no=i;
          }	
        }
      }
    }
    if(group_child_same_no!=-1)		//If the clicked item is a grouped item
    {
      tokenizer<> tok(group_child_total_list[group_child_same_no]);
      int k=1;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(k!=1)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                int child_in_total_list;
                std::stringstream str(*beg);
                str>>child_in_total_list;
                changed_item=root->get_child(child_in_total_list);
                grouped_child_no.push_back(child_in_total_list);

                xx=changed_item->property_x();
                yy=changed_item->property_y();
                ww=changed_item->property_width();
                hh=changed_item->property_height();

                group_xx.push_back(xx);
                group_yy.push_back(yy);
                group_end_xx.push_back(xx+ww);
                group_end_yy.push_back(yy+hh);
                }
                l++;
              }
            }
          }
        }
        k++;
      }

      std::sort (group_xx.begin(), group_xx.end());
      std::sort (group_yy.begin(), group_yy.end());
      std::sort (group_end_xx.begin(), group_end_xx.end(), std::greater<double>());
      std::sort (group_end_yy.begin(), group_end_yy.end(), std::greater<double>());

      grp_xx=group_xx[0];		//Find x, y, w, h values to create the control region
      grp_yy=group_yy[0];
      grp_ww=group_end_xx[0]-grp_xx;
      grp_hh=group_end_yy[0]-grp_yy;

      if(move_type=="left")
      grp_xx=grp_xx-2;	
      else if(move_type=="right")
      grp_xx=grp_xx+2;	
      else if(move_type=="up")
      grp_yy=grp_yy-2;	
      else if(move_type=="down")
      grp_yy=grp_yy+2;	

      control_points_remove();

      Glib::RefPtr<Goocanvas::Rect> rect1 ;
      rect1 = Goocanvas::Rect::create(grp_xx,grp_yy,grp_ww,grp_hh); 
      #ifdef GLIBMM_PROPERTIES_ENABLED
      rect1->property_stroke_color() = "red" ;
      rect1->property_line_width() = 0.5 ;
      #endif
      root->add_child(rect1);
      child_num=child_num+1;

      first(grp_xx-16,grp_yy-16,grp_xx,grp_yy);
      second(grp_xx+grp_ww+16,grp_yy-16,grp_xx+grp_ww,grp_yy);
      third(grp_xx-16,grp_yy+grp_hh+16,grp_xx,grp_yy+grp_hh);
      fourth(grp_xx+grp_ww,grp_yy+grp_hh,grp_xx+grp_ww+16,grp_yy+grp_hh+16);
      fifth(grp_xx+grp_ww/2,grp_yy-22,grp_xx+grp_ww/2,grp_yy);
      sixth(grp_xx+grp_ww/2,grp_yy+grp_hh+22,grp_xx+grp_ww/2,grp_yy+grp_hh);
      seventh(grp_xx-22,grp_yy+grp_hh/2,grp_xx,grp_yy+grp_hh/2);
      eighth(grp_xx+grp_ww,grp_yy+grp_hh/2,grp_xx+grp_ww+22,grp_yy+grp_hh/2);


 

      for(int i=0; i<grouped_child_no.size(); i++)
      {
		int n=grouped_child_no[i];
		changed_item=root->get_child(n);
		xx=changed_item->property_x();	 
		yy=changed_item->property_y();

		std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[n-1]+" </Scene> </Kalanjiyam>";

		const std::string input_xml = test;
		vector<char> xml_copy(input_xml.begin(), input_xml.end());
		xml_copy.push_back('\0');
		xml_document<> doc;
		doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
		xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
		xml_node<>* Scene = Kalanjiyam->first_node("Scene");
		xml_node<> * abc; 
		while (Scene != NULL )
		{
		for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
		{
		  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
		  {
			const char * node_name = abc->name();
			const char * node_value = abc->value();		
			open_node_name = node_name;
			open_node_value = node_value;
			const char * attribute_name = attribute->name();	
			const char * attribute_value = attribute->value();	

			if (strcmp(open_node_name, "Text") == 0)
			{
			open_node_name_curve = 1;
			}
			if (strcmp(open_node_name, "Path") == 0)
			{
			 Glib::ustring path_val;
			 path_val = open_node_value;
			 path_val=""+path_val+"";

			 if(path_val==" Curve ")
			 {
				open_node_name_curve = 1;
			 }
			}

			if (strcmp(attribute_name, "data") == 0) 
			{
			open_global_data = attribute_value;
			//image_status=0;
			}
			if (strcmp(attribute_name, "py_data") == 0) 
			{
			open_global_python_data = attribute_value;
			//image_status=0;
			}
				 
			}
			}
		Scene = Scene->next_sibling("Scene");	
		}


		for(int g=0;g<for_image_indentification.size();g++)
				{
				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;
				  tokenizer<> tok(get_image_number);
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	
					   child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);

				   if(n==child_number_for_image_int)
						{
							image_status=1;


						}
			}



		if(move_type=="left")		//groupasdf
		{
			xx=xx-2;
			/****/

			if(open_node_name_curve ==0)
			{
				if(image_status==1)  // DRAGGING EVENT 
				{


					std::vector<std::string>split_x_y;  
					std::vector<std::string>combined_x_y; 
					global_x_diff=-2;
					global_y_diff=0;
					my_str1_tag = "";

					my_str1_tag = open_global_data;

					std::string delimiter = ",";
					std::string storestring="";


					 string strvalue1;
					 string strvalue2;
					 stringstream stream(my_str1_tag);
					 while( getline(stream, strvalue1, ' ') )
						 split_x_y.push_back(strvalue1);

					 string dis_x_str;
					 string dis_y_str;

					float dis_x_int;
					float dis_y_int;
					int a_size=split_x_y.size();

					for (int g=0; g<split_x_y.size(); g++)
					{
					  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
						{
						combined_x_y.push_back("Z");
						break;
						//g = g++;
						}
					  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
						{
						combined_x_y.push_back(split_x_y[g]);
						g=g++;
						}

					if(split_x_y[g]=="M" || split_x_y[g]== "L")
					   {
							if(split_x_y[g]=="M")
							{
							combined_x_y.push_back(split_x_y[g]);
							g = g++;
							}
						   else	if(split_x_y[g]=="L")
							{
							combined_x_y.push_back(split_x_y[g]);
							g = g++;
							}
							dis_x_str =split_x_y[g];
						 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
							dis_x_int = dis_x_int + global_x_diff;
							dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
							combined_x_y.push_back(dis_x_str);


							g = g++;
							dis_y_str =split_x_y[g];
							dis_y_int =boost::lexical_cast<float>(dis_y_str);
							dis_y_int= dis_y_int + global_y_diff;
							dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
							combined_x_y.push_back(dis_y_str);			
						}   

					}
					my_str1_tag="";
					for (int g=0; g<combined_x_y.size(); g++)
					{
					 if(g==0)
						 my_str1_tag = combined_x_y[g] ;
					else
						 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
					}
					// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
					//come_from_line_change1 = 1;
					open_global_data =  my_str1_tag;


					//open_glob_dat = open_global_data;



					string open_global_python_data_for_check = open_global_python_data.substr(0,6);

					if(open_global_python_data_for_check=="MULTIP")
					{
					string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

					string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

					Glib::locale_from_utf8(open_global_python_data);
					Glib::locale_from_utf8(dis_x_str_str);
					Glib::locale_from_utf8(dis_y_str_str);

					const char *open_global_python_data1 = open_global_python_data.c_str();
					const char *dis_x_str1 = dis_x_str_str.c_str();
					const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


						PyRun_SimpleString("import ast\n"
					"from shapely.geometry import Polygon, MultiPolygon\n"
					"from shapely.geometry import *\n"
					"from shapely.ops import cascaded_union\n"
					"Multipo = pythondata\n"
					"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
					"Multipo = Multipo.replace(')))','))')\n"
					"Multipo = Multipo.replace(', ((','split[(')\n"
					"Multipo = Multipo.replace('))',')]')\n"
					"Multipo = Multipo.replace('), (',')],[(')\n"
					"Multipo = Multipo.replace(', ','),(')\n"
					"Multipo = Multipo.replace(' ',',')\n"
					"Multipo = Multipo.split('split')\n"
					"s = []\n"
					"for i in Multipo:\n"
					"	a = i.split('],[')\n"
					"	if len(a) >=2:\n"
					"		i = i.replace('],[','],[[',1)\n"
					"		i = '[' + i + ']]'\n"
					"		i = ast.literal_eval(i)\n"
					"		m = []\n"
					"		n = []\n"
					"		o = []\n"
					"		for j in i[0]:\n"
					"			k = j[0]+float(pythondata1)\n"
					"			l = j[1]+float(pythondata2)\n"
					"			m.append((k,l))\n"
					"		for a in i[1]:\n"
					"			for b in a:\n"
					"				k = b[0]+float(pythondata1)\n"
					"				l = b[1]+float(pythondata2)\n"
					"				o.append((k,l))\n"
					"			n.append(o)\n"
					"		s.append(Polygon(m,n).buffer(0))\n"
					"	else:\n"
					"		i = ast.literal_eval(i)\n"
					"		m = []\n"
					"		for j in i:\n"
					"			k = j[0]+float(pythondata1)\n"
					"			l = j[1]+float(pythondata2)\n"
					"			m.append((k,l))\n"
					"		s.append(Polygon(m).buffer(0))\n"
					"C = cascaded_union(s)\n"
					"C1 = str(C)\n");


					PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
					PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
					PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
					string changed_val = PyString_AsString(eraserera);

					open_global_python_data = changed_val;
				  }
								//}
				Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(n);
				imgg->set_property("clip_path", Glib::ustring(open_global_data));
				get_property(imgg,n);
				image_status = 0;

			}	
			else
			{


				std::vector<std::string>split_x_y;  
				std::vector<std::string>combined_x_y; 
				global_x_diff=-2;
				global_y_diff=0;


				my_str1_tag = "";

				my_str1_tag = open_global_data;

				std::string delimiter = ",";
				std::string storestring="";


				 string strvalue1;
				 string strvalue2;
				 stringstream stream(my_str1_tag);
				 while( getline(stream, strvalue1, ' ') )
					 split_x_y.push_back(strvalue1);



				 string dis_x_str;
				 string dis_y_str;

				float dis_x_int;
				float dis_y_int;
				int a_size=split_x_y.size();



				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

				PyObject *main = PyImport_AddModule("__main__"); // borrowed

				PyObject *globals = PyModule_GetDict(main); // borrowed
				PyObject *py_data = PyString_FromString(open_global_python_data1);

				PyDict_SetItemString(globals, "pythondata", py_data) ;

				Py_DECREF(py_data);

				PyObject *py_data1 = PyString_FromString(dis_x_str1);

				PyDict_SetItemString(globals, "pythondata1", py_data1);


				Py_DECREF(py_data1);


				PyObject *py_data2 = PyString_FromString(dis_y_str1);

				 
				PyDict_SetItemString(globals, "pythondata2", py_data2);

				Py_DECREF(py_data2);


					PyRun_SimpleString("import ast\n"
				"from shapely.geometry import Polygon, MultiPolygon\n"
				"from shapely.geometry import *\n"
				"from shapely.ops import cascaded_union\n"
				"Multipo = pythondata\n"
				"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
				"Multipo = Multipo.replace(')))','))')\n"
				"Multipo = Multipo.replace(', ((','split[(')\n"
				"Multipo = Multipo.replace('))',')]')\n"
				"Multipo = Multipo.replace('), (',')],[(')\n"
				"Multipo = Multipo.replace(', ','),(')\n"
				"Multipo = Multipo.replace(' ',',')\n"
				"Multipo = Multipo.split('split')\n"
				"s = []\n"
				"for i in Multipo:\n"
				"	a = i.split('],[')\n"
				"	if len(a) >=2:\n"
				"		i = i.replace('],[','],[[',1)\n"
				"		i = '[' + i + ']]'\n"
				"		i = ast.literal_eval(i)\n"
				"		m = []\n"
				"		n = []\n"
				"		o = []\n"
				"		for j in i[0]:\n"
				"			k = j[0]+float(pythondata1)\n"
				"			l = j[1]+float(pythondata2)\n"
				"			m.append((k,l))\n"
				"		for a in i[1]:\n"
				"			for b in a:\n"
				"				k = b[0]+float(pythondata1)\n"
				"				l = b[1]+float(pythondata2)\n"
				"				o.append((k,l))\n"
				"			n.append(o)\n"
				"		s.append(Polygon(m,n).buffer(0))\n"
				"	else:\n"
				"		i = ast.literal_eval(i)\n"
				"		m = []\n"
				"		for j in i:\n"
				"			k = j[0]+float(pythondata1)\n"
				"			l = j[1]+float(pythondata2)\n"
				"			m.append((k,l))\n"
				"		s.append(Polygon(m).buffer(0))\n"
				"C = cascaded_union(s)\n"
				"C1 = str(C)\n");


					PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
					PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
					PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
					string changed_val = PyString_AsString(eraserera);

					open_global_python_data = changed_val;
				}
								//}
			image_status=1;
			get_property(changed_item,n);
			image_status=0;

				}//CURVE CHECK ENDS 

			}	

			/****/

		}
		
		else if(move_type=="right")
		  {
			xx=xx+2;

			if(open_node_name_curve ==0)
			{

				if(image_status==1)  // DRAGGING EVENT 
						{
					std::vector<std::string>split_x_y;  
					std::vector<std::string>combined_x_y; 
					global_x_diff=+2;
					global_y_diff=0;

					my_str1_tag = "";

					my_str1_tag = open_global_data;

					std::string delimiter = ",";
					std::string storestring="";


					 string strvalue1;
					 string strvalue2;
					 stringstream stream(my_str1_tag);
					 while( getline(stream, strvalue1, ' ') )
						 split_x_y.push_back(strvalue1);



					 string dis_x_str;
					 string dis_y_str;

					float dis_x_int;
					float dis_y_int;
					int a_size=split_x_y.size();


					for (int g=0; g<split_x_y.size(); g++)
					{
					  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
						{
						combined_x_y.push_back("Z");
						break;
						//g = g++;
						}
					  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
						{
						combined_x_y.push_back(split_x_y[g]);
						g=g++;
						}

					if(split_x_y[g]=="M" || split_x_y[g]== "L")
					   {
							if(split_x_y[g]=="M")
							{
							combined_x_y.push_back(split_x_y[g]);
							g = g++;
							}
						   else	if(split_x_y[g]=="L")
							{
							combined_x_y.push_back(split_x_y[g]);
							g = g++;
							}
							dis_x_str =split_x_y[g];
						 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
							dis_x_int = dis_x_int + global_x_diff;
							dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
							combined_x_y.push_back(dis_x_str);


							g = g++;
							dis_y_str =split_x_y[g];
							dis_y_int =boost::lexical_cast<float>(dis_y_str);
							dis_y_int= dis_y_int + global_y_diff;
							dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
							combined_x_y.push_back(dis_y_str);			
						}   

					}
					my_str1_tag="";
					for (int g=0; g<combined_x_y.size(); g++)
					{
					 if(g==0)
						 my_str1_tag = combined_x_y[g] ;
					else
						 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
					}
					// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
					//come_from_line_change1 = 1;
					open_global_data =  my_str1_tag;

					//open_glob_dat = open_global_data;



					string open_global_python_data_for_check = open_global_python_data.substr(0,6);

					if(open_global_python_data_for_check=="MULTIP")
					{
					string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

					string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

					Glib::locale_from_utf8(open_global_python_data);
					Glib::locale_from_utf8(dis_x_str_str);
					Glib::locale_from_utf8(dis_y_str_str);

					const char *open_global_python_data1 = open_global_python_data.c_str();
					const char *dis_x_str1 = dis_x_str_str.c_str();
					const char *dis_y_str1 = dis_y_str_str.c_str();

						PyObject *main = PyImport_AddModule("__main__"); // borrowed
						/*if (main == NULL)
							//error();
						return 0;*/
						PyObject *globals = PyModule_GetDict(main); // borrowed
						PyObject *py_data = PyString_FromString(open_global_python_data1);
						/*if (py_data == NULL)
						return 0;
						   //error();*/
						PyDict_SetItemString(globals, "pythondata", py_data) ;
						//return 0;
						   //error();
						Py_DECREF(py_data);

						PyObject *py_data1 = PyString_FromString(dis_x_str1);
						/*if (py_data1 == NULL)
						return 0;
						   //error();*/
						PyDict_SetItemString(globals, "pythondata1", py_data1);
						//return 0;*/
						   //error();
						Py_DECREF(py_data1);


						PyObject *py_data2 = PyString_FromString(dis_y_str1);
						/*if (py_data2 == NULL)
						return 0;
						   //error();*/
						PyDict_SetItemString(globals, "pythondata2", py_data2);
						//return 0;
						   //error();
						Py_DECREF(py_data2);


								PyRun_SimpleString("import ast\n"
							"from shapely.geometry import Polygon, MultiPolygon\n"
							"from shapely.geometry import *\n"
							"from shapely.ops import cascaded_union\n"
							"Multipo = pythondata\n"
							"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
							"Multipo = Multipo.replace(')))','))')\n"
							"Multipo = Multipo.replace(', ((','split[(')\n"
							"Multipo = Multipo.replace('))',')]')\n"
							"Multipo = Multipo.replace('), (',')],[(')\n"
							"Multipo = Multipo.replace(', ','),(')\n"
							"Multipo = Multipo.replace(' ',',')\n"
							"Multipo = Multipo.split('split')\n"
							"s = []\n"
							"for i in Multipo:\n"
							"	a = i.split('],[')\n"
							"	if len(a) >=2:\n"
							"		i = i.replace('],[','],[[',1)\n"
							"		i = '[' + i + ']]'\n"
							"		i = ast.literal_eval(i)\n"
							"		m = []\n"
							"		n = []\n"
							"		o = []\n"
							"		for j in i[0]:\n"
							"			k = j[0]+float(pythondata1)\n"
							"			l = j[1]+float(pythondata2)\n"
							"			m.append((k,l))\n"
							"		for a in i[1]:\n"
							"			for b in a:\n"
							"				k = b[0]+float(pythondata1)\n"
							"				l = b[1]+float(pythondata2)\n"
							"				o.append((k,l))\n"
							"			n.append(o)\n"
							"		s.append(Polygon(m,n).buffer(0))\n"
							"	else:\n"
							"		i = ast.literal_eval(i)\n"
							"		m = []\n"
							"		for j in i:\n"
							"			k = j[0]+float(pythondata1)\n"
							"			l = j[1]+float(pythondata2)\n"
							"			m.append((k,l))\n"
							"		s.append(Polygon(m).buffer(0))\n"
							"C = cascaded_union(s)\n"
							"C1 = str(C)\n");


					PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
					PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
					PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
					string changed_val = PyString_AsString(eraserera);

					open_global_python_data = changed_val;
					}
					//}
				Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(n);
				imgg->set_property("clip_path", Glib::ustring(open_global_data));
				get_property(imgg,n);
				image_status = 0;
			}	
			else
			{

			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=+2;
			global_y_diff=0;


			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

				PyObject *main = PyImport_AddModule("__main__"); // borrowed

				PyObject *globals = PyModule_GetDict(main); // borrowed
				PyObject *py_data = PyString_FromString(open_global_python_data1);

				PyDict_SetItemString(globals, "pythondata", py_data) ;

				Py_DECREF(py_data);

				PyObject *py_data1 = PyString_FromString(dis_x_str1);

				PyDict_SetItemString(globals, "pythondata1", py_data1);


				Py_DECREF(py_data1);


				PyObject *py_data2 = PyString_FromString(dis_y_str1);

				 
				PyDict_SetItemString(globals, "pythondata2", py_data2);

				Py_DECREF(py_data2);


						PyRun_SimpleString("import ast\n"
					"from shapely.geometry import Polygon, MultiPolygon\n"
					"from shapely.geometry import *\n"
					"from shapely.ops import cascaded_union\n"
					"Multipo = pythondata\n"
					"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
					"Multipo = Multipo.replace(')))','))')\n"
					"Multipo = Multipo.replace(', ((','split[(')\n"
					"Multipo = Multipo.replace('))',')]')\n"
					"Multipo = Multipo.replace('), (',')],[(')\n"
					"Multipo = Multipo.replace(', ','),(')\n"
					"Multipo = Multipo.replace(' ',',')\n"
					"Multipo = Multipo.split('split')\n"
					"s = []\n"
					"for i in Multipo:\n"
					"	a = i.split('],[')\n"
					"	if len(a) >=2:\n"
					"		i = i.replace('],[','],[[',1)\n"
					"		i = '[' + i + ']]'\n"
					"		i = ast.literal_eval(i)\n"
					"		m = []\n"
					"		n = []\n"
					"		o = []\n"
					"		for j in i[0]:\n"
					"			k = j[0]+float(pythondata1)\n"
					"			l = j[1]+float(pythondata2)\n"
					"			m.append((k,l))\n"
					"		for a in i[1]:\n"
					"			for b in a:\n"
					"				k = b[0]+float(pythondata1)\n"
					"				l = b[1]+float(pythondata2)\n"
					"				o.append((k,l))\n"
					"			n.append(o)\n"
					"		s.append(Polygon(m,n).buffer(0))\n"
					"	else:\n"
					"		i = ast.literal_eval(i)\n"
					"		m = []\n"
					"		for j in i:\n"
					"			k = j[0]+float(pythondata1)\n"
					"			l = j[1]+float(pythondata2)\n"
					"			m.append((k,l))\n"
					"		s.append(Polygon(m).buffer(0))\n"
					"C = cascaded_union(s)\n"
					"C1 = str(C)\n");


					PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
					PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
					PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
					string changed_val = PyString_AsString(eraserera);

					open_global_python_data = changed_val;
					}
							//}
				image_status=1;
				get_property(changed_item,n);
				image_status=0;
				//create_xml_for_path(erased_value);
				}// CURVE CHECK ENDS 

				}	
		 }
		else if(move_type=="up")
		{
			yy=yy-2;
			if(open_node_name_curve ==0)
			{
			if(image_status==1)  // DRAGGING EVENT 
					{


					std::vector<std::string>split_x_y;  
					std::vector<std::string>combined_x_y; 
					global_x_diff=0;
					global_y_diff=-2;


					my_str1_tag = "";

					my_str1_tag = open_global_data;

					std::string delimiter = ",";
					std::string storestring="";


					 string strvalue1;
					 string strvalue2;
					 stringstream stream(my_str1_tag);
					 while( getline(stream, strvalue1, ' ') )
						 split_x_y.push_back(strvalue1);



					 string dis_x_str;
					 string dis_y_str;

					float dis_x_int;
					float dis_y_int;
					int a_size=split_x_y.size();


						for (int g=0; g<split_x_y.size(); g++)
						{
						  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
							{
							combined_x_y.push_back("Z");
							break;
							//g = g++;
							}
						  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
							{
							combined_x_y.push_back(split_x_y[g]);
							g=g++;
							}

						if(split_x_y[g]=="M" || split_x_y[g]== "L")
						   {
								if(split_x_y[g]=="M")
								{
								combined_x_y.push_back(split_x_y[g]);
								g = g++;
								}
							   else	if(split_x_y[g]=="L")
								{
								combined_x_y.push_back(split_x_y[g]);
								g = g++;
								}
								dis_x_str =split_x_y[g];
							 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
								dis_x_int = dis_x_int + global_x_diff;
								dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
								combined_x_y.push_back(dis_x_str);


								g = g++;
								dis_y_str =split_x_y[g];
								dis_y_int =boost::lexical_cast<float>(dis_y_str);
								dis_y_int= dis_y_int + global_y_diff;
								dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
								combined_x_y.push_back(dis_y_str);			
							}   

						}
						my_str1_tag="";
						for (int g=0; g<combined_x_y.size(); g++)
						{
						 if(g==0)
							 my_str1_tag = combined_x_y[g] ;
						else
							 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
						}
						// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
						//come_from_line_change1 = 1;
						open_global_data =  my_str1_tag;

						//open_glob_dat = open_global_data;



						string open_global_python_data_for_check = open_global_python_data.substr(0,6);

						if(open_global_python_data_for_check=="MULTIP")
						{
						string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

						string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

						Glib::locale_from_utf8(open_global_python_data);
						Glib::locale_from_utf8(dis_x_str_str);
						Glib::locale_from_utf8(dis_y_str_str);

						const char *open_global_python_data1 = open_global_python_data.c_str();
						const char *dis_x_str1 = dis_x_str_str.c_str();
						const char *dis_y_str1 = dis_y_str_str.c_str();

						PyObject *main = PyImport_AddModule("__main__"); // borrowed
						/*if (main == NULL)
							//error();
						return 0;*/
						PyObject *globals = PyModule_GetDict(main); // borrowed
						PyObject *py_data = PyString_FromString(open_global_python_data1);
						/*if (py_data == NULL)
						return 0;
						   //error();*/
						PyDict_SetItemString(globals, "pythondata", py_data) ;
						//return 0;
						   //error();
						Py_DECREF(py_data);

						PyObject *py_data1 = PyString_FromString(dis_x_str1);
						/*if (py_data1 == NULL)
						return 0;
						   //error();*/
						PyDict_SetItemString(globals, "pythondata1", py_data1);
						//return 0;*/
						   //error();
						Py_DECREF(py_data1);


						PyObject *py_data2 = PyString_FromString(dis_y_str1);
						/*if (py_data2 == NULL)
						return 0;
						   //error();*/
						PyDict_SetItemString(globals, "pythondata2", py_data2);
						//return 0;
						   //error();
						Py_DECREF(py_data2);


							PyRun_SimpleString("import ast\n"
						"from shapely.geometry import Polygon, MultiPolygon\n"
						"from shapely.geometry import *\n"
						"from shapely.ops import cascaded_union\n"
						"Multipo = pythondata\n"
						"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
						"Multipo = Multipo.replace(')))','))')\n"
						"Multipo = Multipo.replace(', ((','split[(')\n"
						"Multipo = Multipo.replace('))',')]')\n"
						"Multipo = Multipo.replace('), (',')],[(')\n"
						"Multipo = Multipo.replace(', ','),(')\n"
						"Multipo = Multipo.replace(' ',',')\n"
						"Multipo = Multipo.split('split')\n"
						"s = []\n"
						"for i in Multipo:\n"
						"	a = i.split('],[')\n"
						"	if len(a) >=2:\n"
						"		i = i.replace('],[','],[[',1)\n"
						"		i = '[' + i + ']]'\n"
						"		i = ast.literal_eval(i)\n"
						"		m = []\n"
						"		n = []\n"
						"		o = []\n"
						"		for j in i[0]:\n"
						"			k = j[0]+float(pythondata1)\n"
						"			l = j[1]+float(pythondata2)\n"
						"			m.append((k,l))\n"
						"		for a in i[1]:\n"
						"			for b in a:\n"
						"				k = b[0]+float(pythondata1)\n"
						"				l = b[1]+float(pythondata2)\n"
						"				o.append((k,l))\n"
						"			n.append(o)\n"
						"		s.append(Polygon(m,n).buffer(0))\n"
						"	else:\n"
						"		i = ast.literal_eval(i)\n"
						"		m = []\n"
						"		for j in i:\n"
						"			k = j[0]+float(pythondata1)\n"
						"			l = j[1]+float(pythondata2)\n"
						"			m.append((k,l))\n"
						"		s.append(Polygon(m).buffer(0))\n"
						"C = cascaded_union(s)\n"
						"C1 = str(C)\n");


						PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
						PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
						PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
						string changed_val = PyString_AsString(eraserera);

						open_global_python_data = changed_val;
						}
									//}
						Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(n);
						imgg->set_property("clip_path", Glib::ustring(open_global_data));

						// 	imgg->set_property("x",xx);
						//		  	imgg->set_property("y",yy);	

						get_property(imgg,n);
						image_status = 0;
				}
					else
					{

								std::vector<std::string>split_x_y;  
								std::vector<std::string>combined_x_y; 
								global_x_diff=0;
								global_y_diff=-2;


								my_str1_tag = "";

								my_str1_tag = open_global_data;

								std::string delimiter = ",";
								std::string storestring="";


								 string strvalue1;
								 string strvalue2;
								 stringstream stream(my_str1_tag);
								 while( getline(stream, strvalue1, ' ') )
									 split_x_y.push_back(strvalue1);



								 string dis_x_str;
								 string dis_y_str;

								float dis_x_int;
								float dis_y_int;
								int a_size=split_x_y.size();


									for (int g=0; g<split_x_y.size(); g++)
									{
									  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
										{
										combined_x_y.push_back("Z");
										break;
										//g = g++;
										}
									  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
										{
										combined_x_y.push_back(split_x_y[g]);
										g=g++;
										}

									if(split_x_y[g]=="M" || split_x_y[g]== "L")
									   {
											if(split_x_y[g]=="M")
											{
											combined_x_y.push_back(split_x_y[g]);
											g = g++;
											}
										   else	if(split_x_y[g]=="L")
											{
											combined_x_y.push_back(split_x_y[g]);
											g = g++;
											}
											dis_x_str =split_x_y[g];
										 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
											dis_x_int = dis_x_int + global_x_diff;
											dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
											combined_x_y.push_back(dis_x_str);


											g = g++;
											dis_y_str =split_x_y[g];
											dis_y_int =boost::lexical_cast<float>(dis_y_str);
											dis_y_int= dis_y_int + global_y_diff;
											dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
											combined_x_y.push_back(dis_y_str);			
										}   

									}
									my_str1_tag="";
									for (int g=0; g<combined_x_y.size(); g++)
									{
									 if(g==0)
										 my_str1_tag = combined_x_y[g] ;
									else
										 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
									}
									// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
									//come_from_line_change1 = 1;
									open_global_data =  my_str1_tag;

									//open_glob_dat = open_global_data;



									string open_global_python_data_for_check = open_global_python_data.substr(0,6);

									if(open_global_python_data_for_check=="MULTIP")
									{
									string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

									string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

									Glib::locale_from_utf8(open_global_python_data);
									Glib::locale_from_utf8(dis_x_str_str);
									Glib::locale_from_utf8(dis_y_str_str);

									const char *open_global_python_data1 = open_global_python_data.c_str();
									const char *dis_x_str1 = dis_x_str_str.c_str();
									const char *dis_y_str1 = dis_y_str_str.c_str();

										PyObject *main = PyImport_AddModule("__main__"); // borrowed
			
										PyObject *globals = PyModule_GetDict(main); // borrowed
										PyObject *py_data = PyString_FromString(open_global_python_data1);
		
										PyDict_SetItemString(globals, "pythondata", py_data) ;
		
										Py_DECREF(py_data);

										PyObject *py_data1 = PyString_FromString(dis_x_str1);
		
										PyDict_SetItemString(globals, "pythondata1", py_data1);
		
		
										Py_DECREF(py_data1);


										PyObject *py_data2 = PyString_FromString(dis_y_str1);
		
										 
										PyDict_SetItemString(globals, "pythondata2", py_data2);
			
										Py_DECREF(py_data2);


														PyRun_SimpleString("import ast\n"
													"from shapely.geometry import Polygon, MultiPolygon\n"
													"from shapely.geometry import *\n"
													"from shapely.ops import cascaded_union\n"
													"Multipo = pythondata\n"
													"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
													"Multipo = Multipo.replace(')))','))')\n"
													"Multipo = Multipo.replace(', ((','split[(')\n"
													"Multipo = Multipo.replace('))',')]')\n"
													"Multipo = Multipo.replace('), (',')],[(')\n"
													"Multipo = Multipo.replace(', ','),(')\n"
													"Multipo = Multipo.replace(' ',',')\n"
													"Multipo = Multipo.split('split')\n"
													"s = []\n"
													"for i in Multipo:\n"
													"	a = i.split('],[')\n"
													"	if len(a) >=2:\n"
													"		i = i.replace('],[','],[[',1)\n"
													"		i = '[' + i + ']]'\n"
													"		i = ast.literal_eval(i)\n"
													"		m = []\n"
													"		n = []\n"
													"		o = []\n"
													"		for j in i[0]:\n"
													"			k = j[0]+float(pythondata1)\n"
													"			l = j[1]+float(pythondata2)\n"
													"			m.append((k,l))\n"
													"		for a in i[1]:\n"
													"			for b in a:\n"
													"				k = b[0]+float(pythondata1)\n"
													"				l = b[1]+float(pythondata2)\n"
													"				o.append((k,l))\n"
													"			n.append(o)\n"
													"		s.append(Polygon(m,n).buffer(0))\n"
													"	else:\n"
													"		i = ast.literal_eval(i)\n"
													"		m = []\n"
													"		for j in i:\n"
													"			k = j[0]+float(pythondata1)\n"
													"			l = j[1]+float(pythondata2)\n"
													"			m.append((k,l))\n"
													"		s.append(Polygon(m).buffer(0))\n"
													"C = cascaded_union(s)\n"
													"C1 = str(C)\n");


									PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
									PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
									PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
									string changed_val = PyString_AsString(eraserera);

									open_global_python_data = changed_val;
									}
									//}

					image_status=1;
					get_property(changed_item,n);
					image_status=0;
					//create_xml_for_path(erased_value);
				}// CURVE CHEEK ENDS 


			}		
				  }
		  else if(move_type=="down")
		  {
		  	yy=yy+2;

			if(open_node_name_curve ==0)
			{
				if(image_status==1)  // DRAGGING EVENT 
							{


							std::vector<std::string>split_x_y;  
							std::vector<std::string>combined_x_y; 
							global_x_diff=0;
							global_y_diff=+2;


							my_str1_tag = "";

							my_str1_tag = open_global_data;

							std::string delimiter = ",";
							std::string storestring="";


							 string strvalue1;
							 string strvalue2;
							 stringstream stream(my_str1_tag);
							 while( getline(stream, strvalue1, ' ') )
								 split_x_y.push_back(strvalue1);



							 string dis_x_str;
							 string dis_y_str;

							float dis_x_int;
							float dis_y_int;
							int a_size=split_x_y.size();


								for (int g=0; g<split_x_y.size(); g++)
								{
								  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
									{
									combined_x_y.push_back("Z");
									break;
									//g = g++;
									}
								  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
									{
									combined_x_y.push_back(split_x_y[g]);
									g=g++;
									}

								if(split_x_y[g]=="M" || split_x_y[g]== "L")
								   {
										if(split_x_y[g]=="M")
										{
										combined_x_y.push_back(split_x_y[g]);
										g = g++;
										}
									   else	if(split_x_y[g]=="L")
										{
										combined_x_y.push_back(split_x_y[g]);
										g = g++;
										}
										dis_x_str =split_x_y[g];
									 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
										dis_x_int = dis_x_int + global_x_diff;
										dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
										combined_x_y.push_back(dis_x_str);


										g = g++;
										dis_y_str =split_x_y[g];
										dis_y_int =boost::lexical_cast<float>(dis_y_str);
										dis_y_int= dis_y_int + global_y_diff;
										dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
										combined_x_y.push_back(dis_y_str);			
									}   

								}
								my_str1_tag="";
								for (int g=0; g<combined_x_y.size(); g++)
								{
								 if(g==0)
									 my_str1_tag = combined_x_y[g] ;
								else
									 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
								}
								// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
								//come_from_line_change1 = 1;
								open_global_data =  my_str1_tag;

								//open_glob_dat = open_global_data;



								string open_global_python_data_for_check = open_global_python_data.substr(0,6);

								if(open_global_python_data_for_check=="MULTIP")
								{
								string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

								string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

								Glib::locale_from_utf8(open_global_python_data);
								Glib::locale_from_utf8(dis_x_str_str);
								Glib::locale_from_utf8(dis_y_str_str);

								const char *open_global_python_data1 = open_global_python_data.c_str();
								const char *dis_x_str1 = dis_x_str_str.c_str();
								const char *dis_y_str1 = dis_y_str_str.c_str();

									PyObject *main = PyImport_AddModule("__main__"); // borrowed
									/*if (main == NULL)
										//error();
									return 0;*/
									PyObject *globals = PyModule_GetDict(main); // borrowed
									PyObject *py_data = PyString_FromString(open_global_python_data1);
									/*if (py_data == NULL)
									return 0;
									   //error();*/
									PyDict_SetItemString(globals, "pythondata", py_data) ;
									//return 0;
									   //error();
									Py_DECREF(py_data);

									PyObject *py_data1 = PyString_FromString(dis_x_str1);
									/*if (py_data1 == NULL)
									return 0;
									   //error();*/
									PyDict_SetItemString(globals, "pythondata1", py_data1);
									//return 0;*/
									   //error();
									Py_DECREF(py_data1);


									PyObject *py_data2 = PyString_FromString(dis_y_str1);
									/*if (py_data2 == NULL)
									return 0;
									   //error();*/
									PyDict_SetItemString(globals, "pythondata2", py_data2);
									//return 0;
									   //error();
									Py_DECREF(py_data2);


													PyRun_SimpleString("import ast\n"
												"from shapely.geometry import Polygon, MultiPolygon\n"
												"from shapely.geometry import *\n"
												"from shapely.ops import cascaded_union\n"
												"Multipo = pythondata\n"
												"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
												"Multipo = Multipo.replace(')))','))')\n"
												"Multipo = Multipo.replace(', ((','split[(')\n"
												"Multipo = Multipo.replace('))',')]')\n"
												"Multipo = Multipo.replace('), (',')],[(')\n"
												"Multipo = Multipo.replace(', ','),(')\n"
												"Multipo = Multipo.replace(' ',',')\n"
												"Multipo = Multipo.split('split')\n"
												"s = []\n"
												"for i in Multipo:\n"
												"	a = i.split('],[')\n"
												"	if len(a) >=2:\n"
												"		i = i.replace('],[','],[[',1)\n"
												"		i = '[' + i + ']]'\n"
												"		i = ast.literal_eval(i)\n"
												"		m = []\n"
												"		n = []\n"
												"		o = []\n"
												"		for j in i[0]:\n"
												"			k = j[0]+float(pythondata1)\n"
												"			l = j[1]+float(pythondata2)\n"
												"			m.append((k,l))\n"
												"		for a in i[1]:\n"
												"			for b in a:\n"
												"				k = b[0]+float(pythondata1)\n"
												"				l = b[1]+float(pythondata2)\n"
												"				o.append((k,l))\n"
												"			n.append(o)\n"
												"		s.append(Polygon(m,n).buffer(0))\n"
												"	else:\n"
												"		i = ast.literal_eval(i)\n"
												"		m = []\n"
												"		for j in i:\n"
												"			k = j[0]+float(pythondata1)\n"
												"			l = j[1]+float(pythondata2)\n"
												"			m.append((k,l))\n"
												"		s.append(Polygon(m).buffer(0))\n"
												"C = cascaded_union(s)\n"
												"C1 = str(C)\n");


								PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
								PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
								PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
								string changed_val = PyString_AsString(eraserera);

								open_global_python_data = changed_val;
								}
								//}
							Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(n);
							imgg->set_property("clip_path", Glib::ustring(open_global_data));

						// 	imgg->set_property("x",xx);
				//		  	imgg->set_property("y",yy);	

				get_property(imgg,n);
					image_status = 0;


							}		

				else
				{

				std::vector<std::string>split_x_y;  
				std::vector<std::string>combined_x_y; 
				global_x_diff=0;
				global_y_diff=+2;


				my_str1_tag = "";

				my_str1_tag = open_global_data;

				std::string delimiter = ",";
				std::string storestring="";


				 string strvalue1;
				 string strvalue2;
				 stringstream stream(my_str1_tag);
				 while( getline(stream, strvalue1, ' ') )
					 split_x_y.push_back(strvalue1);



				 string dis_x_str;
				 string dis_y_str;

				float dis_x_int;
				float dis_y_int;
				int a_size=split_x_y.size();


					for (int g=0; g<split_x_y.size(); g++)
					{
					  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
						{
						combined_x_y.push_back("Z");
						break;
						//g = g++;
						}
					  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
						{
						combined_x_y.push_back(split_x_y[g]);
						g=g++;
						}

					if(split_x_y[g]=="M" || split_x_y[g]== "L")
					   {
							if(split_x_y[g]=="M")
							{
							combined_x_y.push_back(split_x_y[g]);
							g = g++;
							}
						   else	if(split_x_y[g]=="L")
							{
							combined_x_y.push_back(split_x_y[g]);
							g = g++;
							}
							dis_x_str =split_x_y[g];
						 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
							dis_x_int = dis_x_int + global_x_diff;
							dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
							combined_x_y.push_back(dis_x_str);


							g = g++;
							dis_y_str =split_x_y[g];
							dis_y_int =boost::lexical_cast<float>(dis_y_str);
							dis_y_int= dis_y_int + global_y_diff;
							dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
							combined_x_y.push_back(dis_y_str);			
						}   

					}
					my_str1_tag="";
					for (int g=0; g<combined_x_y.size(); g++)
					{
					 if(g==0)
						 my_str1_tag = combined_x_y[g] ;
					else
						 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
					}
					// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
					//come_from_line_change1 = 1;
					open_global_data =  my_str1_tag;

					//open_glob_dat = open_global_data;



					string open_global_python_data_for_check = open_global_python_data.substr(0,6);

					if(open_global_python_data_for_check=="MULTIP")
					{
					string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

					string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

					Glib::locale_from_utf8(open_global_python_data);
					Glib::locale_from_utf8(dis_x_str_str);
					Glib::locale_from_utf8(dis_y_str_str);

					const char *open_global_python_data1 = open_global_python_data.c_str();
					const char *dis_x_str1 = dis_x_str_str.c_str();
					const char *dis_y_str1 = dis_y_str_str.c_str();

						PyObject *main = PyImport_AddModule("__main__"); // borrowed

						PyObject *globals = PyModule_GetDict(main); // borrowed
						PyObject *py_data = PyString_FromString(open_global_python_data1);

						PyDict_SetItemString(globals, "pythondata", py_data) ;

						Py_DECREF(py_data);

						PyObject *py_data1 = PyString_FromString(dis_x_str1);

						PyDict_SetItemString(globals, "pythondata1", py_data1);


						Py_DECREF(py_data1);


						PyObject *py_data2 = PyString_FromString(dis_y_str1);

						 
						PyDict_SetItemString(globals, "pythondata2", py_data2);

						Py_DECREF(py_data2);


										PyRun_SimpleString("import ast\n"
									"from shapely.geometry import Polygon, MultiPolygon\n"
									"from shapely.geometry import *\n"
									"from shapely.ops import cascaded_union\n"
									"Multipo = pythondata\n"
									"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
									"Multipo = Multipo.replace(')))','))')\n"
									"Multipo = Multipo.replace(', ((','split[(')\n"
									"Multipo = Multipo.replace('))',')]')\n"
									"Multipo = Multipo.replace('), (',')],[(')\n"
									"Multipo = Multipo.replace(', ','),(')\n"
									"Multipo = Multipo.replace(' ',',')\n"
									"Multipo = Multipo.split('split')\n"
									"s = []\n"
									"for i in Multipo:\n"
									"	a = i.split('],[')\n"
									"	if len(a) >=2:\n"
									"		i = i.replace('],[','],[[',1)\n"
									"		i = '[' + i + ']]'\n"
									"		i = ast.literal_eval(i)\n"
									"		m = []\n"
									"		n = []\n"
									"		o = []\n"
									"		for j in i[0]:\n"
									"			k = j[0]+float(pythondata1)\n"
									"			l = j[1]+float(pythondata2)\n"
									"			m.append((k,l))\n"
									"		for a in i[1]:\n"
									"			for b in a:\n"
									"				k = b[0]+float(pythondata1)\n"
									"				l = b[1]+float(pythondata2)\n"
									"				o.append((k,l))\n"
									"			n.append(o)\n"
									"		s.append(Polygon(m,n).buffer(0))\n"
									"	else:\n"
									"		i = ast.literal_eval(i)\n"
									"		m = []\n"
									"		for j in i:\n"
									"			k = j[0]+float(pythondata1)\n"
									"			l = j[1]+float(pythondata2)\n"
									"			m.append((k,l))\n"
									"		s.append(Polygon(m).buffer(0))\n"
									"C = cascaded_union(s)\n"
									"C1 = str(C)\n");


					PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
					PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
					PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
					string changed_val = PyString_AsString(eraserera);

					open_global_python_data = changed_val;
					}
								//}	

				image_status=1;
				get_property(changed_item,n);
				image_status=0;
				//create_xml_for_path(erased_value);
				}// CURVE CHECK ENDS 
			}



	  }
	  open_node_name_curve = 0;
      changed_item->set_property("x",xx);
      changed_item->set_property("y",yy);
      }
      //If the child is in group, should pop all values at each release event //code starts here
      int child_no_size=grouped_child_no.size();
      for(int i=0; i<child_no_size; i++)
      {
      grouped_child_no.pop_back();
      group_xx.pop_back();
      group_yy.pop_back();
      group_end_xx.pop_back();
      group_end_yy.pop_back();
      }
    }	
    else 	
    {

      changed_item=root->get_child(changed_item_num);
      xx=changed_item->property_x();	 
      yy=changed_item->property_y();
      ww=changed_item->property_width();
      hh=changed_item->property_height();

std::string test = "<Kalanjiyam> <Scene> "+xml_scene_overall_tag[changed_item_num-1]+" </Scene> </Kalanjiyam>";
				
							  const std::string input_xml = test;
							  vector<char> xml_copy(input_xml.begin(), input_xml.end());
							  xml_copy.push_back('\0');
							  xml_document<> doc;
							  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
							  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
							  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
							  xml_node<> * abc; 
							  while (Scene != NULL )
							  {
								for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
								{
								  for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
								  {
									  const char * node_name = abc->name();
									  const char * node_value = abc->value();		
									  open_node_name = node_name;
									  open_node_value = node_value;
									  const char * attribute_name = attribute->name();	
									  const char * attribute_value = attribute->value();	
	
											
												count_for_my_str1=0;
											if (strcmp(open_node_name, "Text") == 0)
											{
												open_node_name_curve = 1;
											}
										   if (strcmp(open_node_name, "Path") == 0)
											{
												 Glib::ustring path_val;
												 path_val = open_node_value;
												 path_val=""+path_val+"";
											   
												 if(path_val==" Curve ")
												 {
														open_node_name_curve = 1;
												 }
											}

												if (strcmp(attribute_name, "data") == 0) 
												{
													open_global_data = attribute_value;
													image_status=0;
												}
												if (strcmp(attribute_name, "py_data") == 0) 
												{
													open_global_python_data = attribute_value;
													image_status=0;
												}
										  
									}
							  }
							Scene = Scene->next_sibling("Scene");	



						}




		for(int g=0;g<for_image_indentification.size();g++)//singleasdf
		{
		  int counts=1;
		  string get_image_number = for_image_indentification[g] ;
		  Glib::ustring image_number;
		  Glib::ustring child_number_for_image;
		  tokenizer<> tok(get_image_number);
		  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		  {
			if(counts==1)
			image_number =*beg;
			else
			child_number_for_image=*beg;
			counts++;
		   }	
			   child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
			 int  image_int = boost::lexical_cast<int>(image_number);

		   if(changed_item_num==child_number_for_image_int)
				{
					image_status=1;

				}
	}



  if(move_type=="left")		
  {
      	xx=xx-2;//asdf5
	if(open_node_name_curve==0)
	{
		if(image_status==1)  // DRAGGING EVENT 
		{


			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=-2;
			global_y_diff=0;
		

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}
			Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(child_number_for_image_int);
			imgg->set_property("clip_path", Glib::ustring(open_global_data));

		// 	imgg->set_property("x",xx);
//		  	imgg->set_property("y",yy);	

get_property(imgg,child_number_for_image_int);

	image_status = 0;

			}	

else
{

			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=-2;
			global_y_diff=0;
		

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}

		//changed_item->set_property("open_global_data",open_global_data);
		image_status=1;
		get_property(changed_item,changed_item_num);
		}// CUREV ENDS 
		//create_xml_for_path(erased_value);


		}
		
	}
	else if(move_type=="right")
	{
  	xx=xx+2;
	if(open_node_name_curve==0)

	{
			if(image_status==1)  // DRAGGING EVENT 
			{
				std::vector<std::string>split_x_y;  
				std::vector<std::string>combined_x_y; 
				global_x_diff=+2;
				global_y_diff=0;

				my_str1_tag = "";

				my_str1_tag = open_global_data;

				std::string delimiter = ",";
				std::string storestring="";


				 string strvalue1;
				 string strvalue2;
				 stringstream stream(my_str1_tag);
				 while( getline(stream, strvalue1, ' ') )
					 split_x_y.push_back(strvalue1);



				 string dis_x_str;
				 string dis_y_str;

				float dis_x_int;
				float dis_y_int;
				int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;


				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}
			Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(child_number_for_image_int);
			imgg->set_property("clip_path", Glib::ustring(open_global_data));

		// 	imgg->set_property("x",xx);
//		  	imgg->set_property("y",yy);	
			get_property(imgg,child_number_for_image_int);

			image_status = 0;

	}	
	else
	{

			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=+2;
			global_y_diff=0;
		

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}



		//changed_item->set_property("open_global_data",open_global_data);
		image_status=1;
		get_property(changed_item,changed_item_num);
		//create_xml_for_path(erased_value);
		}//CURVE ENDS 


		}
	
	}
	else if(move_type=="up")
	  {
      	yy=yy-2;

	if(open_node_name_curve==0)
	{

		if(image_status==1)  // DRAGGING EVENT 
			{


			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=0;
			global_y_diff=-2;
		

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}
			Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(child_number_for_image_int);
			imgg->set_property("clip_path", Glib::ustring(open_global_data));

		// 	imgg->set_property("x",xx);
//		  	imgg->set_property("y",yy);	
			get_property(imgg,child_number_for_image_int);

			image_status = 0;

			}		

		else
		{

			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=0;
			global_y_diff=-2;
		

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}

		//changed_item->set_property("open_global_data",open_global_data);
		image_status=1;
		get_property(changed_item,changed_item_num);
		image_status=0;
		}//CUREVE  ENDS 
		//create_xml_for_path(erased_value);
		}

  }
  else if(move_type=="down")
	{
      yy=yy+2;
	if(open_node_name_curve==0)
	{
	if(image_status==1)  // DRAGGING EVENT 
		{


			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=0;
			global_y_diff=+2;
		

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}
			Glib::RefPtr<Goocanvas::Item> imgg = root->get_child(child_number_for_image_int);
			imgg->set_property("clip_path", Glib::ustring(open_global_data));


			get_property(imgg,child_number_for_image_int);

			image_status=0;

			}		
		else
		{


			std::vector<std::string>split_x_y;  
			std::vector<std::string>combined_x_y; 
			global_x_diff=0;
			global_y_diff=+2;
		

			my_str1_tag = "";

			my_str1_tag = open_global_data;

			std::string delimiter = ",";
			std::string storestring="";


			 string strvalue1;
			 string strvalue2;
			 stringstream stream(my_str1_tag);
			 while( getline(stream, strvalue1, ' ') )
				 split_x_y.push_back(strvalue1);



			 string dis_x_str;
			 string dis_y_str;

			float dis_x_int;
			float dis_y_int;
			int a_size=split_x_y.size();


				for (int g=0; g<split_x_y.size(); g++)
				{
				  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
					{
					combined_x_y.push_back("Z");
					break;
					//g = g++;
					}
				  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
					{
					combined_x_y.push_back(split_x_y[g]);
					g=g++;
					}

				if(split_x_y[g]=="M" || split_x_y[g]== "L")
				   {
						if(split_x_y[g]=="M")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
					   else	if(split_x_y[g]=="L")
						{
						combined_x_y.push_back(split_x_y[g]);
						g = g++;
						}
						dis_x_str =split_x_y[g];
					 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
						dis_x_int = dis_x_int + global_x_diff;
						dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
						combined_x_y.push_back(dis_x_str);


						g = g++;
						dis_y_str =split_x_y[g];
						dis_y_int =boost::lexical_cast<float>(dis_y_str);
						dis_y_int= dis_y_int + global_y_diff;
						dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
						combined_x_y.push_back(dis_y_str);			
					}   

				}
				my_str1_tag="";
				for (int g=0; g<combined_x_y.size(); g++)
				{
				 if(g==0)
					 my_str1_tag = combined_x_y[g] ;
				else
					 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
				}
				// my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
				//come_from_line_change1 = 1;
				open_global_data =  my_str1_tag;

				//open_glob_dat = open_global_data;



				string open_global_python_data_for_check = open_global_python_data.substr(0,6);

				if(open_global_python_data_for_check=="MULTIP")
				{
				string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

				string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

				Glib::locale_from_utf8(open_global_python_data);
				Glib::locale_from_utf8(dis_x_str_str);
				Glib::locale_from_utf8(dis_y_str_str);

				const char *open_global_python_data1 = open_global_python_data.c_str();
				const char *dis_x_str1 = dis_x_str_str.c_str();
				const char *dis_y_str1 = dis_y_str_str.c_str();

					PyObject *main = PyImport_AddModule("__main__"); // borrowed
					/*if (main == NULL)
						//error();
					return 0;*/
					PyObject *globals = PyModule_GetDict(main); // borrowed
					PyObject *py_data = PyString_FromString(open_global_python_data1);
					/*if (py_data == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata", py_data) ;
					//return 0;
					   //error();
					Py_DECREF(py_data);

					PyObject *py_data1 = PyString_FromString(dis_x_str1);
					/*if (py_data1 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata1", py_data1);
					//return 0;*/
					   //error();
					Py_DECREF(py_data1);


					PyObject *py_data2 = PyString_FromString(dis_y_str1);
					/*if (py_data2 == NULL)
					return 0;
					   //error();*/
					PyDict_SetItemString(globals, "pythondata2", py_data2);
					//return 0;
					   //error();
					Py_DECREF(py_data2);


									PyRun_SimpleString("import ast\n"
								"from shapely.geometry import Polygon, MultiPolygon\n"
								"from shapely.geometry import *\n"
								"from shapely.ops import cascaded_union\n"
								"Multipo = pythondata\n"
								"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
								"Multipo = Multipo.replace(')))','))')\n"
								"Multipo = Multipo.replace(', ((','split[(')\n"
								"Multipo = Multipo.replace('))',')]')\n"
								"Multipo = Multipo.replace('), (',')],[(')\n"
								"Multipo = Multipo.replace(', ','),(')\n"
								"Multipo = Multipo.replace(' ',',')\n"
								"Multipo = Multipo.split('split')\n"
								"s = []\n"
								"for i in Multipo:\n"
								"	a = i.split('],[')\n"
								"	if len(a) >=2:\n"
								"		i = i.replace('],[','],[[',1)\n"
								"		i = '[' + i + ']]'\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		n = []\n"
								"		o = []\n"
								"		for j in i[0]:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		for a in i[1]:\n"
								"			for b in a:\n"
								"				k = b[0]+float(pythondata1)\n"
								"				l = b[1]+float(pythondata2)\n"
								"				o.append((k,l))\n"
								"			n.append(o)\n"
								"		s.append(Polygon(m,n).buffer(0))\n"
								"	else:\n"
								"		i = ast.literal_eval(i)\n"
								"		m = []\n"
								"		for j in i:\n"
								"			k = j[0]+float(pythondata1)\n"
								"			l = j[1]+float(pythondata2)\n"
								"			m.append((k,l))\n"
								"		s.append(Polygon(m).buffer(0))\n"
								"C = cascaded_union(s)\n"
								"C1 = str(C)\n");


				PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
				PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
				PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
				string changed_val = PyString_AsString(eraserera);

				open_global_python_data = changed_val;
				}
				//}



			//changed_item->set_property("open_global_data",open_global_data);
			image_status=1;
			get_property(changed_item,changed_item_num);
			image_status=0;
			}// CUREV ENEDS 
			//create_xml_for_path(erased_value);


		}

	  }

      control_points_remove();

      Glib::RefPtr<Goocanvas::Rect> rect1 ;
      rect1 = Goocanvas::Rect::create(xx,yy,ww,hh); 
      #ifdef GLIBMM_PROPERTIES_ENABLED
      rect1->property_stroke_color() = "red" ;
      rect1->property_line_width() = 0.5 ;
      #endif
      root->add_child(rect1);
      child_num=child_num+1;

      first(xx-16,yy-16,xx,yy);
      second(xx+ww+16,yy-16,xx+ww,yy);
      third(xx-16,yy+hh+16,xx,yy+hh);
      fourth(xx+ww,yy+hh,xx+ww+16,yy+hh+16);
      fifth(xx+ww/2,yy-22,xx+ww/2,yy);
      sixth(xx+ww/2,yy+hh+22,xx+ww/2,yy+hh);
      seventh(xx-22,yy+hh/2,xx,yy+hh/2);
      eighth(xx+ww,yy+hh/2,xx+ww+22,yy+hh/2);

      changed_item->set_property("x",xx);
      changed_item->set_property("y",yy);
      xx1=xx;      yy1=yy;
      ww1=ww;      hh1=hh;
	changed_item_num=root->find_child(changed_item);
    }
  }	

image_status=0;
open_node_name_curve==0;



global_x_diff=0;
global_y_diff=0;
split_x_y.clear();  
combined_x_y.clear(); 

}

void KalanjiyamWindow::multi_selected_objects_delete(int a)
{
  std::vector<std::string>changed_image_vector_values;
  int image_delete_flag=0;
  int image_vector_position;
  int delete_image_vector_poition;
  int current_clicked_item_new;
  int current_clicked_next_item;
  int current_clicked_next_item1;
  std::string image_vector_position_str;
  std::string image_vector_position_value;
  std::string new_image_vector_position_value;

	Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
	group_child_buffer_no.clear();
    //To check the clicked item is a single item or a grouped item..?
    //If it is grouped item to store the xx, yy, ww, hh values //Code starts here
    int single_child_same_no=-1;
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="S")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
        if(child_in_total_list==a)
        {
        single_child_same_no=i;
        break;
        }	
        }
      }
    }
    int group_child_same_no=-1;
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="G")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          if(child_in_total_list==single_child_same_no)
          {
          group_child_same_no=i;
          }	
        }
      }
    }
    if(group_child_same_no!=-1)		//If the clicked item is a grouped item
    {
      //To remove the child from the vector if there is //Code starts here
      Glib::ustring int_to_string_value;
      std::string total_arr;
      int removing_child;
      //code for xml scene vector starts
      tokenizer<> toki(group_child_total_list[group_child_same_no]);
      int m=1;
      for(tokenizer<>::iterator beg=toki.begin(); beg!=toki.end();++beg)
      {
        if(m!=1)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="S")
              {	
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  std::stringstream str(*beg);
                  str>>removing_child;
                  group_child_buffer_no.push_back(removing_child);
                  }
                  l++;	
                }
              }
            }
          }
        }
        m++;
      }
      //code for xml scene vector ends
      tokenizer<> tok(group_child_total_list[group_child_same_no]);
      int k=1;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(k!=1)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="S")
              {	
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  std::stringstream str(*beg);
                  str>>removing_child;
                  root->remove_child(removing_child); //Which item has to be removed from root.
				 /*SARU*/


				for(int g=0;g<for_image_indentification.size();g++)
				{
				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;
				  tokenizer<> tok(get_image_number);
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	
					 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);


				   if(removing_child==child_number_for_image_int)
						{
							delete_image_vector_poition = g;
							image_delete_flag = 1;
						}

					if(child_number_for_image_int>removing_child)
						{
							number_for_image = image_int;
							image_vector_position = g;
							image_vector_position_str = boost::lexical_cast<std::string>(g);
							current_clicked_item_new  = child_number_for_image_int-1;
							image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
							new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
							changed_image_vector_values.push_back(new_image_vector_position_value);
						}		
				}
				for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];


					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
					 {
						token = changed_image_vector_values[g] .substr(0, pos);
						changed_image_vector_values[g] .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=changed_image_vector_values[g];

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
				 }	

				changed_image_vector_values.clear();
				
				if(image_delete_flag==1)
					{
						for_image_indentification.erase(for_image_indentification.begin()+delete_image_vector_poition);	
						image_delete_flag = 0;
					}


				/*SARU*/

                  child_num=child_num-1;	
                  }
                  l++;	
                }
              }
              for(int j=0; j<group_child_total_list.size(); j++)
              {
              tokenizer<> tok(group_child_total_list[j]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="S")
              {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
              if(l!=1)
              {
              int child_in_total_list1;
              std::stringstream str(*beg);
              str>>child_in_total_list1;
              if(child_in_total_list1>=removing_child)
              {
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1-1);
              total_arr="S,"+int_to_string_value;
              group_child_total_list[j]=total_arr;			
              }
              }
              l++;
              }
              }
              }
              group_child_total_list[i]="Empty";
            }
          }
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="G")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list2;
                  std::stringstream str(*beg);
                  str>>child_in_total_list2;
                  if(child_in_total_list==child_in_total_list2 && j!=group_child_same_no)
                  group_child_total_list[j]="Empty";
                }
                l++;
              }
            }
          }
        }
        k++;
      }
      group_child_total_list[group_child_same_no]="Empty";
      for(int i=group_child_total_list.size()-1; i>=0; i--)
      {
        if(group_child_total_list[i]=="Empty")
        {
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="G")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;		
                  if(child_in_total_list>=i)
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
                  else
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
                  if(l==2)
                  total_arr="G,"+int_to_string_value;
                  else
                  total_arr=total_arr+","+int_to_string_value;
                }
                l++;
              }
              group_child_total_list[j]=total_arr;
            }
          }
        }
      }
      group_child_total_list_buffer = group_child_total_list;
      group_child_total_list.erase(group_child_total_list.begin(),group_child_total_list.end());
      for(int i=0; i<group_child_total_list_buffer.size(); i++)
      {	
        if(group_child_total_list_buffer[i]!="Empty")
        {
        group_child_total_list.push_back(group_child_total_list_buffer[i]);
        }
      }
      group_child_total_list_buffer.erase(group_child_total_list_buffer.begin(),group_child_total_list_buffer.end());
      //code for xml scene vector starts			
      std::sort (group_child_buffer_no.begin(), group_child_buffer_no.end(), std::greater<double>());
      for(int i=0; i<group_child_buffer_no.size(); i++)
      {
        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+(group_child_buffer_no[i]-1));
      }
      group_child_buffer_no.clear();
      //code for xml scene vector ends			
    }
    else
    {
      xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+(a-1)); //code for xml scene vector starts
      Glib::ustring int_to_string_value;
      std::string total_arr;
      //To remove the child from the vector if there is //Code starts here
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==a)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      if(single_child_same_no!=-1)
      {
        for(int i=single_child_same_no; i<group_child_total_list.size()-1; i++)
        {
        group_child_total_list[i]=group_child_total_list[i+1];
        }
        group_child_total_list.pop_back();
        for(int i=0; i<group_child_total_list.size()-1; i++)
        {
          tokenizer<> tok(group_child_total_list[i]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="G")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list>=single_child_same_no)
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
              else
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
              if(l==2)
              total_arr="G,"+int_to_string_value;
              else
              total_arr=total_arr+","+int_to_string_value;
              group_child_total_list[i]=total_arr;			
              }
              l++;
            }
          }
        }
      }
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          int l=1;
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            if(l!=1)
            {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list>a)
              {
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
              total_arr="S,"+int_to_string_value;
              group_child_total_list[i]=total_arr;			
              }
            }
            l++;
          }
        }
      }
      //To remove the child from the vector if there is //Code ends here
      //To remove the child from the root //Code starts here
      root->remove_child(a); //Which item has to be removed.
	   /*SARU*/


		for(int g=0;g<for_image_indentification.size();g++)
		{
		  int counts=1;
		  string get_image_number = for_image_indentification[g] ;
		  Glib::ustring image_number;
		  Glib::ustring child_number_for_image;
		  tokenizer<> tok(get_image_number);
		  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		  {
			if(counts==1)
			image_number =*beg;
			else
			child_number_for_image=*beg;
			counts++;
		   }	
			 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
			 int  image_int = boost::lexical_cast<int>(image_number);


		   if(a==child_number_for_image_int)
				{
					delete_image_vector_poition = g;
					image_delete_flag = 1;
				}

			if(child_number_for_image_int>a)
				{
					number_for_image = image_int;
					image_vector_position = g;
					image_vector_position_str = boost::lexical_cast<std::string>(g);
					current_clicked_item_new  = child_number_for_image_int-1;
					image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
					new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
					changed_image_vector_values.push_back(new_image_vector_position_value);
				}		
		}
		for(int g=0;g<changed_image_vector_values.size();g++)
		{
		   string new_image_value =	changed_image_vector_values[g];


			 tokenizer<> tok(new_image_value);
			 int count=1;
			 Glib::ustring vector_no;
			 std::string image_no;
			 std::string item_no;
			 std::string delimiter = ",";
			 std::string storestring="";
			 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
			 {
			   if(count==1)
				   vector_no=*beg;
			   else 
				  storestring=storestring + *beg ;
				  count++;
			 }
			 int  vector_no_int = boost::lexical_cast<int>(vector_no);
			 size_t pos = 0;
			 std::string token;
			 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
			 {
				token = changed_image_vector_values[g] .substr(0, pos);
				changed_image_vector_values[g] .erase(0, pos + delimiter.length());
			 }
			image_no=token;
			item_no=changed_image_vector_values[g];

			new_image_vector_position_value = image_no + "," + item_no;
	 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
		 }	

		changed_image_vector_values.clear();
		
		if(image_delete_flag==1)
			{
				for_image_indentification.erase(for_image_indentification.begin()+delete_image_vector_poition);	
				image_delete_flag = 0;
			}

		/*SARU*/
      child_num=child_num-1;
      //To remove the child from the root	//Code ends here
    }
}
void KalanjiyamWindow::selected_objects_delete()
{
  open_global_python_data="";
  polyline_cnt_curve_cnt();
  current_clicked_item=changed_item_num;
  std::vector<std::string>changed_image_vector_values;
  int image_delete_flag=0;
  int image_vector_position;
  int delete_image_vector_poition;
  int current_clicked_item_new;
  int current_clicked_next_item;
  int current_clicked_next_item1;
  std::string image_vector_position_str;
  std::string image_vector_position_value;
  std::string new_image_vector_position_value;
  int child_number1;
  int delete_group_status = 0;
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  current_clicked_next_item1 = current_clicked_item;

if(group_child_no.size()>0)
{ 
//undo-redo-code-starts here
//undo-redo-code-starts here
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
int status=9;
int position=-1;
std::string str_val="MultiDeleteStarts";
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

std::sort (group_child_no.begin(), group_child_no.end(), std::greater<double>());
for(int i=0; i<group_child_no.size(); i++)
{
int grp_vec_val=group_child_no[i];
Glib::ustring tag_val=xml_scene_overall_tag[grp_vec_val-1];
undo_redo_tag_vector.push_back(tag_val);
undo_redo_child_number_vector.push_back(grp_vec_val);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}

str_val="GroupVectorValues";
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

group_child_buffer1_no.clear();
for(int i=0; i<group_child_no.size(); i++)
{
	int push_flag=0;
	int chi_val = group_child_no[i];
	for(int j=0; j<group_child_total_list.size(); j++)
	{
	  int check2=-1;
	  tokenizer<> tok(group_child_total_list[j]);
	  tokenizer<>::iterator beg=tok.begin();
	  if(*beg=="S")
	  {
		for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
		{
		  int child_in_total_list;
		  std::stringstream str(*beg);
		  str>>child_in_total_list;
		  if(child_in_total_list==chi_val)
		  {
			check2=j;
			int index_num=j;
			int check=-1;
			for(int w=0; w<group_child_buffer1_no.size(); w++)
			{
			  if(group_child_buffer1_no[w]==index_num)
			  {
				check=w;
				break;
			  }
			}
			if(check==-1)
			{
			group_child_buffer1_no.push_back(j);
			push_flag=1;
			}
			for(int k=0; k<group_child_total_list.size(); k++)
			{
			  tokenizer<> toki(group_child_total_list[k]);
			  tokenizer<>::iterator beg=toki.begin();
			  if(*beg=="G")
			  {
				for(tokenizer<>::iterator beg=toki.begin(); beg!=toki.end();++beg)
				{
			  	  int child_in_total_list;
				  std::stringstream str(*beg);
				  str>>child_in_total_list;
				  if(child_in_total_list==j)
				  {
					int index_num=k;
					int check1=-1;
					for(int l=0; l<group_child_buffer1_no.size(); l++)
					{
					  if(group_child_buffer1_no[l]==index_num)
					  {
						check1=l;
						break;
					  }
					}
					if(check1==-1)
					group_child_buffer1_no.push_back(k);
				  }
				}
			  }
			}
		  }
		}
	  }
	  if(check2!=-1)
	  break;
	}
	if(push_flag==0)
	{
	  Glib::ustring int_to_string_value;
	  std::string total_arr;
	  int grp_vec_val=0;
	  int_to_string_value = boost::lexical_cast<std::string>(group_child_no[i]);
      total_arr="S,"+int_to_string_value;
	  undo_redo_tag_vector.push_back(total_arr);
	  undo_redo_child_number_vector.push_back(grp_vec_val);
	  undo_redo_delete_status_vector.push_back(status);
	  undo_redo_position_vector.push_back(position);
	}
}
std::sort (group_child_buffer1_no.begin(), group_child_buffer1_no.end(), std::greater<double>());
for(int i=0; i<group_child_buffer1_no.size(); i++)
{
int grp_vec_val=group_child_buffer1_no[i];
Glib::ustring tag_val=group_child_total_list[grp_vec_val];
undo_redo_tag_vector.push_back(tag_val);
undo_redo_child_number_vector.push_back(grp_vec_val);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
}
group_child_buffer1_no.clear();
//undo-redo-code-ends here
//undo-redo-code-ends here

std::sort (group_child_no.begin(), group_child_no.end());
for(int j=0; j<group_child_no.size(); j++)
{
	int a = group_child_no[j];
if(a!=0)
{
    int single_child_same_no=-1;
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="S")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
        if(child_in_total_list==a)
        {
        single_child_same_no=i;
        break;
        }	
        }
      }
    }
    int group_child_same_no=-1;
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="G")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          if(child_in_total_list==single_child_same_no)
          {
          group_child_same_no=i;
          }	
        }
      }
    }
	if(group_child_same_no!=-1)
	{
	  group_child_buffer1_no.clear();
      tokenizer<> tok(group_child_total_list[group_child_same_no]);
      int k=1;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(k!=1)
        {
          int child_in_total_list, removing_child;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="S")
              {	
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                    std::stringstream str(*beg);
                    str>>removing_child;
					group_child_buffer1_no.push_back(removing_child);
				  }
				  l++;
				}
			  }
			}
		  }
		}
		k++;
	  }
	  std::sort (group_child_buffer1_no.begin(), group_child_buffer1_no.end(), std::greater<double>());
	  for(int l=0; l<group_child_buffer1_no.size(); l++)
	  {
	    for(int m=0; m<group_child_no.size(); m++)
		{
		  if(group_child_no[m]==group_child_buffer1_no[l])
		  {
			group_child_no[m]=0;
			for(int n=m+1; n<group_child_no.size(); n++)
			{
				if(group_child_no[n]!=0)
					group_child_no[n]=group_child_no[n]-1;
			}
			break;
		  }
		}
	  }
	  group_child_buffer1_no.clear();
	}
	else
	{
		for(int i=j+1; i<group_child_no.size(); i++)
		{
			if(group_child_no[i]!=0)
				group_child_no[i]=group_child_no[i]-1;
		}
	}
	multi_selected_objects_delete(a);
}
}
	selected_items_remove();
    move_var=0;
//undo-redo-code-starts here
//undo-redo-code-starts here
str_val="MultiDeleteEnds";
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
standing_position=undo_redo_tag_vector.size()-1;
//undo-redo-code-ends here
//undo-redo-code-ends here

}

  if(move_var>0 && group_child_no.size()==0)
  {
    //To check the clicked item is a single item or a grouped item..?
    //If it is grouped item to store the xx, yy, ww, hh values //Code starts here
    int single_child_same_no=-1;
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="S")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
        int child_in_total_list;
        std::stringstream str(*beg);
        str>>child_in_total_list;
        if(child_in_total_list==changed_item_num)
        {
        single_child_same_no=i;
        break;
        }	
        }
      }
    }
    int group_child_same_no=-1;
    for(int i=0; i<group_child_total_list.size(); i++)
    {
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="G")
      {
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          if(child_in_total_list==single_child_same_no)
          {
          group_child_same_no=i;
          }	
        }
      }
    }

//undo-redo-code-starts here
//undo-redo-code-starts here
if(undo_count>0)
{
  undo_redo_tag_vector.erase(undo_redo_tag_vector.begin()+standing_position+1,undo_redo_tag_vector.end());
  undo_redo_child_number_vector.erase(undo_redo_child_number_vector.begin()+standing_position+1,undo_redo_child_number_vector.end());
  undo_redo_delete_status_vector.erase(undo_redo_delete_status_vector.begin()+standing_position+1,undo_redo_delete_status_vector.end());
  undo_redo_position_vector.erase(undo_redo_position_vector.begin()+standing_position+1,undo_redo_position_vector.end());
  undo_count=0;
}
//undo-redo-code-ends here
//undo-redo-code-ends here

    if(group_child_same_no!=-1)		//If the clicked item is a grouped item
    {
//undo-redo-code-starts here
//undo-redo-code-starts here
int status=6;
int position=-1;

std::string str_val="GroupDeleteStarts";
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);

group_child_no.push_back(group_child_same_no);
tokenizer<> token(group_child_total_list[group_child_same_no]);
int a=1;
for(tokenizer<>::iterator beg=token.begin(); beg!=token.end();++beg)
{
  if(a!=1)
  {
    int child_in_total_list;
    std::stringstream str(*beg);
    str>>child_in_total_list;
	group_child_no.push_back(child_in_total_list);

	for(int i=0; i<group_child_same_no; i++)
	{
      tokenizer<> tok(group_child_total_list[i]);
      tokenizer<>::iterator beg=tok.begin();
      if(*beg=="G")
      {
        int l=1;
        for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
        {
          if(l!=1)
          {
            int child_in_total_list2;
            std::stringstream str(*beg);
            str>>child_in_total_list2;
            if(child_in_total_list==child_in_total_list2)
			{
			  int same_no=-1;
			  for(int j=0; j<group_child_no.size(); j++)
			  {
				if(group_child_no[j]==i)
				{
				  same_no=i;
				  break;
				}
			  }
			  if(same_no==-1)
                group_child_no.push_back(i);
			}
          }
          l++;
        }
      }
	}
  }
  a++;
}
std::sort (group_child_no.begin(), group_child_no.end(), std::greater<double>());
for(int i=0; i<group_child_no.size(); i++)
{
  int index_num=group_child_no[i];
  undo_redo_tag_vector.push_back(group_child_total_list[index_num]);
  undo_redo_child_number_vector.push_back(index_num);
  undo_redo_delete_status_vector.push_back(status);
  undo_redo_position_vector.push_back(position);
}
group_child_no.clear();

str_val="TagValues";
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
//undo-redo-code-ends here
//undo-redo-code-ends here


      //To remove the child from the root //Code starts here
      control_points_remove();
      move_var=0;
      //To remove the child from the root	//Code ends here

      //To remove the child from the vector if there is //Code starts here
      Glib::ustring int_to_string_value;
      std::string total_arr;
      int removing_child;
      //code for xml scene vector starts
      tokenizer<> toki(group_child_total_list[group_child_same_no]);
      int m=1;
      for(tokenizer<>::iterator beg=toki.begin(); beg!=toki.end();++beg)
      {
        if(m!=1)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="S")
              {	
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  std::stringstream str(*beg);
                  str>>removing_child;
                  group_child_no.push_back(removing_child);
                  }
                  l++;	
                }
              }
            }
          }
        }
        m++;
      }
      //code for xml scene vector ends
      tokenizer<> tok(group_child_total_list[group_child_same_no]);
      int k=1;
      for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
      {
        if(k!=1)
        {
          int child_in_total_list;
          std::stringstream str(*beg);
          str>>child_in_total_list;
          for(int i=0; i<group_child_total_list.size(); i++)
          {
            if(i==child_in_total_list)
            {
              tokenizer<> tok(group_child_total_list[i]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="S")
              {	
                int l=1;
                for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
                {
                  if(l!=1)
                  {
                  std::stringstream str(*beg);
                  str>>removing_child;
                  root->remove_child(removing_child); //Which item has to be removed from root.
				  /*SARU*/


				for(int g=0;g<for_image_indentification.size();g++)
				{
				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;
				  tokenizer<> tok(get_image_number);
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	
					 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);


				   if(removing_child==child_number_for_image_int)
						{
							delete_image_vector_poition = g;
							image_delete_flag = 1;
						}

					if(child_number_for_image_int>removing_child)
						{
							number_for_image = image_int;
							image_vector_position = g;
							image_vector_position_str = boost::lexical_cast<std::string>(g);
							current_clicked_item_new  = child_number_for_image_int-1;
							image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
							new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
							changed_image_vector_values.push_back(new_image_vector_position_value);
						}		
				}
				for(int g=0;g<changed_image_vector_values.size();g++)
				{
				   string new_image_value =	changed_image_vector_values[g];


					 tokenizer<> tok(new_image_value);
					 int count=1;
					 Glib::ustring vector_no;
					 std::string image_no;
					 std::string item_no;
					 std::string delimiter = ",";
					 std::string storestring="";
					 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
					 {
					   if(count==1)
						   vector_no=*beg;
					   else 
						  storestring=storestring + *beg ;
						  count++;
					 }
					 int  vector_no_int = boost::lexical_cast<int>(vector_no);
					 size_t pos = 0;
					 std::string token;
					 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
					 {
						token = changed_image_vector_values[g] .substr(0, pos);
						changed_image_vector_values[g] .erase(0, pos + delimiter.length());
					 }
					image_no=token;
					item_no=changed_image_vector_values[g];

					new_image_vector_position_value = image_no + "," + item_no;
			 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
				 }	

				changed_image_vector_values.clear();
				
				if(image_delete_flag==1)
					{
						for_image_indentification.erase(for_image_indentification.begin()+delete_image_vector_poition);	
						image_delete_flag = 0;
					}


				/*SARU*/

                  child_num=child_num-1;	
                  }
                  l++;	
                }
              }
              for(int j=0; j<group_child_total_list.size(); j++)
              {
              tokenizer<> tok(group_child_total_list[j]);
              tokenizer<>::iterator beg=tok.begin();
              if(*beg=="S")
              {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
              if(l!=1)
              {
              int child_in_total_list1;
              std::stringstream str(*beg);
              str>>child_in_total_list1;
              if(child_in_total_list1>=removing_child)
              {
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list1-1);
              total_arr="S,"+int_to_string_value;
              group_child_total_list[j]=total_arr;			
              }
              }
              l++;
              }
              }
              }
              group_child_total_list[i]="Empty";
            }
          }
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="G")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list2;
                  std::stringstream str(*beg);
                  str>>child_in_total_list2;
                  if(child_in_total_list==child_in_total_list2 && j!=group_child_same_no)
                  group_child_total_list[j]="Empty";
                }
                l++;
              }
            }
          }
        }
        k++;
      }
      group_child_total_list[group_child_same_no]="Empty";
      for(int i=group_child_total_list.size()-1; i>=0; i--)
      {
        if(group_child_total_list[i]=="Empty")
        {
          for(int j=0; j<group_child_total_list.size(); j++)
          {
            tokenizer<> tok(group_child_total_list[j]);
            tokenizer<>::iterator beg=tok.begin();
            if(*beg=="G")
            {
              int l=1;
              for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
              {
                if(l!=1)
                {
                  int child_in_total_list;
                  std::stringstream str(*beg);
                  str>>child_in_total_list;		
                  if(child_in_total_list>=i)
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
                  else
                  int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
                  if(l==2)
                  total_arr="G,"+int_to_string_value;
                  else
                  total_arr=total_arr+","+int_to_string_value;
                  //group_child_total_list[j]=total_arr;			
                }
                l++;
              }
              group_child_total_list[j]=total_arr;
            }
          }
        }
      }
      group_child_total_list_buffer = group_child_total_list;
      group_child_total_list.erase(group_child_total_list.begin(),group_child_total_list.end());
      for(int i=0; i<group_child_total_list_buffer.size(); i++)
      {	
        if(group_child_total_list_buffer[i]!="Empty")
        {
        group_child_total_list.push_back(group_child_total_list_buffer[i]);
        }
      }
      group_child_total_list_buffer.erase(group_child_total_list_buffer.begin(),group_child_total_list_buffer.end());
      //code for xml scene vector starts			
      std::sort (group_child_no.begin(), group_child_no.end(), std::greater<double>());
      for(int i=0; i<group_child_no.size(); i++)
      {
delete_group_status = 1;
//undo-redo-code-starts here
//undo-redo-code-starts here
int grp_vec_val=group_child_no[i];
Glib::ustring tag_val=xml_scene_overall_tag[grp_vec_val-1];
undo_redo_tag_vector.push_back(tag_val);
undo_redo_child_number_vector.push_back(grp_vec_val);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
//undo-redo-code-ends here
//undo-redo-code-ends here

        xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+(group_child_no[i]-1));
      }
      group_child_no.clear();
      //code for xml scene vector ends			

//undo-redo-code-starts here
//undo-redo-code-starts here
str_val="GroupDeleteEnds";
undo_redo_tag_vector.push_back(str_val);
undo_redo_child_number_vector.push_back(position);
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
standing_position=undo_redo_tag_vector.size()-1;
//undo-redo-code-ends here
//undo-redo-code-ends here

    }
    else
    {
//undo-redo-code-starts here
//undo-redo-code-starts here
Glib::ustring xml_tag = xml_scene_overall_tag[changed_item_num-1];
undo_redo_tag_vector.push_back(xml_tag);
undo_redo_child_number_vector.push_back(changed_item_num);
int status=2;
int position=-1;
undo_redo_delete_status_vector.push_back(status);
undo_redo_position_vector.push_back(position);
standing_position=undo_redo_tag_vector.size()-1;

//undo-redo-code-ends here
//undo-redo-code-ends here


      xml_scene_overall_tag.erase(xml_scene_overall_tag.begin()+(changed_item_num-1)); //code for xml scene vector starts
      Glib::ustring int_to_string_value;
      std::string total_arr;
      //To remove the child from the vector if there is //Code starts here
      int single_child_same_no=-1;
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            int child_in_total_list;
            std::stringstream str(*beg);
            str>>child_in_total_list;
            if(child_in_total_list==changed_item_num)
            {
            single_child_same_no=i;
            break;
            }	
          }
        }
      }
      if(single_child_same_no!=-1)
      {
        for(int i=single_child_same_no; i<group_child_total_list.size()-1; i++)
        {
        group_child_total_list[i]=group_child_total_list[i+1];
        }
        group_child_total_list.pop_back();
        for(int i=0; i<group_child_total_list.size()-1; i++)
        {
          tokenizer<> tok(group_child_total_list[i]);
          tokenizer<>::iterator beg=tok.begin();
          if(*beg=="G")
          {
            int l=1;
            for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
            {
              if(l!=1)
              {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list>=single_child_same_no)
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
              else
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list);
              if(l==2)
              total_arr="G,"+int_to_string_value;
              else
              total_arr=total_arr+","+int_to_string_value;
              group_child_total_list[i]=total_arr;			
              }
              l++;
            }
          }
        }
      }
      for(int i=0; i<group_child_total_list.size(); i++)
      {
        tokenizer<> tok(group_child_total_list[i]);
        tokenizer<>::iterator beg=tok.begin();
        if(*beg=="S")
        {
          int l=1;
          for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
          {
            if(l!=1)
            {
              int child_in_total_list;
              std::stringstream str(*beg);
              str>>child_in_total_list;
              if(child_in_total_list>changed_item_num)
              {
              int_to_string_value = boost::lexical_cast<std::string>(child_in_total_list-1);
              total_arr="S,"+int_to_string_value;
              group_child_total_list[i]=total_arr;			
              }
            }
            l++;
          }
        }
      }
      //To remove the child from the vector if there is //Code ends here
      //To remove the child from the root //Code starts here
      control_points_remove();
      move_var=0;
      root->remove_child(changed_item_num); //Which item has to be removed.
      child_num=child_num-1;
			/*SARU*/
		  for(int g=0;g<for_image_indentification.size();g++)
				{
				  int counts=1;
				  string get_image_number = for_image_indentification[g] ;
				  Glib::ustring image_number;
				  Glib::ustring child_number_for_image;
				  tokenizer<> tok(get_image_number);
				  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				  {
					if(counts==1)
					image_number =*beg;
					else
					child_number_for_image=*beg;
					counts++;
				   }	
					 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
					 int  image_int = boost::lexical_cast<int>(image_number);


				   if(current_clicked_item==child_number_for_image_int)
						{
							delete_image_vector_poition = g;
							image_delete_flag = 1;
						}

					if(child_number_for_image_int>current_clicked_item)
						{
							number_for_image = image_int;
							image_vector_position = g;
							image_vector_position_str = boost::lexical_cast<std::string>(g);
							current_clicked_item_new  = child_number_for_image_int-1;
							image_vector_position_value =boost::lexical_cast<std::string>(current_clicked_item_new);
							new_image_vector_position_value = image_vector_position_str + "," + image_number + "," + image_vector_position_value;
							changed_image_vector_values.push_back(new_image_vector_position_value);
						}		

				}
			for(int g=0;g<changed_image_vector_values.size();g++)
			{
			   string new_image_value =	changed_image_vector_values[g];


				 tokenizer<> tok(new_image_value);
				 int count=1;
				 Glib::ustring vector_no;
				 std::string image_no;
				 std::string item_no;
				 std::string delimiter = ",";
				 std::string storestring="";
				 for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
				 {
				   if(count==1)
					   vector_no=*beg;
				   else 
					  storestring=storestring + *beg ;
					  count++;
				 }
				 int  vector_no_int = boost::lexical_cast<int>(vector_no);
				 size_t pos = 0;
				 std::string token;
				 while ((pos =  changed_image_vector_values[g].find(delimiter)) != std::string::npos) 
				 {
					token = changed_image_vector_values[g] .substr(0, pos);
					changed_image_vector_values[g] .erase(0, pos + delimiter.length());
				 }
				image_no=token;
				item_no=changed_image_vector_values[g];

				new_image_vector_position_value = image_no + "," + item_no;
		 		for_image_indentification.at(vector_no_int) = new_image_vector_position_value;
			 }	


			if(image_delete_flag==1)
				{
					for_image_indentification.erase(for_image_indentification.begin()+delete_image_vector_poition);	
					image_delete_flag = 0;
				}
			/*SARU*/

      //To remove the child from the root	//Code ends here
    }
  }

if(delete_group_status==0)
{
	if(grid_mode==0)
	{
	 changed_item_num = child_num;
     for_grp_check=1;
	}
	else if(grid_mode==1 && changed_item_num==2)
	{
	 changed_item_num = changed_item_num;
	 for_grp_check=1;
	}
	else
	{
	 changed_item_num = changed_item_num-1;
     for_grp_check=1;
	}
}
else
{
    if(grid_mode==0)
    {
	changed_item_num = child_num;
     for_grp_check=1;
    }
	else		
    {
	changed_item_num = child_num-1;
    for_grp_check=1;
    }
	eraser_grouped_child_no.clear();
	delete_group_status=0;
}

}


/*Spin Button*/
void KalanjiyamWindow::on_pAdjBorder_value_changed()
{
  border_width = pSpinBorderWidth->get_value_as_int();
  if(col_flag==1 && move_var>=1	 && eraser_grouped_child_no.size()==0)
  {
  my_item->set_property(Glib::ustring("line_width"), border_width);
  come_from_line_change = 1;
  get_property(my_item,item_pos);
  come_from_line_change = 0;
  open_node_name_line="";
  open_node_name_ellipse="";
  }
}	

void KalanjiyamWindow::on_pAdjEraser_value_changed()
{

  eraser_width = pSpinEraserWidth->get_value_as_int();
  //my_item->set_property(Glib::ustring(""), eraser_width);

Glib::RefPtr<Gdk::Pixbuf> pixbuf;
if(eraser_width>=1)
eraser_width=eraser_width+2;
std::string img_file = "/usr/share/applications/Kalanjiyam/Gui/Icon/eraser.png";
std::string img_file1 = "/usr/share/applications/Kalanjiyam/Gui/Icon/eraser_final.png";
Image image(img_file); 
Geometry newSize = Geometry(eraser_width, eraser_width);
newSize.aspect(true);
image.resize(newSize);
image.write(img_file1);
pixbuf = Gdk::Pixbuf::create_from_file(img_file1); //eraser
Gdk::Cursor cursor = Gdk::Cursor(Gdk::Display::get_default(),pixbuf,(eraser_width/2),(eraser_width/2));
m_refDrawable->set_cursor(cursor);

}		

void KalanjiyamWindow::on_pAdjBorder_xRadius_value_changed()
{
  border_x_radius = pSpinBorderXRadius->get_value_as_int();
  if(col_flag==1)
  {
  my_item->set_property(Glib::ustring("radius_x"), border_x_radius);
  get_property(my_item,item_pos);
  }
}	

void KalanjiyamWindow::on_pAdjBorder_yRadius_value_changed()
{
  border_y_radius = pSpinBorderYRadius->get_value_as_int();
  if(col_flag==1)
  {
  my_item->set_property(Glib::ustring("radius_y"), border_y_radius);
  get_property(my_item,item_pos);
  }
}	

void KalanjiyamWindow::on_total_frames_selection_changed()
{
  int global_total_frames = pTotalFrames->get_value_as_int();
  to_png();
}	
/*Spin Button*/

void KalanjiyamWindow::show_selected_thumbnail_contents_in_window()
{
  edit_clear_window();
  clear_info_contents();
  clear_global_varaiables_values();
  correct_scene_shot_position_occured = find_correct_scene_shot_position();
  std::string scene_total_value;
  tokenizer<> tok(global_scene_shot_number_list_vector[correct_scene_shot_position_occured-1]);
  int counts=1;
  Glib::ustring SceneNo;
  Glib::ustring ShotNo;
  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
  {
    if(counts==1)
    SceneNo=*beg;
    else
    ShotNo=*beg;
    counts++;
  }		
  string input_xml = "<Kalanjiyam> \n <Scene> \n <SceneNumber>" + SceneNo + "</SceneNumber> \n <ShotNumber>" + ShotNo + "</ShotNumber>" + xml_kalanjiyam_overall_tag[correct_scene_shot_position_occured-1] + " </Kalanjiyam>";
  vector<char> xml_copy(input_xml.begin(), input_xml.end());
  xml_copy.push_back('\0');
  xml_document<> doc;
  doc.parse<parse_declaration_node | parse_no_data_nodes>(&xml_copy[0]);
  xml_node<>* Kalanjiyam = doc.first_node("Kalanjiyam");
  xml_node<>* Scene = Kalanjiyam->first_node("Scene");
  xml_node<> * abc;
  while (Scene != NULL )
  {
    for(abc = Scene->first_node(); abc; abc = abc->next_sibling())
    {
      const char * test1 = abc->name();	
      if (strcmp(test1, "SceneNumber" ) == 0)
      {
      SceneNumber = abc->value();
      pSceneNumber->set_text(SceneNumber);
      }	
      if (strcmp(test1, "ShotNumber" ) == 0)
      {
      ShotNumber = abc->value();
      pShotNumber->set_text(ShotNumber);
      }
      if (strcmp(test1, "ShotType" ) == 0)
      {
      ShotType=abc->value();
      m_Combo.set_active_text(abc->value()); 
      }
      if (strcmp(test1, "TotalFrames" ) == 0)
      {
      TotalFrames=abc->value();
      Glib::ustring a = abc->value();        
      pTotalFrames->set_value(atoi(a.c_str()));
      }
      if (strcmp(test1, "SceneTitle" ) == 0)
      {
      SceneTitle=abc->value();
      pSceneTitle->set_text(abc->value());
      }
      if (strcmp(test1, "Dialogue" ) == 0)
      {
      Dialogue=abc->value();
      text_buffer = Gtk::TextBuffer::create();
      text_buffer->set_text(abc->value());
      pDialogue->set_buffer(text_buffer);
      }
      if (strcmp(test1, "ActionNotes" ) == 0)
      {
      ActionNotes=abc->value();
      text_buffer = Gtk::TextBuffer::create();
      text_buffer->set_text(abc->value());
      pActionNotes->set_buffer(text_buffer);
      }
      if (strcmp(test1, "AudioNotes" ) == 0)
      {
      AudioNotes=abc->value();
      text_buffer = Gtk::TextBuffer::create();
      text_buffer->set_text(abc->value());
      pAudioNotes->set_buffer(text_buffer);
      }
      open_node_name="";
      for (xml_attribute<> *attribute = abc->first_attribute(); attribute; attribute = attribute->next_attribute())
      {
      const char * node_name = abc->name();
      const char * node_value = abc->value();		
      open_node_name = node_name;
      open_node_value = node_value;
      const char * attribute_name = attribute->name();	
      const char * attribute_value = attribute->value();	
      open_attr_name = attribute_name;
      open_attr_value = attribute_value;
      find_current_node_to_get_attribute_value(open_node_name);
      }
      call_function_according_to_node_name(open_node_name); 
    }
    Scene = Scene->next_sibling("Scene");	
  }
  to_png();
  darea->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_strokecolor_hex));
  darea2->modify_bg(Gtk::STATE_NORMAL, Gdk::Color(open_global_fillcolor_hex));
}

void KalanjiyamWindow::create_thumbnail_window()
{
  Glib::RefPtr<Gtk::TreeView::Selection> refSelection =my_Tree_View_Test_Tree_View.get_selection();
  Gtk::TreeModel::iterator iter1 = refSelection ->get_selected ();
  Gtk::TreeModel::Row my_row1;
  my_row1=*iter1;
  my_row1[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file("/tmp/Kalanjiyam/Thumbnails/Thumbnail1.png");
  total_rows1 = 1;
  Gtk::TreeModel::Row my_row;
  int i=-1;
  std::string sc_no,shot_no;
  int check_shot;

  for(int g=1;g<global_scene_shot_number_list_vector.size();g++)
  {
    Glib::ustring img_file_name="Thumbnail";
    Glib::ustring int_to_string_value;
    Glib::ustring img_file_extension=".png";
    Glib::ustring img_path;
    int_to_string_value = boost::lexical_cast<std::string>(g+1);
    img_path = thumbnail_tmp_path + img_file_name + int_to_string_value + img_file_extension;
    tokenizer<> tok(global_scene_shot_number_list_vector[g]);

    for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
    {
      i++;
      if(i==1)
      {
      shot_no= *beg;		
      check_shot = boost::lexical_cast<int>(shot_no);	
      }
      if(i==0)
      sc_no= *beg;		
    }
    i=-1;

    if(check_shot>1)
    {
      Glib::RefPtr<Gtk::TreeView::Selection> refSelection = my_Tree_View_Test_Tree_View. get_selection();
      Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
      Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
      Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
      if ( refSelection->get_selected() )
      {
      Gtk::TreeModel::Row row;
      row = *iter;
      Gtk::TreeModel::Row my_row = *( my_Tree_View_Test_Tree_Model->append(row.children()));	
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file(img_path.c_str());
      full_scene_name="Scene"+sc_no+" "+"shot"+shot_no;
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;
      }
    }
    else
    {		
      Glib::RefPtr<Gtk::TreeView::Selection> refSelection=my_Tree_View_Test_Tree_View. get_selection();
      Gtk::TreeModel::iterator store_iter = refSelection->get_selected();
      my_row = *(my_Tree_View_Test_Tree_Model->append());
      Gtk::TreeModel::iterator iter = refSelection ->get_selected ();
      Gtk::TreeModel::Path path = my_Tree_View_Test_Tree_Model->get_path (iter);
      refSelection->select(my_row);
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Id_Number] = Gdk::Pixbuf::create_from_file(img_path.c_str());
      full_scene_name="Scene"+sc_no+" "+"shot"+shot_no;
      my_row[my_Tree_View_Test_Tree_Model->my_Tree_View_Test_Columns.my_Name_String] = full_scene_name;
      refSelection->select(my_row);
      total_rows1 ++;
    }

  }
}

Glib::ustring KalanjiyamWindow::create_temp_scene_xml()
{
  Glib::ustring int_to_string_scene_value = boost::lexical_cast<std::string>(global_current_scene_number);
  Glib::ustring int_to_string_shot_value = boost::lexical_cast<std::string>(global_current_shot_number);
  global_temp_scene_xml = "<ShotType>Select</ShotType>\n"
  "<TotalFrames></TotalFrames>\n"
  "<SceneTitle></SceneTitle>\n"
  "<Dialogue></Dialogue>\n"
  "<ActionNotes></ActionNotes>\n"
  "<AudioNotes></AudioNotes>\n"
  "</Scene>";
  return global_temp_scene_xml;
}

int KalanjiyamWindow::find_correct_scene_shot_position()
{
  Glib::ustring combine_cur_scene_shot_number = boost::lexical_cast<std::string>(global_current_scene_number) + "," + boost::lexical_cast<std::string>(global_current_shot_number);
  int count = 0;
  int size = global_scene_shot_number_list_vector.size();		
  for (global_scene_shot_number_list_vector_it = global_scene_shot_number_list_vector.begin(); global_scene_shot_number_list_vector_it != global_scene_shot_number_list_vector.end(); ++global_scene_shot_number_list_vector_it)
  { 
    count = count + 1;
    Glib::ustring find_scene_shot_position = *global_scene_shot_number_list_vector_it; 
    if (strcmp(combine_cur_scene_shot_number.c_str(), find_scene_shot_position.c_str() ) == 0)
    {
    correct_scene_shot_position_occured = count;
    break;	
    }
    else
    {
    correct_scene_shot_position_occured = size;
    }
  }
  return correct_scene_shot_position_occured;
}

void KalanjiyamWindow::polyline_cnt_curve_cnt()
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
  if(drawing_tool_number==14)
  {
	   open_node_name_curve=1;
    if(curve_cnt>0)
    {
      int grid_status=0;
      if(grid_mode==1)
      {
      view_grid_on_off();
      grid_status=1;
      }
      for(child_var=last_child_num+1; child_var<=child_num; child_var++)
      {
      root->remove_child(last_child_num+1);
      }
      child_num=last_child_num; 
      if(grid_status==1)
      view_grid_on_off();
      curve_cnt=0;
    }
  }
  polyline_cnt=0;
}


bool KalanjiyamWindow::dragging_erase()
{

/*Code for dragging erase*/
	Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();
	string my_str1_tag_modified2;
	string my_str1_tag_modified3;
	erased_path_merge_data = "";
	erased_path_merge1_data = "";
	//count_for_my_str1=0;
	int line_check=0;
	view_grid_on_off();

	Glib::RefPtr<Goocanvas::Path> path ;	
 if(image_edit_status==1 && eraser_grouped_child_no.size()==0)	 // FOR IMAGE ERASE CHECK
	{
	if(my_str1_tag_modified.size()!=0 && my_str1_tag_modified1.size()!=0 )
	{

		eraser_status=1;
		current_clicked_item = changed_item_num;

			my_item = root->get_child(current_clicked_item); 

			float open_global_hei= open_global_height;
			float open_global_wid= open_global_width;
			float open_global_x_pos = open_global_xposition;
			float open_global_y_pos = open_global_yposition;
	
		    get_property(my_item ,current_clicked_item); 

			if(open_node_name_curve==0 )
				{

						first_vector_for_eraser.clear();
						string strvalue1;
						string strvalue2;
						stringstream stream(my_str1_tag);
						int i=0;
						z_count=0; 
						m_count=0; 
						string erase_value;

								while( getline(stream, strvalue1, ' ') )
								{
							 	  if(strvalue1=="z" || strvalue1=="Z")
								  {
									z_count++;
									first_vector_for_eraser.push_back("z");
								  }
								  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z" && strvalue1!="Z")
								  {
									if(i==0)
									{
									  strvalue2=strvalue1;
									  i++;
									}
									else
									{
									  strvalue2=strvalue2+","+strvalue1;
									  first_vector_for_eraser.push_back(strvalue2);
									  i=0;
									}
								  }
								}

								if(open_node_name_ellipse=="Ellipse")//rrkk
								{
		                 			
									my_str1_tag_modified.push_back(my_str1_tag_modified5);
								}
								for(int i=0; i<my_str1_tag_modified1.size(); i++)
								{
									if(i==0)
									my_str1_tag_modified2="[("+my_str1_tag_modified1[i]+"), ";
									else
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified1[i]+"), ";
								}
								for(int i=my_str1_tag_modified.size()-1; i>=0; i--)
								{
									if(i!=0)
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified[i]+"), ";
									else if(i==0)
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified[i]+")]";
								}
								if(z_count<2)
								{
									for(int i=0; i<first_vector_for_eraser.size();i++)
									{
										if(i==0)
										my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
										else if(i==first_vector_for_eraser.size()-1)
										my_str1_tag_modified3=my_str1_tag_modified3+"]";
										else
										my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
									}
								}
								else if(z_count>=2)
								{
									int z_cnt=1, j=0;
									for(int i=0; i<first_vector_for_eraser.size(); i++)
									{
										if(j==0)
										{
											my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
											j++;
										}
										else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
										{
											my_str1_tag_modified3=my_str1_tag_modified3+"], [";
											j=0; z_cnt++;
										}
										else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
										my_str1_tag_modified3=my_str1_tag_modified3+"]]";
										else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
										{
											my_str1_tag_modified3=my_str1_tag_modified3+"], ";
											j=0; z_cnt++;
										}
										else
										my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
									}
								}
							Glib::locale_from_utf8(my_str1_tag_modified3);
							Glib::locale_from_utf8(my_str1_tag_modified2);
							const char *c = my_str1_tag_modified3.c_str();
							const char *d = my_str1_tag_modified2.c_str();


							const char *open_global_python_data1 = open_global_python_data.c_str();

							PyObject *main = PyImport_AddModule("__main__"); // borrowed
							if (main == NULL)
								//error();
							return 0;
							PyObject *globals = PyModule_GetDict(main); // borrowed

							PyObject *py_data = PyString_FromString(open_global_python_data1);
							if (py_data == NULL)
							return 0;
							   //error();
							if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
							return 0;
							   //error();
							Py_DECREF(py_data);

							PyObject *value = PyString_FromString(c);
							if (value == NULL)
							return 0;
							   //error();
							if (PyDict_SetItemString(globals, "n", value) < 0)
							return 0;
							   //error();
							Py_DECREF(value);
							PyObject *value1 = PyString_FromString(d);
							if (value1 == NULL)
							return 0;
							   //error();
							if (PyDict_SetItemString(globals, "m", value1) < 0)
							return 0;
							   //error();
							Py_DECREF(value1);
							
							if(open_node_name_ellipse_string=="2")
							{
								  PyRun_SimpleString("import ast\n"
							"from shapely.geometry import Polygon, MultiPolygon\n"
							"from shapely.geometry import *\n"
							"from shapely.ops import cascaded_union\n"
							"splitmultipoly = pythondata.split(')), ((')\n"
							"if len(splitmultipoly) == 1:\n"
							"	eras = n.split('], [[')\n"
							"	if len(eras) == 1:\n"
							"		a= ast.literal_eval(n)\n"
							"		A1 = Polygon(a)\n"
							"		A1 = A1.buffer(0)\n"
							"	else:\n"
							"		str1 = '[' + n + ']'\n"
							"		c= ast.literal_eval(str1)\n"
							"		A1 = Polygon(c[0],c[1])\n"
							"	A1 = A1.buffer(0)\n"
							"else:\n"
							"	Multipo = pythondata\n"
							"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
							"	Multipo = Multipo.replace(')))','))')\n"
							"	Multipo = Multipo.replace(', ((','split[(')\n"
							"	Multipo = Multipo.replace('))',')]')\n"
							"	Multipo = Multipo.replace('), (',')],[(')\n"
							"	Multipo = Multipo.replace(', ','),(')\n"
							"	Multipo = Multipo.replace(' ',',')\n"
							"	Multipo = Multipo.split('split')\n"
							"	s = []\n"
							"	for i in Multipo:\n"
							"		a = i.split('],[')\n"
							"		if len(a) >=2:\n"
							"			i = i.replace('],[','],[[',1)\n"
							"			i = '[' + i + ']]'\n"
							"			i = ast.literal_eval(i)\n"
							"			s.append(Polygon(i[0],i[1]))\n"
							"		else:\n"
							"			i = ast.literal_eval(i)\n"
							"			s.append(Polygon(i))\n"
							"	A1 = cascaded_union(s)\n"
							"try:\n"
							"	m = m.replace(', ( , ),' , ',')\n"
	   						"	m = m.replace('( , ), ' , '')\n"
							"	m = m.replace(', ( , )' , '')\n"
							"	m = m.replace(', (,),' , ',')\n"
	   						"	m = m.replace('(,), ' , '')\n"
							"	m = m.replace(', (,)' , '')\n"
							"	b= ast.literal_eval(m)\n"
							"	B1 = Polygon(b)\n"
							"	B1 = B1.buffer(0)\n"
							"	if(A1.difference(B1)):\n"
							"		erase=A1.difference(B1)\n"
							"	else:\n"
							"		erase=A1.difference(B1)\n"
							"except:\n"
							"	erase = A1\n"
							"eraser=str(erase)\n"
							"f=open('file.txt','w')\n"
							"f.write(eraser)\n"
							"f=open('file.txt','r')\n"
							"text=f.read()\n");
							}

							PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
							PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
							PyObject * eraser = PyDict_GetItemString(dictionary, "text");
							erase_value = PyString_AsString(eraser);
							PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
							string er_val1 = PyString_AsString(er_val);
							string er_val2 = "'";
							open_global_python_data = er_val1;


							second_vector_for_eraser.clear();


								if(erase_value=="GEOMETRYCOLLECTION EMPTY" && eraser_grouped_child_no.size()!=0)
								{
									open_global_data=my_str1_tag;
								}
								else
								{
								string first_value = erase_value.substr(0,1);
								if(first_value=="M")
								{
								boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
								boost::replace_all(erase_value, "((", "(");
								boost::replace_all(erase_value, "))", ")");
								}

								string token, mystring(erase_value), mystring1;
								int loop_cnt=1;
								while(token != mystring)
								{
								  token = mystring.substr(0,mystring.find_first_of(")"));
								  mystring = mystring.substr(mystring.find_first_of(")") + 1);
								  if(mystring.size()==0)
								  break;
								  if(loop_cnt==1)
								  mystring1 = token.substr(10,token.size()-10);
								  else
								  mystring1 = token.substr(3,token.size()-3);
								  second_vector_for_eraser.push_back(mystring1);
								  loop_cnt++;

								}
								open_global_data="";
								for(int i=0; i<second_vector_for_eraser.size(); i++)
								{ 
								  open_global_data=open_global_data+"M ";
								  string old_data = second_vector_for_eraser[i];
								  string tok, mystr(old_data);
								  int loop_count=1;
								  while(tok != mystr)
								  {
									tok = mystr.substr(0,mystr.find_first_of(","));
									mystr = mystr.substr(mystr.find_first_of(",") + 1);
									if(loop_count==1)
									{
					 			  	  open_global_data=open_global_data+tok;
									}
									else
									{
									  open_global_data=open_global_data+" L"+tok;
									}
									loop_count++;
								  }
								  open_global_data=open_global_data+" z ";
								}
							}

							my_item=root->get_child(current_clicked_item);
							if(image_edit_status==0)
								my_item->set_property("data", open_global_data);
					}//CURVE ENDES
						
			my_item=root->get_child(current_clicked_item);
			_dragging = my_item ;
		//	image_edit_status=0;

			} // SINGLE ITEM ENDS
//		}//else

if(image_edit_status==1 && eraser_grouped_child_no.size()==0)	
		{

 			boost::timer t1; // start timing

			current_clicked_item = changed_item_num;
			my_item = root->get_child(current_clicked_item); 

			Glib::RefPtr<Goocanvas::Item> img = root->get_child(current_clicked_item);

			img->set_property("clip_path", Glib::ustring(open_global_data));


			img->property_x() = open_global_xposition;
			img->property_y() = open_global_yposition;
			img->property_width() = open_global_width;
			img->property_height() = open_global_height;	
			img->set_property("scale_to_fit",true);	

			double elapsed_time1 = t1.elapsed();
			std::cout<<"AFTER CREATE IMAGE IMAGE ERASE ***********"<<elapsed_time1<<"\n"<<"\n";

			_dragging = my_item ;
		//	open_global_data = img_encode;
		}
		} // END IMAGE ERASE 

	else // ITEM ERASE STARRT
	{

	if(my_str1_tag_modified.size()!=0 && my_str1_tag_modified1.size()!=0 )
	{


		eraser_status=1;
		current_clicked_item = changed_item_num;

			my_item = root->get_child(current_clicked_item); 

			float open_global_hei= open_global_height;
			float open_global_wid= open_global_width;
			float open_global_x_pos = open_global_xposition;
			float open_global_y_pos = open_global_yposition;
	
		    get_property(my_item ,current_clicked_item); 

			if(open_node_name_curve==0 && image_edit_status==0)
				{

						first_vector_for_eraser.clear();
						string strvalue1;
						string strvalue2;
						stringstream stream(my_str1_tag);
						int i=0;
						z_count=0; 
						m_count=0; 
						string erase_value;
						if(open_node_name_line=="Line")
						{
							open_node_name_line_string="1";
							open_node_name_line="open1";
							line_check=1;
							while( getline(stream, strvalue1, ' ') )
								{
								  if(strvalue1=="m" || strvalue1=="M")
								  {
									m_count++;
									first_vector_for_eraser.push_back("M");
								  }
								 else if(strvalue1!="M" && strvalue1!="L" && strvalue1!="m")
								  {
									if(i==0)
									{
				 					  strvalue2=strvalue1;
						
									  i++;
									}
									else
									{
									  strvalue2=strvalue2+","+strvalue1;
									  first_vector_for_eraser.push_back(strvalue2);
									  i=0;
									}
								  }
								}
								for(int i=0; i<my_str1_tag_modified1.size(); i++)
								{
									if(i==0)
									my_str1_tag_modified2="[("+my_str1_tag_modified1[i]+"), ";
									else
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified1[i]+"), ";
								}
								for(int i=my_str1_tag_modified.size()-1; i>=2; i--)
								{
									if(i!=2)
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified[i]+"), ";
									else if(i==2)
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified[i]+")]";
								}
							if(m_count==1)
							 {

								for(int i=0; i<first_vector_for_eraser.size();i++)
								{
									if(i==0)
									{
									my_str1_tag_modified3="[(("+first_vector_for_eraser[i+1]+")";
									i = i+1;
									}
					
									else if(i==first_vector_for_eraser.size()-1)
									my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+"))]";
									else
									my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
								}
							}
						   else if(m_count>=1)
									{
										int z_cnt=1, j=0;
										for(int i=0; i<first_vector_for_eraser.size(); i++)
										{
											if(i==0)
											{
												my_str1_tag_modified3="[(";
											}
											else if(first_vector_for_eraser[i]=="m" || first_vector_for_eraser[i]=="M")
											{
												my_str1_tag_modified3=my_str1_tag_modified3+"), (";
											}
											else if(i==first_vector_for_eraser.size()-1) 
											my_str1_tag_modified3 = my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"))]";
											else if(first_vector_for_eraser[i+1]=="M")
											{
												my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+")";
											}
											else if (i!=first_vector_for_eraser.size()-1) 
											my_str1_tag_modified3=my_str1_tag_modified3+"("+first_vector_for_eraser[i]+"), ";
										}
								}
						}
						else
						{

								while( getline(stream, strvalue1, ' ') )
								{
							 	  if(strvalue1=="z" || strvalue1=="Z")
								  {
									z_count++;
									first_vector_for_eraser.push_back("z");
								  }
								  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z" && strvalue1!="Z")
								  {
									if(i==0)
									{
									  strvalue2=strvalue1;
									  i++;
									}
									else
									{
									  strvalue2=strvalue2+","+strvalue1;
									  first_vector_for_eraser.push_back(strvalue2);
									  i=0;
									}
								  }
								}

								if(open_node_name_ellipse=="Ellipse")//rrkk
								{
		                 			
									my_str1_tag_modified.push_back(my_str1_tag_modified5);

								}
								for(int i=0; i<my_str1_tag_modified1.size(); i++)
								{
									if(i==0)
									my_str1_tag_modified2="[("+my_str1_tag_modified1[i]+"), ";
									else
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified1[i]+"), ";
								}
								for(int i=my_str1_tag_modified.size()-1; i>=0; i--)
								{
									if(i!=0)
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified[i]+"), ";
									else if(i==0)
									my_str1_tag_modified2=my_str1_tag_modified2+"("+my_str1_tag_modified[i]+")]";
								}
								if(z_count<2)
								{
									for(int i=0; i<first_vector_for_eraser.size();i++)
									{
										if(i==0)
										my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
										else if(i==first_vector_for_eraser.size()-1)
										my_str1_tag_modified3=my_str1_tag_modified3+"]";
										else
										my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
									}
								}
								else if(z_count>=2)
								{
									int z_cnt=1, j=0;
									for(int i=0; i<first_vector_for_eraser.size(); i++)
									{
										if(j==0)
										{
											my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
											j++;
										}
										else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
										{
											my_str1_tag_modified3=my_str1_tag_modified3+"], [";
											j=0; z_cnt++;
										}
										else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
										my_str1_tag_modified3=my_str1_tag_modified3+"]]";
										else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
										{
											my_str1_tag_modified3=my_str1_tag_modified3+"], ";
											j=0; z_cnt++;
										}
										else
										my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
									}
								}
							}
							Glib::locale_from_utf8(my_str1_tag_modified3);
							Glib::locale_from_utf8(my_str1_tag_modified2);
							const char *c = my_str1_tag_modified3.c_str();
							const char *d = my_str1_tag_modified2.c_str();


					const char *open_global_python_data1 = open_global_python_data.c_str();

							PyObject *main = PyImport_AddModule("__main__"); // borrowed
							if (main == NULL)
								//error();
							return 0;
							PyObject *globals = PyModule_GetDict(main); // borrowed

							PyObject *py_data = PyString_FromString(open_global_python_data1);
							if (py_data == NULL)
							return 0;
							   //error();
							if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
							return 0;
							   //error();
							Py_DECREF(py_data);

							PyObject *value = PyString_FromString(c);
							if (value == NULL)
							return 0;
							   //error();
							if (PyDict_SetItemString(globals, "n", value) < 0)
							return 0;
							   //error();
							Py_DECREF(value);
							PyObject *value1 = PyString_FromString(d);
							if (value1 == NULL)
							return 0;
							   //error();
							if (PyDict_SetItemString(globals, "m", value1) < 0)
							return 0;
							   //error();
							Py_DECREF(value1);
							if(open_node_name_line_string=="1")
							{
								PyRun_SimpleString("import ast\n"
							"from shapely.geometry import LineString, MultiLineString\n"
							"from shapely.geometry import *\n"
							"a= ast.literal_eval(n)\n"
							"A = MultiLineString(a)\n"
							"try:\n"
	 						"	m = m.replace(', ( , ),' , ',')\n"
	   						"	m = m.replace('( , ), ' , '')\n"
							"	m = m.replace(', ( , )' , '')\n"
							"	m = m.replace(', (,),' , ',')\n"
	   						"	m = m.replace('(,), ' , '')\n"
							"	m = m.replace(', (,)' , '')\n"
							"	b= ast.literal_eval(m)\n"
							"	B = Polygon(b)\n"
							"	B = B.buffer(0)\n"
							"	erase = A.difference(B)\n"
							"except:\n"
							"	erase = A\n"
							"eraser=str(erase)\n"
							"f=open('file.txt','w')\n"
							"f.write(eraser)\n"
							"f=open('file.txt','r')\n"
							"text=f.read()\n");
							}
							else if(open_node_name_ellipse_string=="2")
							{
								  PyRun_SimpleString("import ast\n"
							"from shapely.geometry import Polygon, MultiPolygon\n"
							"from shapely.geometry import *\n"
							"from shapely.ops import cascaded_union\n"
							"splitmultipoly = pythondata.split(')), ((')\n"
							"if len(splitmultipoly) == 1:\n"
							"	eras = n.split('], [[')\n"
							"	if len(eras) == 1:\n"
							"		a= ast.literal_eval(n)\n"
							"		A1 = Polygon(a)\n"
							"		A1 = A1.buffer(0)\n"
							"	else:\n"
							"		str1 = '[' + n + ']'\n"
							"		c= ast.literal_eval(str1)\n"
							"		A1 = Polygon(c[0],c[1])\n"
							"	A1 = A1.buffer(0)\n"
							"else:\n"
							"	Multipo = pythondata\n"
							"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
							"	Multipo = Multipo.replace(')))','))')\n"
							"	Multipo = Multipo.replace(', ((','split[(')\n"
							"	Multipo = Multipo.replace('))',')]')\n"
							"	Multipo = Multipo.replace('), (',')],[(')\n"
							"	Multipo = Multipo.replace(', ','),(')\n"
							"	Multipo = Multipo.replace(' ',',')\n"
							"	Multipo = Multipo.split('split')\n"
							"	s = []\n"
							"	for i in Multipo:\n"
							"		a = i.split('],[')\n"
							"		if len(a) >=2:\n"
							"			i = i.replace('],[','],[[',1)\n"
							"			i = '[' + i + ']]'\n"
							"			i = ast.literal_eval(i)\n"
							"			s.append(Polygon(i[0],i[1]))\n"
							"		else:\n"
							"			i = ast.literal_eval(i)\n"
							"			s.append(Polygon(i))\n"
							"	A1 = cascaded_union(s)\n"
								"try:\n"
							"	m = m.replace(', ( , ),' , ',')\n"
	   						"	m = m.replace('( , ), ' , '')\n"
							"	m = m.replace(', ( , )' , '')\n"
							"	m = m.replace(', (,),' , ',')\n"
	   						"	m = m.replace('(,), ' , '')\n"
							"	m = m.replace(', (,)' , '')\n"
							"	b= ast.literal_eval(m)\n"
							"	B1 = Polygon(b)\n"
							"	B1 = B1.buffer(0)\n"
							"	if(A1.difference(B1)):\n"
							"		erase=A1.difference(B1)\n"
							"	else:\n"
							"		erase=A1.difference(B1)\n"
							"except:\n"
							"	erase = A1\n"
							"eraser=str(erase)\n"
							"f=open('file.txt','w')\n"
							"f.write(eraser)\n"
							"f=open('file.txt','r')\n"
							"text=f.read()\n");
							}

							PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
							PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
							PyObject * eraser = PyDict_GetItemString(dictionary, "text");
							erase_value = PyString_AsString(eraser);
							PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
							string er_val1 = PyString_AsString(er_val);
							string er_val2 = "'";
							open_global_python_data = er_val1;


							second_vector_for_eraser.clear();
							if(line_check==1)
							{

								string erase_value_for_line_check=erase_value.substr(0,10);
						
								if(erase_value_for_line_check=="LINESTRING" || erase_value=="GEOMETRYCOLLECTION EMPTY")
								{
									open_global_data=my_str1_tag;
								}
								else
								{
									string token, mystring(erase_value), mystring1;
									int loop_cnt=1;
									while(token != mystring)
									{
									  token = mystring.substr(0,mystring.find_first_of(")"));
									  mystring = mystring.substr(mystring.find_first_of(")") + 1);
									  if(mystring.size()==0)
									  break;
									  if(loop_cnt==1)
									  mystring1 = token.substr(18,token.size()-18);
									  else
									  mystring1 = token.substr(3,token.size()-3);
									  second_vector_for_eraser.push_back(mystring1);
									  loop_cnt++;

									}
									open_global_data="";
									open_global_data="";
									for(int i=0; i<second_vector_for_eraser.size(); i++)
									{ 
									  if(i==0)
									  open_global_data=open_global_data+"M ";	
									  else
									  open_global_data=open_global_data+" M ";
									  string old_data = second_vector_for_eraser[i];
									  string tok, mystr(old_data);
									  int loop_count=1;
									  while(tok != mystr)
									  {
										tok = mystr.substr(0,mystr.find_first_of(","));
										mystr = mystr.substr(mystr.find_first_of(",") + 1);
										if(loop_count==1)
										{
						 			  	  open_global_data=open_global_data+tok;
										}
										else
										{
										  open_global_data=open_global_data+" L"+tok;
										}
										loop_count++;
									  }
									}
			
								}
				 
							}
							else
							{


								if(erase_value=="GEOMETRYCOLLECTION EMPTY" && eraser_grouped_child_no.size()!=0)
								{
									open_global_data=my_str1_tag;
								}
								else
								{
								string first_value = erase_value.substr(0,1);
								if(first_value=="M")
								{
								boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
								boost::replace_all(erase_value, "((", "(");
								boost::replace_all(erase_value, "))", ")");
								}

								string token, mystring(erase_value), mystring1;
								int loop_cnt=1;
								while(token != mystring)
								{
								  token = mystring.substr(0,mystring.find_first_of(")"));
								  mystring = mystring.substr(mystring.find_first_of(")") + 1);
								  if(mystring.size()==0)
								  break;
								  if(loop_cnt==1)
								  mystring1 = token.substr(10,token.size()-10);
								  else
								  mystring1 = token.substr(3,token.size()-3);
								  second_vector_for_eraser.push_back(mystring1);
								  loop_cnt++;

								}
								open_global_data="";
								for(int i=0; i<second_vector_for_eraser.size(); i++)
								{ 
								  open_global_data=open_global_data+"M ";
								  string old_data = second_vector_for_eraser[i];
								  string tok, mystr(old_data);
								  int loop_count=1;
								  while(tok != mystr)
								  {
									tok = mystr.substr(0,mystr.find_first_of(","));
									mystr = mystr.substr(mystr.find_first_of(",") + 1);
									if(loop_count==1)
									{
					 			  	  open_global_data=open_global_data+tok;
									}
									else
									{
									  open_global_data=open_global_data+" L"+tok;
									}
									loop_count++;
								  }
								  open_global_data=open_global_data+" z ";
								}
							}
						  }

							my_item=root->get_child(current_clicked_item);
							my_item->set_property("data", open_global_data);
							
				
					if(eraser_grouped_child_no.size()!=0)
						{


							 Glib::ustring path_open_tag = "<Path";
							  Glib::ustring path_close_tag;
							  Glib::ustring path_fill_color;
							  const char* path_name = erased_value.c_str();
							  if (strcmp(path_name, " Arrow " ) == 0)
							  {
							  path_close_tag = " Arrow </Path>";	
							  path_fill_color = " fillcolor=\"";
							  }
							  else if (strcmp(path_name, " Brush " ) == 0)	
							  {
							  path_close_tag = " Brush </Path>";	
							  }
							  else if (strcmp(path_name, " Line " ) == 0)	
							  {
							  path_close_tag = " Line </Path>";	
							  }
							  else if (strcmp(path_name, " Star " ) == 0)	
							  {
							  path_close_tag = " Star </Path>";	
							  path_fill_color = " fillcolor=\"";
							  }
							  else if (strcmp(path_name, " Star1 " ) == 0)	
							  {
							  path_close_tag = " Star1 </Path>";	
							  path_fill_color = " fillcolor=\"";
							  }
							  else if (strcmp(path_name, " Triangle " ) == 0)	
							  {
							  path_close_tag = " Triangle </Path>";	
							  path_fill_color = " fillcolor=\"";
							  }
							  else if (strcmp(path_name, " Curve " ) == 0)	
							  {
							  path_close_tag = " Curve </Path>";	
							  }
							  else if (strcmp(path_name, " Polyline " ) == 0)	
							  {
							  path_close_tag = " Polyline </Path>";	
							  }

							  Glib::ustring path_i_tag = " data=\"";
							  Glib::ustring path_py_tag = " py_data=\"";
							  Glib::ustring path_stroke_color = " strokecolor=\"";
							  Glib::ustring path_line_width = " linewidth=\"";

							  Glib::ustring path_height_tag = " height=\"";
							  Glib::ustring path_width_tag = " width=\"";

							  Glib::ustring path_xposition = " xposition=\"";
							  Glib::ustring path_yposition = " yposition=\"";

							  Glib::ustring path_height_tag_value = boost::lexical_cast<std::string>(open_global_height);
							  Glib::ustring path_width_tag_value = boost::lexical_cast<std::string>(open_global_width);

							  Glib::ustring path_xposition_value = boost::lexical_cast<std::string>(open_global_xposition);
							  Glib::ustring path_yposition_value = boost::lexical_cast<std::string>(open_global_yposition);
							  Glib::ustring path_width_value = boost::lexical_cast<std::string>(open_global_linewidth);
							  Glib::ustring path_tag;
								if ((strcmp(path_name, " Curve " ) == 0) ||	(strcmp(path_name, " Line " ) == 0) ||	(strcmp(path_name, " Brush " ) == 0) || (strcmp(path_name, " Polyline " ) == 0))
							  {
							  path_tag = path_open_tag + path_i_tag + open_global_data + "\"" + path_py_tag + open_global_python_data + "\"" + path_stroke_color + open_global_strokecolor_hex + "\"" + path_line_width + path_width_value + "\""  + path_xposition + path_xposition_value + "\"" + path_yposition + path_yposition_value + "\"" + path_width_tag + path_width_tag_value + "\"" + path_height_tag + path_height_tag_value + "\">" + path_close_tag;
							  }
							  else
							  {

							  path_tag = path_open_tag + path_i_tag + open_global_data + "\"" + path_py_tag + open_global_python_data + "\"" + path_stroke_color + open_global_strokecolor_hex + "\"" + path_fill_color + open_global_fillcolor_hex + "\"" + path_line_width + path_width_value + "\""  + path_xposition + path_xposition_value + "\"" + path_yposition + path_yposition_value + "\"" + path_width_tag + path_width_tag_value + "\"" + path_height_tag + path_height_tag_value + "\">" + path_close_tag;
							  }

						if(count_for_my_str1<eraser_grouped_child_no.size())
						 {	
							undo_vector_for_group_erase.push_back(path_tag);
							count_for_my_str1++;
						 }
						else
						{
							string store_value= open_global_data+"@"+open_global_python_data;
							undo_vector_for_group_erase.at(group_indext_number)=path_tag;
						}
					   }

				}//curve check ends
			else
			{
					    Glib::ustring current_clicked_item_str = boost::lexical_cast<std::string>(current_clicked_item);
						if(count_for_my_str1<eraser_grouped_child_no.size())
						 {	
							undo_vector_for_group_erase.push_back(current_clicked_item_str);
							count_for_my_str1++;
						 }
						else
						{
							undo_vector_for_group_erase.at(group_indext_number)=current_clicked_item_str;
						}
			}// CURVE CHECK ELSE 

			my_item=root->get_child(current_clicked_item);
			_dragging = my_item ;
			image_edit_status=0;

			} // SINGLE ITEM ENDS
		}//else


	edit_flag=0;
	view_grid_on_off();
    open_node_name_ellipse_string="2";
    open_node_name_line_string="2";
    line_check=0;
	my_str1_tag_modified2 = "";
	my_str1_tag_modified3 = "";
	my_str1_last_tag_modified = "";
	my_str1_tag = "";
	open_node_name_ellipse = "";
	open_node_name_line = "";
	for_image_set =0;
	flag_set_for_find_child=1;
	open_node_name_curve=0 ;
	for_grp_check=0;

/*Code For dragging Erase */

}


bool KalanjiyamWindow::for_image_move()
{

for(int g=0;g<for_image_indentification.size();g++)
{
  int counts=1;
  string get_image_number = for_image_indentification[g] ;
  Glib::ustring image_number;
  Glib::ustring child_number_for_image;
  tokenizer<> tok(get_image_number);
  for(tokenizer<>::iterator beg=tok.begin(); beg!=tok.end();++beg)
  {
	if(counts==1)
	image_number =*beg;
	else
	child_number_for_image=*beg;
	counts++;
   }	
	 int  child_number_for_image_int = boost::lexical_cast<int>(child_number_for_image);	
	 int  image_int = boost::lexical_cast<int>(image_number);	
   if(current_clicked_item==child_number_for_image_int)
		{
			  number_for_image = image_int;
		}		
}

}

bool KalanjiyamWindow::for_image_group_move1(int child_number_for_image_int)
{
  Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();

/* SET PROPERT IMAGE*/

	erase_dragging_status=1;
	/*************/

	std::vector<std::string>split_x_y;  
	std::vector<std::string>combined_x_y; 


	my_str1_tag = "";

	my_str1_tag = open_global_data;

	 string strvalue1;
	 string strvalue2;
	 stringstream stream(my_str1_tag);
	 while( getline(stream, strvalue1, ' ') )
		 split_x_y.push_back(strvalue1);



	 string dis_x_str;
	 string dis_y_str;

	float dis_x_int;
	float dis_y_int;
	int a_size=split_x_y.size();


	//if((global_y_diff!=0)||(global_x_diff!=0))
	//{
		for (int g=0; g<split_x_y.size(); g++)
		{
		  if(g==a_size-1)//|| split_x_y[g]== "z") && (split_x_y[g++]!="M"))
			{
			combined_x_y.push_back("Z");
			break;
			//g = g++;
			}
		  if((split_x_y[g]=="Z" || split_x_y[g]=="z") && (g!=a_size-1))
			{
			combined_x_y.push_back(split_x_y[g]);
			g=g++;
			}

		if(split_x_y[g]=="M" || split_x_y[g]== "L")
		   {
				if(split_x_y[g]=="M")
				{
				combined_x_y.push_back(split_x_y[g]);
				g = g++;
				}
			   else	if(split_x_y[g]=="L")
				{
				combined_x_y.push_back(split_x_y[g]);
				g = g++;
				}
				dis_x_str =split_x_y[g];
			 	dis_x_int =boost::lexical_cast<float>(dis_x_str);
				dis_x_int = dis_x_int + global_x_diff;
				dis_x_str=boost::lexical_cast<std::string>(dis_x_int);
				combined_x_y.push_back(dis_x_str);


				g = g++;
				dis_y_str =split_x_y[g];
				dis_y_int =boost::lexical_cast<float>(dis_y_str);
				dis_y_int= dis_y_int + global_y_diff;
				dis_y_str=boost::lexical_cast<std::string>(dis_y_int);
				combined_x_y.push_back(dis_y_str);			
			}   

		}
		my_str1_tag="";
		for (int g=0; g<combined_x_y.size(); g++)
		{
		 if(i==0)
			 my_str1_tag = combined_x_y[g] ;
		else
			 my_str1_tag = my_str1_tag+" "+combined_x_y[g] ;
		}
		 my_str1_tag  = my_str1_tag .substr(1,my_str1_tag .size()-1);
		//come_from_line_change1 = 1;
		open_global_data =  my_str1_tag;
		

		//open_glob_dat = open_global_data;

		string open_global_python_data_for_check = open_global_python_data.substr(0,6);

		if(open_global_python_data_for_check=="MULTIP")
		{
		string dis_x_str_str=boost::lexical_cast<string>(global_x_diff);

		string dis_y_str_str=boost::lexical_cast<string>(global_y_diff);

		Glib::locale_from_utf8(open_global_python_data);
		Glib::locale_from_utf8(dis_x_str_str);
		Glib::locale_from_utf8(dis_y_str_str);

		const char *open_global_python_data1 = open_global_python_data.c_str();
		const char *dis_x_str1 = dis_x_str_str.c_str();
		const char *dis_y_str1 = dis_y_str_str.c_str();

			PyObject *main = PyImport_AddModule("__main__"); // borrowed
			/*if (main == NULL)
				//error();
			return 0;*/
			PyObject *globals = PyModule_GetDict(main); // borrowed
			PyObject *py_data = PyString_FromString(open_global_python_data1);
			/*if (py_data == NULL)
			return 0;
			   //error();*/
			PyDict_SetItemString(globals, "pythondata", py_data) ;
			//return 0;
			   //error();
			Py_DECREF(py_data);

			PyObject *py_data1 = PyString_FromString(dis_x_str1);
			/*if (py_data1 == NULL)
			return 0;
			   //error();*/
			PyDict_SetItemString(globals, "pythondata1", py_data1);
			//return 0;*/
			   //error();
			Py_DECREF(py_data1);


			PyObject *py_data2 = PyString_FromString(dis_y_str1);
			/*if (py_data2 == NULL)
			return 0;
			   //error();*/
			PyDict_SetItemString(globals, "pythondata2", py_data2);
			//return 0;
			   //error();
			Py_DECREF(py_data2);


							PyRun_SimpleString("import ast\n"
						"from shapely.geometry import Polygon, MultiPolygon\n"
						"from shapely.geometry import *\n"
						"from shapely.ops import cascaded_union\n"
						"Multipo = pythondata\n"
						"Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
						"Multipo = Multipo.replace(')))','))')\n"
						"Multipo = Multipo.replace(', ((','split[(')\n"
						"Multipo = Multipo.replace('))',')]')\n"
						"Multipo = Multipo.replace('), (',')],[(')\n"
						"Multipo = Multipo.replace(', ','),(')\n"
						"Multipo = Multipo.replace(' ',',')\n"
						"Multipo = Multipo.split('split')\n"
						"s = []\n"
						"for i in Multipo:\n"
						"	a = i.split('],[')\n"
						"	if len(a) >=2:\n"
						"		i = i.replace('],[','],[[',1)\n"
						"		i = '[' + i + ']]'\n"
						"		i = ast.literal_eval(i)\n"
						"		m = []\n"
						"		n = []\n"
						"		o = []\n"
						"		for j in i[0]:\n"
						"			k = j[0]+float(pythondata1)\n"
						"			l = j[1]+float(pythondata2)\n"
						"			m.append((k,l))\n"
						"		for a in i[1]:\n"
						"			for b in a:\n"
						"				k = b[0]+float(pythondata1)\n"
						"				l = b[1]+float(pythondata2)\n"
						"				o.append((k,l))\n"
						"			n.append(o)\n"
						"		s.append(Polygon(m,n).buffer(0))\n"
						"	else:\n"
						"		i = ast.literal_eval(i)\n"
						"		m = []\n"
						"		for j in i:\n"
						"			k = j[0]+float(pythondata1)\n"
						"			l = j[1]+float(pythondata2)\n"
						"			m.append((k,l))\n"
						"		s.append(Polygon(m).buffer(0))\n"
						"C = cascaded_union(s)\n"
						"C1 = str(C)\n");


		PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
		PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
		PyObject * eraserera = PyDict_GetItemString(dictionary, "C1");
		string changed_val = PyString_AsString(eraserera);

		open_global_python_data = changed_val;
		//}
		}

		Glib::RefPtr<Goocanvas::Item> img1 = root->get_child(child_number_for_image_int);

		img1->set_property("clip_path",open_global_data);

	/*************


	/* SET PROPERT IMAGE*/

}


void KalanjiyamWindow::reset_global_variables()
{
/*Thumbnail*/
//Glib::ustring str;
file_open_confirm_flag=0;
//global_name="";
//final="";
//thump_list.clear();
scene_number="";
full_scene_name="";
full_shot_name="";
total_rows=0;
total_rows1=1;
selection_value=0;
selection_value1=0;
selec=0;
rows_altered=0;
rows_altered1=0;
k1=0;
zxc=0;	
scene_shot_check_flag=0;
shot_flag=0;
drop_flag=0;
del_flag=0;
Goocanvas::Bounds ram;
my_scene_number=1;
/*Thumbnail*/
add_scn_status=0;
shot_parse_status=0;
/*Pdf*/
ij=0;
abc11=""; 
/*Pdf*/

/*xml*/
xml_scene_overall_tag.clear(); 
xml_kalanjiyam_overall_tag.clear(); 


global_temp_scene_xml="";
polyline_tag="";
curve_tag="";
/*xml*/

open_global_fillcolor_hex= g_strdup_printf("#%02x%02x%02x",(gint) 255,(gint) 255,(gint) 255);
open_global_strokecolor_hex=g_strdup_printf("#%02x%02x%02x",00000,00000,00000);


//Gtk::ToolButton* pfull = 0;
group_item_no=0; //Group
grouping_flag=0; //Group
global_move_status = 0;
button_press_status = 1;
on_parse_value_status = 0;

child_num=0;
last_child_num=0;
move_var=0;
child_var=0;
polyline_cnt=0;
curve_cnt=0;
curve_rect_num=0;
dragging_var=0;
starting_x=0.0; //double
group_var=""; 
xx1=0.0;yy1=0.0;xx2=0.0;yy2=0.0;xx3=0.0;yy3=0.0;xx4=0.0;yy4=0.0;xx5=0.0;yy5=0.0;xx6=0.0;yy6=0.0;xx7=0.0;yy7=0.0;xx8=0.0;yy8=0.0;
ww1=0.0;hh1=0.0; //double

/*Group*/
grp_xx=0.0;//double
grp_yy=0.0;//double
grp_ww=0.0;//double
grp_hh=0.0;//double
group_child_total_list.clear();
group_child_total_list_buffer.clear();
group_child_no.clear();
group_child_buffer_no.clear();
group_child_buffer1_no.clear();
grouped_child_no.clear();
eraser_grouped_child_no.clear();
group_child_region_no.clear();
group_xx.clear();
group_yy.clear();
group_end_xx.clear();
group_end_yy.clear();
/*Group*/

global_group_status=0;
copy_status=0;
copy_tag_vector.clear();
copy_group_temp_vector.clear();
copy_single_temp_vector.clear();
copy_single_index_temp_vector.clear();

/*Undo-Redo*/
undo_redo_tag_vector.clear();
undo_redo_child_number_vector.clear();
undo_redo_delete_status_vector.clear();
undo_redo_position_vector.clear();
undo_redo_buffer_for_group.clear();
undo_redo_buffer_for_ungroup.clear();
standing_position=0;
undo_status=0;
undo_count=0;
action_status=0;
group_select=0;
copy_paste_status=0;
standing_position_value=0;
/*Undo-Redo*/

curve_var="";


/* Kalanjiyam Info */

SceneNumber="";
ShotNumber="";
ShotType="";
TotalFrames="";
SceneTitle="";
Dialogue="";
ActionNotes="";
AudioNotes="";
scene_shot_comparision_status = 0;
/* Kalanjiyam Info*/



/*SpinButton*/
border_width=1;
eraser_width=1;
border_x_radius=0;
border_y_radius=0;
open_node_name = "";
open_node_value = "";
open_attr_name = "";
open_attr_value = "";
/*SpinButton*/


//dir_to_show_names.clear();
str="";
str1="";

/*xml vector*/
img_tmp_path = "/tmp/Kalanjiyam/Images/";
thumbnail_tmp_path = "/tmp/Kalanjiyam/Thumbnails/";
active_file_name = "";
active_folder_name = "";
SaveAs_file_name = "";
pdf_folder_path = "";

/*Open-drawing-variables*/
open_global_x=0.0;
open_global_y=0.0;
open_global_width=0.0;
open_global_height=0.0;
open_global_strokecolor="";
open_global_fillcolor="";
open_global_linewidth=0;
open_global_xposition = 0;
open_global_yposition = 0;
open_global_centerx=0.0;
open_global_centery=0.0;
open_global_xradius=0;
open_global_yradius=0;
open_global_x1=0.0;
open_global_y1=0.0;
open_global_x2=0.0;
open_global_y2=0.0;
open_global_data="";
open_global_font="";
/*Open-drawing-variables*/

zoom_step_count = 0;

//Image image;
loaded_img_count = 1;

scno=0;
shno=0;
s6="";
s7="";
result="";
char_ShotNumber="";
char_SceneNumber="";

flag_sample=0;
drawing_tool_number = 0; 


correct_scene_shot_position_occured = 0;
global_current_scene_number = 1;
global_current_shot_number = 1;
global_total_panels_in_thumbnail = 1;

global_scene_shot_number_list_vector.clear();

flag_delete=0;
zxc_flag=0;
scene_number_for_use = 1;
shot_number_for_use = 1;
flag_delete1=0;

ctr_pt_press=0;
item_pos=0;
col_flag=0;
//gint response; 
//Glib::RefPtr<Goocanvas::Item> my_item;
vec_pos=0;
edit_flag =0;
fillcolor = g_strdup_printf("#%02x%02x%02x",(gint) 255,(gint) 255,(gint) 255);
strokecolor =g_strdup_printf("#%02x%02x%02x",00000,00000,00000);

/*Raise*/
raise_current_child_temp_vector.clear();
raise_next_child_temp_vector.clear();
current_clicked_item=0;
/*Raise*/

to_create_thumbnail1_dot_png_initially = 1;
source_index=0;
release_index=0;
ConfirmStatus=0;

save_file_name="";

scene_sel=0;
shot_sel=0;
scene_sel_flag=0;
global_number_of_children=0;

/*Pdf*/
global_char_projectname="";
global_char_projectclient="";
global_char_projectcopy="";
global_char_projectsize="";
ProjectName="";
ProjectClient="";
ProjectCopyright="";
Projectsize="";
/*Pdf*/

text_edit_index_value=0;
on_description_save=0;

//For Eraser tool starts
value_of_x="";
value_of_y="";
value_of_xx="";
value_of_yy="";
find_child_item=0;
path_old_x=0.0; path_old_y=0.0; last_motion_x=0.0; last_motion_y=0.0;

my_str1_tag_modified.clear();
my_str1_tag_modified1.clear();
erased_value="";

erased_path_merge_data="";
erased_path_merge1_data="";  
erase_flag = 0;
my_str1_last_tag_modified="";
my_str1_tag="";
count_for_my_str1=0;
brush_var1="";
split_x_y.clear();  
combined_x_y.clear(); 
eraser_status = 0;
button_press_x =0.0;
button_release_x=0.0;
button_press_y =0.0;
button_release_y=0.0;
global_x_diff =0.0;
global_y_diff =0.0;
different_move_x =0.0;
different_move_y =0.0;
press_x_y=""; 
image_eraser_undo_status=0;

number_for_image=0;

eraser_drag_flag = 0;


split_width_height.clear();  
combined_width_height.clear();  

for_image_indentification.clear();  

event_y_pos=0;
event_x_pos=0;

button_press_width =0;
button_release_width=0;
button_press_height =0;
button_release_height=0;

global_width_diff =0;
global_height_diff =0;

different_move_width =0;
different_move_height =0;


press_width_height.clear(); 
image_edit_status=0;


store_brush_value_for_erase.clear();
store_brush_value_for_erase1.clear();

first_vector_for_eraser.clear(); 
second_vector_for_eraser.clear(); 

eraser_release_cnt=1;
z_count=0;
//For Eraser tool ends
open_node_name_ellipse="open";
open_node_name_ellipse_string="2";
open_node_name_curve=0;
come_from_line_change =0;
m_count=0;
//For Eraser tool ends

open_node_name_line="open1";
open_node_name_line_string="2";

child_find=0;
flag_set_for_find_child=0;
changed_item_num=0;
erase_dragging_status = 0;
for_image_set = 0;
//For Eraser tool ends
open_global_python_data="";

active_file_name1 = "";
active_file_name2 = "";
active_file_name3 = "";

cancel_flag=0;
flag_for_replace=0;
ok_flag=0;

text_status=0;
wid=0;
hei=0;
for_grp_check = 0;
path_tag_after_eraser="";
my_str1_tag_modified5="";
erase_flag=0;
}




bool KalanjiyamWindow::image_resize(double path_old_x, double path_old_y, double last_motion_x, double last_motion_y)
{
double path_diff_x ;
double path_diff_y ;
double x_fact, y_fact;

float new_value_for_add, new_value_for_add1;

string new_value_for_add_str,new_value_for_add_str1,x_fact_str,y_fact_str;



if(control_point_number==1)
{
path_diff_x = path_old_x - last_motion_x;
path_diff_y = path_old_y - last_motion_y;





new_value_for_add=open_global_xposition+open_global_width;

new_value_for_add1=open_global_yposition+open_global_height;




}
else if(control_point_number==2)
{

path_diff_x = last_motion_x - path_old_x;
path_diff_y = path_old_y - last_motion_y;


new_value_for_add=open_global_xposition;

new_value_for_add1=open_global_yposition+open_global_height;

//path_diff_x = path_old_x - last_motion_x;
//path_diff_y = path_old_y - last_motion_y;

}
else if(control_point_number==3)
{

path_diff_x = path_old_x - last_motion_x;
path_diff_y = last_motion_y - path_old_y;

new_value_for_add=open_global_xposition+open_global_width;

new_value_for_add1=open_global_yposition;

}
else if(control_point_number==4)
{
path_diff_x = last_motion_x - path_old_x;
path_diff_y = last_motion_y - path_old_y;

new_value_for_add=open_global_xposition;

new_value_for_add1=open_global_yposition;

}
else if(control_point_number==5)
{
// path_diff_x = last_motion_x - path_old_x;

path_diff_x = 0;
path_diff_y = path_old_y - last_motion_y;


new_value_for_add=open_global_xposition+(open_global_width/2);

new_value_for_add1=open_global_yposition+open_global_height;



}
else if(control_point_number==6)
{
//	 path_diff_x = last_motion_x - path_old_x;
// path_diff_y = last_motion_y - path_old_y;


path_diff_x = 0;
path_diff_y = last_motion_y - path_old_y;
new_value_for_add=open_global_xposition+(open_global_width/2);

new_value_for_add1=open_global_yposition;


}
else if(control_point_number==7)
{
path_diff_x = path_old_x - last_motion_x;
//path_diff_y = last_motion_y - path_old_y;
path_diff_y = 0;

new_value_for_add=open_global_xposition+open_global_width;

new_value_for_add1=open_global_yposition+(open_global_height/2);
}
else if(control_point_number==8)
{
path_diff_x = last_motion_x - path_old_x;
path_diff_y = last_motion_y - path_old_y;


new_value_for_add=open_global_xposition;

new_value_for_add1=open_global_yposition+(open_global_height/2);
}


x_fact = (path_diff_x+open_global_width)/open_global_width;
y_fact = (path_diff_y+open_global_height)/open_global_height;


x_fact_str = boost::lexical_cast<std::string>(x_fact);
y_fact_str = boost::lexical_cast<std::string>(y_fact);

const char *x_fact1 =  x_fact_str.c_str();
const char *y_fact1 =  y_fact_str.c_str();



new_value_for_add_str = boost::lexical_cast<std::string>(new_value_for_add);
new_value_for_add_str1 = boost::lexical_cast<std::string>(new_value_for_add1);



const char *x_val1 = new_value_for_add_str.c_str();
const char *y_val1 = new_value_for_add_str1.c_str();

first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
my_str1_tag=open_global_data;
stringstream stream(my_str1_tag);
int i=0;
int line_check=0;
//

	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);


			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;


	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}
	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}


}

bool KalanjiyamWindow::group_image_resize(int child_number_for_image_int, double path_old_x, double path_old_y, double last_motion_x, double last_motion_y)
{

Glib::RefPtr<Goocanvas::Item> root = m_canvas.get_root_item();

double path_diff_x ;
double path_diff_y ;
double x_fact, y_fact;

float new_value_for_add, new_value_for_add1;

string new_value_for_add_str,new_value_for_add_str1,x_fact_str,y_fact_str;

if(control_point_number==1)
{
path_diff_x = path_old_x - last_motion_x;
path_diff_y = path_old_y - last_motion_y;



new_value_for_add=for_group_xx+for_group_ww;
new_value_for_add1=for_group_yy+for_group_hh;



}
else if(control_point_number==2)
{

path_diff_x = last_motion_x - path_old_x;
path_diff_y = path_old_y - last_motion_y;


new_value_for_add=for_group_xx;

new_value_for_add1=for_group_yy+for_group_hh;


}
else if(control_point_number==3)
{

path_diff_x = path_old_x - last_motion_x;
path_diff_y = last_motion_y - path_old_y;

new_value_for_add=for_group_xx+for_group_ww;

new_value_for_add1=for_group_yy;

}
else if(control_point_number==4)
{
path_diff_x = last_motion_x - path_old_x;
path_diff_y = last_motion_y - path_old_y;

new_value_for_add=for_group_xx;

new_value_for_add1=for_group_yy;

}
else if(control_point_number==5)
{
// path_diff_x = last_motion_x - path_old_x;

path_diff_x = 0;
path_diff_y = path_old_y - last_motion_y;


new_value_for_add=for_group_xx+(for_group_ww/2);

new_value_for_add1=for_group_yy+for_group_hh;



}
else if(control_point_number==6)
{
//	 path_diff_x = last_motion_x - path_old_x;
// path_diff_y = last_motion_y - path_old_y;


path_diff_x =0;
path_diff_y = last_motion_y - path_old_y;

new_value_for_add=for_group_xx+(for_group_ww/2);

new_value_for_add1=for_group_yy;

}
else if(control_point_number==7)
{
path_diff_x = path_old_x - last_motion_x;
//path_diff_y = last_motion_y - path_old_y;
path_diff_y = 0;

new_value_for_add=for_group_xx+for_group_ww;

new_value_for_add1= for_group_yy+(for_group_hh/2);
}
else if(control_point_number==8)
{
path_diff_x = last_motion_x - path_old_x;
path_diff_y = 0;


new_value_for_add=for_group_xx;

new_value_for_add1=for_group_yy+(for_group_hh/2);
}


x_fact = for_group_ww/(for_group_ww-path_diff_x);
y_fact = for_group_hh/(for_group_hh-path_diff_y);




x_fact_str = boost::lexical_cast<std::string>(x_fact);
y_fact_str = boost::lexical_cast<std::string>(y_fact);

const char *x_fact1 =  x_fact_str.c_str();
const char *y_fact1 =  y_fact_str.c_str();


new_value_for_add_str = boost::lexical_cast<std::string>(new_value_for_add);
new_value_for_add_str1 = boost::lexical_cast<std::string>(new_value_for_add1);


const char *x_val1 = new_value_for_add_str.c_str();
const char *y_val1 = new_value_for_add_str1.c_str();

first_vector_for_eraser.clear();
second_vector_for_eraser.clear();
string my_str1_tag_modified3;
string strvalue1;
string strvalue2;
my_str1_tag=open_global_data;


open_global_python_data = "";
stringstream stream(my_str1_tag);
int i=0;
int line_check=0;
//

	z_count=0; 
	while( getline(stream, strvalue1, ' ') )
	{
	  if(strvalue1=="z" || strvalue1=="Z")
	  {
		z_count++;
		first_vector_for_eraser.push_back("z");
	  }
	  if(strvalue1!="M" && strvalue1!="L" && strvalue1!="z"  && strvalue1!="Z")
	  {
		if(i==0)
		{
		  strvalue2=strvalue1;
		  i++;
		}
		else
		{
		  strvalue2=strvalue2+","+strvalue1;
		  first_vector_for_eraser.push_back(strvalue2);
		  i=0;
		}
	  }
	}

	if(z_count<2)
	{
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(i==0)
			my_str1_tag_modified3="[("+first_vector_for_eraser[i]+")";
			else if(i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]";
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}
	else if(z_count>=2)
	{
		int z_cnt=1, j=0;
		for(int i=0; i<first_vector_for_eraser.size(); i++)
		{
			if(j==0)
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"[("+first_vector_for_eraser[i]+")";
				j++;
			}
			else if(z_cnt==1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], [";
				j=0; z_cnt++;
			}
			else if(z_count==z_cnt && i==first_vector_for_eraser.size()-1)
			my_str1_tag_modified3=my_str1_tag_modified3+"]]";
			else if(z_cnt>1 && first_vector_for_eraser[i]=="z")
			{
				my_str1_tag_modified3=my_str1_tag_modified3+"], ";
				j=0; z_cnt++;
			}
			else
			my_str1_tag_modified3=my_str1_tag_modified3+", ("+first_vector_for_eraser[i]+")";
		}
	}

Glib::locale_from_utf8(my_str1_tag_modified3);
const char *c = my_str1_tag_modified3.c_str();
const char *open_global_python_data1 = open_global_python_data.c_str();

PyObject *main = PyImport_AddModule("__main__"); // borrowed
if (main == NULL)
	//error();
return 0;
PyObject *globals = PyModule_GetDict(main); // borrowed
PyObject *value = PyString_FromString(c);
if (value == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "n", value) < 0)
return 0;
   //error();
Py_DECREF(value);
PyObject *py_data = PyString_FromString(open_global_python_data1);
if (py_data == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "pythondata", py_data) < 0)
return 0;
   //error();
Py_DECREF(py_data);
PyObject *value1 = PyString_FromString(x_val1);
if (value1 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_o", value1) < 0)
return 0;
   //error();
Py_DECREF(value1);
PyObject *value2 = PyString_FromString(y_val1);
if (value2 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_o", value2) < 0)
return 0;
   //error();
Py_DECREF(value2);
PyObject *value3 = PyString_FromString(x_fact1);
if (value3 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "x_f", value3) < 0)
return 0;
   //error();
Py_DECREF(value3);
PyObject *value4 = PyString_FromString(y_fact1);
if (value4 == NULL)
return 0;
   //error();
if (PyDict_SetItemString(globals, "y_f", value4) < 0)
return 0;
   //error();
Py_DECREF(value4);


			  PyRun_SimpleString("import ast\n"
"from shapely.geometry import Polygon, MultiPolygon\n"
"from shapely import affinity\n"
"from shapely.geometry import *\n"
"from shapely.ops import cascaded_union\n"
"splitmultipoly = pythondata.split(')), ((')\n"
"if len(splitmultipoly) == 1:\n"
"	eras = n.split('], [[')\n"
"	if len(eras) == 1:\n"
"		a= ast.literal_eval(n)\n"
"		A = Polygon(a)\n"
"	else:\n"
"		str1 = '[' + n + ']'\n"
"		c= ast.literal_eval(str1)\n"
"		A = Polygon(c[0],c[1])\n"
"	A = A.buffer(0)\n"
"else:\n"
"	Multipo = pythondata\n"
"	Multipo = Multipo.replace('MULTIPOLYGON (((','[(')\n"
"	Multipo = Multipo.replace(')))','))')\n"
"	Multipo = Multipo.replace(', ((','split[(')\n"
"	Multipo = Multipo.replace('))',')]')\n"
"	Multipo = Multipo.replace('), (',')],[(')\n"
"	Multipo = Multipo.replace(', ','),(')\n"
"	Multipo = Multipo.replace(' ',',')\n"
"	Multipo = Multipo.split('split')\n"
"	s = []\n"
"	for i in Multipo:\n"
"		a = i.split('],[')\n"
"		if len(a) >=2:\n"
"			i = i.replace('],[','],[[',1)\n"
"			i = '[' + i + ']]'\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i[0],i[1]))\n"
"		else:\n"
"			i = ast.literal_eval(i)\n"
"			s.append(Polygon(i))\n"
"	A = cascaded_union(s)\n"
"erase = affinity.scale(A, xfact=float(x_f), yfact=float(y_f), origin=(float(x_o),float(y_o)))\n"
"eraser=str(erase)\n"
"f=open('file.txt','w')\n"
"f.write(eraser)\n"
"f=open('file.txt','r')\n"
"text=f.read()\n");

PyObject * module = PyImport_AddModule("__main__"); // borrowed reference
PyObject * dictionary = PyModule_GetDict(module);   // __main__ should have a dictionary
PyObject * eraser = PyDict_GetItemString(dictionary, "text");
string erase_value = PyString_AsString(eraser);
PyObject * er_val = PyDict_GetItemString(dictionary, "eraser");
string er_val1 = PyString_AsString(er_val);
open_global_python_data = er_val1;



	string first_value = erase_value.substr(0,1);
	if(first_value=="M")
	{
	boost::replace_all(erase_value, "MULTIPOLYGON", "POLYGON");
	boost::replace_all(erase_value, "((", "(");
	boost::replace_all(erase_value, "))", ")");
	}

	string token, mystring(erase_value), mystring1;
	int loop_cnt=1;
	while(token != mystring)
	{
	  token = mystring.substr(0,mystring.find_first_of(")"));
	  mystring = mystring.substr(mystring.find_first_of(")") + 1);
	  if(mystring.size()==0)
	  break;
	  if(loop_cnt==1)
	  mystring1 = token.substr(10,token.size()-10);
	  else
	  mystring1 = token.substr(3,token.size()-3);

	  second_vector_for_eraser.push_back(mystring1);

	  loop_cnt++;

	}


	open_global_data="";
	for(int i=0; i<second_vector_for_eraser.size(); i++)
	{ 
	  open_global_data=open_global_data+"M ";
	  string old_data = second_vector_for_eraser[i];
	  string tok, mystr(old_data);
	  int loop_count=1;
	  while(tok != mystr)
	  {
		tok = mystr.substr(0,mystr.find_first_of(","));
		mystr = mystr.substr(mystr.find_first_of(",") + 1);
		if(loop_count==1)
		{
	  	  open_global_data=open_global_data+tok;
		}
		else
		{
		  open_global_data=open_global_data+" L"+tok;
		}
		loop_count++;
	  }
	  open_global_data=open_global_data+" z ";
	}

		Glib::RefPtr<Goocanvas::Item> img1 = root->get_child(child_number_for_image_int);

		img1->set_property("clip_path",open_global_data);

		img1->set_property("scale_to_fit",true);


}

